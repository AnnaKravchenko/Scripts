{
  "lib": {
    "/cell-dynamic-html-start.py": {
      "data": "import jinja2\n\nparams = PINS.DYNAMIC_HTML_PARAMS.get()\ntmpl = PINS.DYNAMIC_HTML_TEMPLATE.get()\nvars_ = []\nvars_full = []\nfor var_name, v in params[\"vars\"].items():\n    vv = v[0]\n    vars_.append(vv)\n    chars = \".[]{}\"\n    full_var = True\n    for char in chars:\n        if char in vv:\n            full_var = False\n            break\n    if full_var:\n        vars_full.append(vv)\ndynamic_html0 = jinja2.Template(tmpl).render(\n    {\"vars\": vars_, \"vars_full\": vars_full}\n)\n\nfrom seamless.websocketserver import websocketserver\nwebsocketserver.start() #no-op if the websocketserver has already started\n\ndynamic_html = jinja2.Template(dynamic_html0).render({\n    \"IDENTIFIER\": IDENTIFIER,\n    \"socket\": websocketserver.socket,\n})\nPINS.dynamic_html.set(dynamic_html)\n\ndef update(on_start):\n    do_evals = set()\n    for var_name in params[\"vars\"]:\n        pin = getattr(PINS, var_name)\n        if not pin.updated:\n            continue\n        value = pin.get()\n        var, evals = params[\"vars\"][var_name]\n        msg = {\"type\":\"var\", \"var\": var, \"value\": value}\n        #print(\"MSG\", msg, IDENTIFIER)\n        websocketserver.send_message(IDENTIFIER, msg)\n        for e in evals:\n            do_evals.add(e)\n    for html_name in params[\"html\"]:\n        pin = getattr(PINS, html_name)\n        if not pin.updated:\n            continue\n        value = pin.get()\n        id_ = params[\"html\"][html_name]\n        msg = {\"type\":\"html\", \"id\": id_, \"value\": value}\n        #print(\"MSG\", msg, IDENTIFIER)\n        websocketserver.send_message(IDENTIFIER, msg)\n    for e in params[\"evals\"]:\n        do_eval = False\n        do_on_start = params[\"evals\"][e]\n        if on_start:\n            if do_on_start == True:\n                do_eval = True\n            elif do_on_start == False:\n                do_eval = False\n            else:\n                do_eval = (e in do_evals)\n        else:\n            do_eval = (e in do_evals)\n        if do_eval:\n            pin = getattr(PINS, e)\n            value = pin.get()\n            msg = {\"type\":\"eval\", \"value\": value}\n            #print(\"MSG\", msg, IDENTIFIER)\n            websocketserver.send_message(IDENTIFIER, msg)\n\nupdate(on_start=True)\n",
      "links": [
        "dynamic_html_maker.cell2"
      ]
    },
    "/cell-filelink-start.py": {
      "data": "if __name__ == \"__main__\":\n    #test with ipython -i\n    import sys, os\n\n    class dummy:\n        pass\n\n    class EditPin:\n        def __init__(self, value):\n            self.value = value\n            self.defined = True\n        def set(self, value):\n            print(\"SET\", value)\n            self.value = value\n        def get(self):\n            return self.value\n\n    class Getter:\n        def __init__(self, arg):\n            self.arg = arg\n        def get(self):\n            return self.arg\n    PINS = dummy()\n    PINS.value = EditPin(\"test\")\n    directory = sys.argv[1]\n    filename = sys.argv[2]\n    PINS.filepath = Getter(os.path.join(directory, filename))\n    PINS.latency = Getter(float(sys.argv[3]))\n    def serializer(v):\n        return str(v.get())\n    print(\"Edit in \" + filepath.get())\nelse:\n    from seamless.dtypes import serialize\n    def serializer(v):\n        return serialize(v._dtype, v.get())\n\n\nimport os, time, functools, traceback\nfrom threading import Thread, RLock, Event\nlast_value = None\nlast_serialized_value = None\nlast_exc = None\nlast_mtime = None\n\ndef write_file(fpath):\n    global last_mtime, last_value, last_serialized_value\n    if not PINS.value.defined:\n        last_mtime = -1 #will trigger a file read\n        return\n    if last_value == PINS.value.get():\n        return\n    val = serializer(PINS.value)\n    if last_serialized_value == val:\n        return\n    with lock:\n        if last_serialized_value != val:\n            #print(\"WRITE\", val)\n            if PINS.value._dtype == \"object\":\n                with open(fpath, \"wb\") as f:\n                    f.write(val)\n                    last_value = PINS.value.get()\n                    last_serialized_value = val\n            else:\n                with open(fpath, \"w\", encoding=\"utf-8\") as f:\n                    f.write(val)\n                    last_value = PINS.value.get()\n                    last_serialized_value = val\n            last_time = time.time()\n            try:\n                stat = os.stat(fpath)\n                last_mtime = stat.st_mtime\n            except Exception:\n                pass\n\nsleeptime = 0.01\n\ndef poll():\n    global last_time, last_mtime, last_value, last_serialized_value, last_exc\n    fpath = PINS.filepath.get()\n    while 1:\n        sleeps = int(PINS.latency.get() / sleeptime + 0.9999)\n        for n in range(sleeps):\n            time.sleep(sleeptime)\n            if terminate.is_set():\n                break\n        if terminate.is_set():\n            break\n        curr_time = time.time()\n        last_time = curr_time\n        if not os.path.exists(fpath):\n            try:\n                write_file(fpath)\n            except Exception:\n                exc = traceback.format_exc()\n                if exc != last_exc:\n                    print(exc)\n                    last_exc = exc\n        else:\n            with lock:\n                stat = os.stat(fpath)\n                try:\n                    if last_mtime is None or stat.st_mtime > last_mtime:\n                        data = None\n                        if PINS.value._dtype == \"object\":\n                            with open(fpath, \"rb\") as f:\n                                data = f.read()\n                        else:\n                            with open(fpath, encoding=\"utf-8\") as f:\n                                data = f.read()\n                        if data is not None:\n                            if last_serialized_value != data:\n                                #print(\"LOAD\")\n                                PINS.value.set(data)\n                                last_value = None\n                                last_serialized_value = data\n                        last_mtime = stat.st_mtime\n                except Exception:\n                    exc = traceback.format_exc()\n                    if exc != last_exc:\n                        print(exc)\n                        last_exc = exc\n\nterminate = Event()\nt = Thread(target=poll)\nt.setDaemon(True)\nlock = RLock()\nwrite_file(PINS.filepath.get())\nt.start()\n",
      "links": [
        "links.html.cell1",
        "links.template_html_head_body.cell1",
        "links.params_templateer_static.cell1",
        "links.template_head.cell1",
        "links.title.cell1",
        "links.template_body.cell1",
        "links.plotly_data.cell1",
        "links.plotly_layout.cell1",
        "links.plotly_config.cell1",
        "links.code_integrate_data.cell1",
        "links.data.cell1",
        "links.attrib.cell1",
        "links.code_load_data_columns.cell1",
        "links.csv.cell1",
        "links.html_dynamic.cell1",
        "links.template_body_dynamic.cell1"
      ]
    },
    "/cell-templateer.py": {
      "data": "import jinja2, jinja2.meta\nimport json\n\nenv = {}\ndepsgraph = {}\ntemplates = []\njenv = jinja2.Environment()\n\nclass Node:\n    _ignore_deps = [\"range\"]\n    def __init__(self, name):\n        self.name = name\n        self.template = None\n        self.template_code = None\n        self.up_to_date = False\n        self.template_deps = []\n        self.env_deps = []\n        self.dependees = []\n\n    def render(self, visited=None):\n        if self.up_to_date:\n            return env[self.name]\n\n        if self.template is None:\n            raise RuntimeError(\"Cannot render template '{0}'\" % self.name)\n        if visited is None:\n            visited = []\n        if self.name in visited:\n            cycle = visited[visited.index(self.name):] + [self.name]\n            raise RuntimeError(\"Cyclic template dependency: {0}\".format(cycle))\n        visited.append(self.name)\n\n        for dep in sorted(self.template_deps):\n            #print(\"DEP\", self.name, dep)\n            depsgraph[dep].render(visited)\n        result = self.template.render(env)\n        self.up_to_date = True\n        #print(\"RENDER\", self.name)\n        env[self.name] = result\n        return result\n\n    def set_dirty(self):\n        self.up_to_date = False\n        for dependee in self.dependees:\n            depsgraph[dependee].set_dirty()\n\n    def set_template(self, template_code):\n        if template_code == self.template_code:\n            return\n        self.template_code = template_code\n        self.template = None\n        self.set_dirty()\n        ast = jenv.parse(template_code)\n        deps = jinja2.meta.find_undeclared_variables(ast)\n        new_env_deps = []\n        new_template_deps = []\n        for d in sorted(deps):\n            if d in env:\n                new_env_deps.append(d)\n            elif d in templates:\n                new_template_deps.append(d)\n            elif d in self._ignore_deps:\n                continue\n            else:\n                raise RuntimeError(\"Unknown dependency: '{0}'\".format(d))\n        self.template = jinja2.Template(ast)\n        for dep in self.template_deps + self.env_deps:\n            depsgraph[dep].dependees.remove(self.name)\n        self.env_deps = new_env_deps\n        self.template_deps = new_template_deps\n        for dep in self.template_deps  + self.env_deps:\n            depsgraph[dep].dependees.append(self.name)\n\ndef make_template():\n    global result_template\n    import jinja2\n    tempdef = PINS.TEMPLATE_DEFINITION.get()\n    if PINS.TEMPLATE_DEFINITION.updated:\n        env.clear()\n        depsgraph.clear()\n        templates[:] = tempdef[\"templates\"]\n        result_template = tempdef.get(\"result\", None)\n        if len(templates) > 1:\n            assert result_template is not None\n        else:\n            result_template = templates[0]\n        assert result_template in templates, (result_template, templates)\n\n    tempdef = PINS.TEMPLATE_DEFINITION.get()\n    environment = tempdef[\"environment\"]\n\n    env_updates = list()\n    for k, v in environment.items():\n        inp = getattr(PINS, k)\n        if inp.updated or k not in env:\n            val = inp.get()\n            if isinstance(val, (bytes, str)):\n                sval = val\n            else:\n                sval = json.dumps(val, indent=2)\n            env[k] = sval\n            env_updates.append(k)\n\n    for k in env_updates:\n        if k not in depsgraph:\n            node = Node(k)\n            node.up_to_date = True\n            depsgraph[k] = node\n        for nodename in depsgraph[k].dependees:\n            depsgraph[nodename].set_dirty()\n\n    templ_updates = []\n    for t in templates:\n        template = getattr(PINS, t)\n        if template.updated or t not in depsgraph:\n            if t not in depsgraph:\n                node = Node(t)\n                depsgraph[t] = node\n            templ_updates.append(t)\n    for t in templ_updates:\n        template = getattr(PINS, t)\n        node = depsgraph[t]\n        node.set_template(template.get())\n\n    firstnode = depsgraph[result_template]\n    result = firstnode.render()\n\n    PINS.RESULT.set(result)\n",
      "links": [
        "templateer_static.cell3",
        "templateer_dynamic.cell3"
      ]
    },
    "/dynamic-html.jinja": {
      "data": "<script>\n{% for var in vars_full %}\n    var {{var}} = null;\n{% endfor %}\n    var ws = new WebSocket(\"ws://127.0.0.1:{% raw %}{{socket}}{% endraw %}/\");\n    ws.onopen = function () {\n        ws.send(\"{% raw %}{{IDENTIFIER}}{% endraw %}\");\n    }\n    ws.onmessage = function (event) {\n        var message = JSON.parse(event.data);\n        if (message.type == \"var\") {\n          if (0) {}\n          {% for var in vars %}\n          else if (message.var == \"{{var}}\") {\n            {{var}} = message.value;\n          }\n          {% endfor %}\n        }\n        else if (message.type == \"html\") {\n          var ele = document.getElementById(message.id);\n          ele.innerHTML = message.value;\n        }\n        else if (message.type == \"eval\") {\n          eval(message.value);\n        }\n    };\n</script>\n",
      "links": [
        "dynamic_html_maker.cell6"
      ]
    },
    "/gui/cell-basic_display_UPDATE.py": {
      "data": "if PINS.value.updated:\n    b.setValue(PINS.value.get())\nif PINS.title.updated:\n    w.setWindowTitle(PINS.title.get())\n",
      "links": []
    },
    "/gui/cell-basic_display_float.py": {
      "data": "from seamless.qt.QtWidgets import QDoubleSpinBox, QWidget, QVBoxLayout\nfrom seamless.qt.QtCore import Qt\n\nw = QWidget()\n#w.setWindowFlags(Qt.WindowStaysOnTopHint)\nw.setAttribute(Qt.WA_ShowWithoutActivating)\nvbox = QVBoxLayout()\nvbox.addStretch(1)\nw.setLayout(vbox)\nw.resize(300,100)\nw.setWindowTitle(PINS.title.get())\nw.show()\nb = QDoubleSpinBox()\nb.setReadOnly(True)\nb.setSingleStep(0.1)\nb.setMaximum(1000000)\nb.setValue(PINS.value.get())\nvbox.addWidget(b)\n",
      "links": []
    },
    "/gui/cell-basic_display_html.py": {
      "data": "from seamless.qt.QtWidgets import QPlainTextEdit, QWidget, QVBoxLayout\nfrom seamless.qt.QtCore import Qt\nfrom PyQt5.QtGui import QColor\n\nw = QWidget()\n#w.setWindowFlags(Qt.WindowStaysOnTopHint)\nw.setAttribute(Qt.WA_ShowWithoutActivating)\nvbox = QVBoxLayout()\n#vbox.addStretch(1)\nw.resize(600,600)\nw.setLayout(vbox)\nw.setWindowTitle(PINS.title.get())\n\nw.show()\nb = QPlainTextEdit()\nb.setReadOnly(True)\n#b.setFontPointSize(15)\nb.setPlainText(PINS.value.get())\n#b.setFontItalic(True)\n#b.setTextColor(QColor(255,0,0))\nvbox.addWidget(b)\n",
      "links": []
    },
    "/gui/cell-basic_display_html_UPDATE.py": {
      "data": "if PINS.value.updated:\n    b.setPlainText(PINS.value.get())\nif PINS.title.updated:\n    w.setWindowTitle(PINS.title.get())\n",
      "links": []
    },
    "/gui/cell-basic_display_int.py": {
      "data": "from seamless.qt.QtWidgets import QSpinBox, QWidget, QVBoxLayout\nfrom seamless.qt.QtCore import Qt\n\nw = QWidget()\n#w.setWindowFlags(Qt.WindowStaysOnTopHint)\nw.setAttribute(Qt.WA_ShowWithoutActivating)\nvbox = QVBoxLayout()\nvbox.addStretch(1)\nw.setLayout(vbox)\nw.resize(300,100)\nw.setWindowTitle(PINS.title.get())\nw.show()\nb = QSpinBox()\nb.setReadOnly(True)\nb.setMaximum(1000000)\nb.setValue(PINS.value.get())\nvbox.addWidget(b)\n",
      "links": []
    },
    "/gui/cell-basic_display_json.py": {
      "data": "from seamless.qt.QtWidgets import QTextEdit, QWidget, QVBoxLayout\nfrom seamless.qt.QtCore import Qt\nfrom PyQt5.QtGui import QColor\nimport json\n\nw = QWidget()\n#w.setWindowFlags(Qt.WindowStaysOnTopHint)\nw.setAttribute(Qt.WA_ShowWithoutActivating)\nvbox = QVBoxLayout()\n#vbox.addStretch(1)\nw.resize(600,600)\nw.setLayout(vbox)\nw.setWindowTitle(PINS.title.get())\n\nw.show()\nb = QTextEdit()\nb.setReadOnly(True)\nb.setFontPointSize(15)\nb.setText(json.dumps(PINS.value.get(), indent=2))\n#b.setFontItalic(True)\n#b.setTextColor(QColor(255,0,0))\nvbox.addWidget(b)\n",
      "links": []
    },
    "/gui/cell-basic_display_json_UPDATE.py": {
      "data": "if PINS.value.updated:\n    b.setText(json.dumps(PINS.value.get(), indent=2))\nif PINS.title.updated:\n    b.setWindowTitle(PINS.title.get())\n",
      "links": []
    },
    "/gui/cell-basic_display_text.py": {
      "data": "from seamless.qt.QtWidgets import QTextEdit, QWidget, QVBoxLayout\nfrom seamless.qt.QtCore import Qt\nfrom PyQt5.QtGui import QColor\n\nw = QWidget()\n#w.setWindowFlags(Qt.WindowStaysOnTopHint)\nw.setAttribute(Qt.WA_ShowWithoutActivating)\nvbox = QVBoxLayout()\n#vbox.addStretch(1)\nw.resize(600,600)\nw.setLayout(vbox)\nw.setWindowTitle(PINS.title.get())\n\nw.show()\nb = QTextEdit()\nb.setReadOnly(True)\nb.setFontPointSize(15)\nb.setText(PINS.value.get())\n#b.setFontItalic(True)\n#b.setTextColor(QColor(255,0,0))\nvbox.addWidget(b)\n",
      "links": []
    },
    "/gui/cell-basic_display_text_UPDATE.py": {
      "data": "if PINS.value.updated:\n    b.setText(PINS.value.get())\nif PINS.title.updated:\n    w.setWindowTitle(PINS.title.get())\n",
      "links": []
    },
    "/gui/cell-basic_editor_UPDATE.py": {
      "data": "if PINS.value.updated:\n    b.setValue(PINS.value.get())\nif PINS.title.updated:\n    w.setWindowTitle(PINS.title.get())\n",
      "links": []
    },
    "/gui/cell-basic_editor_float.py": {
      "data": "from seamless.qt.QtWidgets import QDoubleSpinBox, QWidget, QVBoxLayout\nfrom seamless.qt.QtCore import Qt\n\nw = QWidget()\n#w.setWindowFlags(Qt.WindowStaysOnTopHint)\nw.setAttribute(Qt.WA_ShowWithoutActivating)\nvbox = QVBoxLayout()\nvbox.addStretch(1)\nw.setLayout(vbox)\nw.resize(300,100)\nw.setWindowTitle(PINS.title.get())\nw.show()\nb = QDoubleSpinBox()\nb.setSingleStep(0.01)\nb.setDecimals(3)\nb.setMaximum(1000000)\nif PINS.value.defined:\n    b.setValue(PINS.value.get())\nvbox.addWidget(b)\nb.valueChanged.connect(PINS.value.set)\n",
      "links": []
    },
    "/gui/cell-basic_editor_int.py": {
      "data": "from seamless.qt.QtWidgets import QSpinBox, QWidget, QVBoxLayout\nfrom seamless.qt.QtCore import Qt\n\nw = QWidget()\n#w.setWindowFlags(Qt.WindowStaysOnTopHint)\nw.setAttribute(Qt.WA_ShowWithoutActivating)\nvbox = QVBoxLayout()\nvbox.addStretch(1)\nw.setLayout(vbox)\nw.resize(300,100)\nw.setWindowTitle(PINS.title.get())\nw.show()\nb = QSpinBox()\nb.setMaximum(1000000)\nif PINS.value.defined:\n    b.setValue(PINS.value.get())\nvbox.addWidget(b)\nb.valueChanged.connect(PINS.value.set)\n",
      "links": []
    },
    "/gui/cell-basic_editor_int_UPDATE.py": {
      "data": "if PINS.value.updated:\n    b.setValue(PINS.value.get())\nif PINS.title.updated:\n    w.setWindowTitle(PINS.title.get())\nif PINS.maximum.updated:\n    b.setMaximum(PINS.maximum.get())\n",
      "links": []
    },
    "/gui/cell-basic_editor_json.py": {
      "data": "from seamless.qt.QtWidgets import QTextEdit, QWidget, QVBoxLayout\nfrom seamless.qt.QtCore import Qt\nfrom PyQt5.QtGui import QColor\nimport json\n\nw = QWidget()\n#w.setWindowFlags(Qt.WindowStaysOnTopHint)\nw.setAttribute(Qt.WA_ShowWithoutActivating)\nvbox = QVBoxLayout()\n#vbox.addStretch(1)\nw.resize(600,600)\nw.setLayout(vbox)\nw.setWindowTitle(PINS.title.get())\n\nclass MyTextEdit(QTextEdit):\n    def focusOutEvent(self, event):\n        PINS.value.set(self.toPlainText())\n        QTextEdit.focusOutEvent(self, event)\n\nw.show()\nb = MyTextEdit()\nb.setFontPointSize(15)\nif PINS.value.defined:\n    b.setText(json.dumps(PINS.value.get(), indent=2))\n#b.setFontItalic(True)\n#b.setTextColor(QColor(255,0,0))\nvbox.addWidget(b)\n",
      "links": []
    },
    "/gui/cell-basic_editor_json_UPDATE.py": {
      "data": "if PINS.value.updated:\n    b.setText(json.dumps(PINS.value.get(), indent=2))\nif PINS.title.updated:\n    w.setWindowTitle(PINS.title.get())\n",
      "links": []
    },
    "/gui/cell-basic_editor_text.py": {
      "data": "from seamless.qt.QtWidgets import QTextEdit, QMainWindow, QAction\nfrom seamless.qt.QtCore import Qt\nfrom PyQt5.QtGui import QColor\n\nw = QMainWindow()\n#w.setWindowFlags(Qt.WindowStaysOnTopHint)\nw.setAttribute(Qt.WA_ShowWithoutActivating)\nw.resize(600,600)\nw.setWindowTitle(PINS.title.get())\n\nclass MyTextEdit(QTextEdit):\n    def focusOutEvent(self, event):\n        PINS.value.set(self.toPlainText())\n        QTextEdit.focusOutEvent(self, event)\n\nw.show()\nb = MyTextEdit()\nb.setFontPointSize(15)\nw.setCentralWidget(b)\n\nsaveAction = QAction('&Save', w)\nsaveAction.setShortcut('Ctrl+S')\nsaveAction.setStatusTip('Save')\nsaveAction.triggered.connect(lambda: PINS.value.set(b.toPlainText()))\nw.menuBar().addAction(saveAction)\n\nif PINS.value.defined:\n    b.setText(PINS.value.get())\n#b.setFontItalic(True)\n#b.setTextColor(QColor(255,0,0))\n",
      "links": []
    },
    "/gui/cell-basic_editor_text_UPDATE.py": {
      "data": "if PINS.value.updated:\n    b.setText(PINS.value.get())\nif PINS.title.updated:\n    w.setWindowTitle(PINS.title.get())\n",
      "links": []
    },
    "/gui/cell-browser.py": {
      "data": "import os\nfrom seamless.qt.QtWebEngineWidgets import QWebEngineView\nfrom seamless.qt.Qt import QUrl\nfrom seamless.qt import QtWidgets, QtGui\n\nwidget = QWebEngineView()\nfake_url = QUrl.fromLocalFile(os.path.abspath(\"seamless.html\"))\nwidget.setWindowTitle(PINS.title.get())\nreloadAction = QtWidgets.QAction(QtGui.QIcon('exit.png'), '&Reload', widget)\nreloadAction.setShortcut('F5')\nreloadAction.setStatusTip('Reload')\nreloadAction.triggered.connect(widget.reload)\nwidget.addAction(reloadAction)\nwidget.setHtml(PINS.value.get(), fake_url)\nwidget.show()\n",
      "links": [
        "browser.cell2",
        "browser_dynamic.cell2"
      ]
    },
    "/gui/cell-browser_UPDATE.py": {
      "data": "if PINS.value.updated:\n    widget.setHtml(PINS.value.get(), fake_url)\nif PINS.title.updated:\n    widget.setWindowTitle(PINS.title.get())\n",
      "links": [
        "browser.cell4",
        "browser_dynamic.cell4"
      ]
    }
  },
  "macro": [
    {
      "with_context": false,
      "dtype": [
        "text",
        "code",
        "python"
      ],
      "type_args": [
        "json",
        "seamless",
        "reactor_params"
      ],
      "module_name": "seamless.core.reactor",
      "func_name": "reactor",
      "code": "@macro(type=(\"json\", \"seamless\", \"reactor_params\"),with_context=False)\ndef reactor(params):\n    \"\"\"Defines a reactor worker.\n\nReactors react upon changes in their input cells.\nReactors are connected to their input cells via inputpins. In addition, reactors\nmay manipulate output cells via outputpins. Finally, a cell may be both an\ninput and an output of the reactor, by connecting it via an editpin.\nThe pins are declared in the `params` parameter (see below).\n\nIn addition, all reactors have three implicit inputpins named `code_start`,\n`code_update` and `code_stop`. Each pin must be connected to a Python cell\n( `dtype=(\"text\", \"code\", \"python\")` ), containing a code block.\n\nThe reactor will start as soon as all input cells (including the three code cells)\nhave been defined. The startup of the reactor will trigger the execution of the\ncode in the `code_start` cell.\n\nAny change in the inputpins (including at startup)\nwill trigger the execution of the `code_update` cell. The `code_stop` cell is\ninvoked when the reactor is destroyed.\n\nAs of seamless 0.1, macro re-evaluation destroys and re-creates all reactors\ncreated by the macro, unless the macro has caching enabled.\n\nAll three code cells are executed in the same namespace. The namespace contains\nan object called `PINS`. This object can be queried for pin objects: a pin\ncalled `spam` is accessible as pin object ``PINS.spam``. The namespace also\ncontains IDENTIFIER, which is guaranteed to be unique for each reactor\ninstance.\n\nEvery inputpin and editpin object contains a ``get()`` method that\nreturns the value.\nAs of seamless 0.1, the `value` property is identical to ``pin.get()``.\n\nEvery inputpin and editpin object has a property `updated`, which is True if\nthe pin has been updated since the last time `code_update` was executed.\n\nEvery outputpin and editpin has a ``set(value)`` method.\nIn case of a signal outputpin, ``set()`` is to be invoked without argument.\nInvoking ``set()`` on a signal outputpin will propagate the signal as fast as possible:\n    - If set from the main thread: immediately. Downstream workers are\n      notified and activated (if synchronous) before set() returns\n    - If set from another thread: as soon as ``seamless.run_work`` is called.\n      Then, downstream workers are notified and activated before any other\n      non-signal notification.\n\nAs of seamless 0.1, all reactors are synchronous (blocking): their code is\nexecuted in the main thread. Therefore, seamless and IPython are non-responsive\nwhile reactor code is executing, and reactor code should return as soon as\npossible. Therefore, if they perform long computations, reactors should spawn\ntheir own threads or processes from within their code.\n\nInvoke ``reactor.status()`` to get the current status of the reactor\n\nInvoke ``shell(reactor)`` to create an IPython shell of the reactor namespace\n\n``pin.connect(cell)`` connects an outputpin to a cell\n\n``cell.connect(pin)`` connects a cell to an inputpin\n\n``pin.cell()`` returns or creates a cell that is connected to that pin\n\nParameters\n----------\n\n    params: dict\n        A dictionary containing the reactor parameters.\n        As of seamless 0.1, each (name,value) item represents a reactor pin:\n\n        -  name: string\n            name of the pin\n\n        -  value: dict\n            with the following items:\n\n            - pin: string\n                must be \"input\", \"output\" or \"edit\"\n            - dtype: string or tuple of strings\n                Describes the dtype of the cell(s) connected to the pin.\n                As of seamless 0.1, the following data types are understood:\n\n                -   \"int\", \"float\", \"bool\", \"str\", \"json\", \"cson\", \"array\", \"signal\"\n                -   \"text\", (\"text\", \"code\", \"python\"), (\"text\", \"code\", \"ipython\")\n                -   (\"text\", \"code\", \"silk\"), (\"text\", \"code\", \"slash-0\")\n                -   (\"text\", \"code\", \"vertexshader\"), (\"text\", \"code\", \"fragmentshader\"),\n                -   (\"text\", \"html\"),\n                -   (\"json\", \"seamless\", \"transformer_params\"),\n                    (\"cson\", \"seamless\", \"transformer_params\"),\n                -   (\"json\", \"seamless\", \"reactor_params\"),\n                    (\"cson\", \"seamless\", \"reactor_params\")\n\n            - must_be_defined: bool\n               default = True\n\n               In case of edit pins, if `must_be_defined` is False, the reactor\n               will start up  even if the connected cell does not yet have a\n               defined value.\n\n        Since \"reactor\" is a macro, the dictionary can also be provided\n        in the form of a cell of dtype (\"json\", \"seamless\", \"reactor_params\")\n\"\"\"\n    from seamless.core.reactor import Reactor #code must be standalone\n    return Reactor(params)\n"
    },
    {
      "with_context": false,
      "dtype": [
        "text",
        "code",
        "python"
      ],
      "type_args": [
        "json",
        "seamless",
        "transformer_params"
      ],
      "module_name": "seamless.core.transformer",
      "func_name": "transformer",
      "code": "@macro(type=(\"json\", \"seamless\", \"transformer_params\"), with_context=False)\ndef transformer(params):\n    \"\"\"Defines a transformer worker.\n\nTransformers transform their input cells into an output result.\nTransformers are connected to their input cells via input pins, and their\nresult is connected to an output cell via an output pin. There can be only one\noutput pin. The pins are declared in the `params` parameter (see below).\n\nIn addition, all transformers have an implicit input pin named \"code\",\nwhich must be connected to a Python cell ( `dtype=(\"text\", \"code\", \"python\")` ).\nThe code must be a Python block that returns the result using a \"return\" statement.\nAll input values are injected directly into the code's namespace. The variable\nname of the input is the same as its pin name.\n\nAs of seamless 0.1, all transformers are asynchronous (non-blocking),\nand they carry out their computation in a separate process\n(using ``multiprocessing``).\n\nAs of seamless 0.1, transformers start their computation as soon as all inputs\n(including the code) has been defined, even if no output cell has been connected.\nWhenever the input data or code changes, a new computation is performed. If the\nprevious computation is still in progress, it is canceled.\n\nInside the transformer code, preliminary values can be returned using\n``return_preliminary(value)``.\nAs of seamless 0.1, this does not require any special pin declaration.\n\nInvoke ``transformer.status()`` to get the current status of the transformer.\n\nInvoke ``shell(transformer)`` to create an IPython shell\nof the transformer namespace.\n\n``pin.connect(cell)`` connects an outputpin to a cell.\n\n``cell.connect(pin)`` connects a cell to an inputpin.\n\n``pin.cell()`` returns or creates a cell that is connected to that pin.\n\nParameters\n----------\n\n    params: dict\n        A dictionary containing the transformer parameters.\n\n        As of seamless 0.1, each (name,value) item represents a transformer pin:\n\n        -  name: string\n            name of the pin\n\n        -  value: dict\n            with the following items:\n\n            - pin: string\n                must be \"input\" or \"output\". Only one output pin is allowed.\n            - dtype: string or tuple of strings\n                Describes the dtype of the cell(s) connected to the pin.\n                As of seamless 0.1, the following data types are understood:\n\n                -   \"int\", \"float\", \"bool\", \"str\", \"json\", \"cson\", \"array\", \"signal\"\n                -   \"text\", (\"text\", \"code\", \"python\"), (\"text\", \"code\", \"ipython\")\n                -   (\"text\", \"code\", \"silk\"), (\"text\", \"code\", \"slash-0\")\n                -   (\"text\", \"code\", \"vertexshader\"), (\"text\", \"code\", \"fragmentshader\"),\n                -   (\"text\", \"html\"),\n                -   (\"json\", \"seamless\", \"transformer_params\"),\n                    (\"cson\", \"seamless\", \"transformer_params\"),\n                -   (\"json\", \"seamless\", \"reactor_params\"),\n                    (\"cson\", \"seamless\", \"reactor_params\")\n\n        Since \"transformer\" is a macro, the dictionary can also be provided\n        in the form of a cell of dtype (\"json\", \"seamless\", \"transformer_params\")\n\"\"\"\n    from seamless.core.transformer import Transformer #code must be standalone\n    return Transformer(params)\n"
    },
    {
      "with_context": true,
      "dtype": [
        "text",
        "code",
        "python"
      ],
      "type_args": "json",
      "module_name": "seamless.lib.dynamic_html",
      "func_name": "dynamic_html",
      "code": "@macro(\"json\")\ndef dynamic_html(ctx, params):\n    from seamless import reactor\n    from collections import OrderedDict\n    params2 = { \"vars\": OrderedDict(),\n                \"html\": OrderedDict(),\n                \"evals\": OrderedDict()\n              }\n    ed_params = {\n        \"DYNAMIC_HTML_PARAMS\": {\n            \"pin\": \"input\",\n            \"dtype\": \"json\"\n        },\n        \"DYNAMIC_HTML_TEMPLATE\": {\n            \"pin\": \"input\",\n            \"dtype\": \"text\"\n        },\n        \"dynamic_html\": {\n            \"pin\": \"output\",\n            \"dtype\": (\"text\", \"html\")\n        }\n    }\n    assert \"dynamic_html\" not in params\n    for k,v in params.items():\n        assert isinstance(v,dict), k\n        ed_param = {\"pin\": \"input\"}\n        type_ = v[\"type\"]\n        assert type_ in (\"var\", \"html\", \"eval\"), type_\n        if type_ == \"var\":\n            dtype = v.get(\"dtype\")\n            evals = v.get(\"evals\", [])\n            var = v.get(\"var\", k)\n            params2[\"vars\"][k] = (var, evals)\n            ed_param[\"dtype\"] = dtype\n        elif type_ == \"html\":\n            id_ = v.get(\"id\", k)\n            params2[\"html\"][k] = id_\n            ed_param[\"dtype\"] = (\"text\", \"html\")\n        else: #type_ = \"eval\"\n            on_start = v.get(\"on_start\", None)\n            params2[\"evals\"][k] = on_start\n            ed_param[\"dtype\"] = \"text\"\n        ed_params[k] = ed_param\n    for k,v in params2[\"vars\"].items():\n        var, evals = v\n        for e in evals:\n            assert e in params2[\"evals\"], (k, e, list(params2[\"evals\"].keys()))\n    rc = ctx.rc = reactor(ed_params)\n    rc.code_start.cell().fromfile(\"cell-dynamic-html-start.py\")\n    rc.code_update.cell().set(\"update(on_start=False)\")\n    rc.code_stop.cell().set(\"\")\n    rc.DYNAMIC_HTML_PARAMS.cell().set(params2)\n    rc.DYNAMIC_HTML_TEMPLATE.cell().fromfile(\"dynamic-html.jinja\")\n    ctx.export(rc)\n"
    },
    {
      "with_context": true,
      "dtype": [
        "text",
        "code",
        "python"
      ],
      "type_args": "str",
      "module_name": "seamless.lib.filelink",
      "func_name": "filelink",
      "code": "@macro(\"str\")\ndef filelink(ctx, cell_type):\n    cell_filelink_start = \"cell-filelink-start.py\" #repeat for inline\n    from seamless import reactor\n    pinparams = {\n       \"value\": {\n         \"pin\": \"edit\",\n         \"dtype\": cell_type,\n         \"must_be_defined\": False\n       },\n       \"filepath\" : {\n         \"pin\": \"input\",\n         \"dtype\": \"str\"\n       },\n       \"latency\" : {\n         \"pin\": \"input\",\n         \"dtype\": \"float\"\n       },\n    }\n    rc = ctx.rc = reactor(pinparams)\n    rc.code_start.cell().fromfile(cell_filelink_start)\n    rc.code_update.cell().set(\"write_file(PINS.filepath.get())\")\n    rc.code_stop.cell().set('terminate.set(); t.join()')\n    ctx.export(rc)\n"
    },
    {
      "with_context": true,
      "dtype": [
        "text",
        "code",
        "python"
      ],
      "type_args": {
        "display_type": "str",
        "title": {
          "default": "Basic display",
          "type": "str"
        },
        "_order": [
          "display_type",
          "title"
        ]
      },
      "module_name": "seamless.lib.gui.basic_display",
      "func_name": "basic_display",
      "code": "@macro(OrderedDict((\n    (\"display_type\",\"str\"),\n    (\"title\",{\"type\": \"str\", \"default\": \"Basic display\"})\n)))\ndef basic_display(ctx, display_type, title):\n    from seamless import reactor\n\n    _displays = {\n      \"int\": {\n        \"code\": \"cell-basic_display_int.py\",\n        \"update\": \"cell-basic_display_UPDATE.py\",\n      },\n      \"float\": {\n        \"code\": \"cell-basic_display_float.py\",\n        \"update\": \"cell-basic_display_UPDATE.py\",\n      },\n      \"text\": {\n        \"code\": \"cell-basic_display_text.py\",\n        \"update\": \"cell-basic_display_text_UPDATE.py\",\n      },\n      \"str\": {\n        \"code\": \"cell-basic_display_text.py\",\n        \"update\": \"cell-basic_display_text_UPDATE.py\",\n      },\n      (\"text\", \"html\"): {\n        \"code\": \"cell-basic_display_html.py\",\n        \"update\": \"cell-basic_display_html_UPDATE.py\",\n      },\n      \"json\": {\n        \"code\": \"cell-basic_display_json.py\",\n        \"update\": \"cell-basic_display_json_UPDATE.py\",\n      },\n    }\n    _displays[\"cson\"] = _displays[\"text\"]\n\n    def _match_type(type, typelist):\n        typelist = list(typelist)\n        type2 = type\n        if isinstance(type, str):\n            type2 = (type,)\n        typelist2 = []\n        for t in typelist:\n            if isinstance(t, str):\n                typelist2.append((t,))\n            else:\n                typelist2.append(t)\n        matches = []\n        for n in range(len(typelist)):\n            ltype = typelist2[n]\n            k = min(len(type2), len(ltype))\n            if type2[:k] == ltype[:k]:\n                matches.append((n, k))\n        if not len(matches):\n            raise TypeError(\"Cannot find display for cell type '{0}'\".format(type))\n        matches.sort(key=lambda v: -v[1])\n        bestmatch = matches[0][0]\n        return typelist[bestmatch]\n\n    display_type = _match_type(display_type, _displays.keys())\n    pinparams = {\n      \"value\": {\n        \"pin\": \"input\",\n        \"dtype\": display_type\n      },\n      \"title\": {\n        \"pin\": \"input\",\n        \"dtype\": \"str\",\n      },\n    }\n    d = ctx.display = reactor(pinparams)\n    d.title.cell().set(title)\n    d.code_start.cell().fromfile(_displays[display_type][\"code\"])\n    d.code_stop.cell().set('w.destroy()')\n    upfile = _displays[display_type][\"update\"]\n    c_up = d.code_update.cell()\n    if upfile is not None:\n        c_up.fromfile(upfile)\n    else:\n        c_up.set(\"\")\n    ctx.export(d, forced=[\"title\"])\n"
    },
    {
      "with_context": true,
      "dtype": [
        "text",
        "code",
        "python"
      ],
      "type_args": {
        "editor_type": "str",
        "title": {
          "default": "Basic editor",
          "type": "str"
        },
        "_order": [
          "editor_type",
          "title"
        ]
      },
      "module_name": "seamless.lib.gui.basic_editor",
      "func_name": "basic_editor",
      "code": "@macro(OrderedDict((\n    (\"editor_type\",\"str\"),\n    (\"title\",{\"type\": \"str\", \"default\": \"Basic editor\"})\n)))\ndef basic_editor(ctx, editor_type, title):\n    from seamless import reactor\n\n    _editors = {\n      \"int\": {\n        \"code\": \"cell-basic_editor_int.py\",\n        \"update\": \"cell-basic_editor_int_UPDATE.py\",\n      },\n      \"float\": {\n        \"code\": \"cell-basic_editor_float.py\",\n        \"update\": \"cell-basic_editor_UPDATE.py\",\n      },\n      \"text\": {\n        \"code\": \"cell-basic_editor_text.py\",\n        \"update\": \"cell-basic_editor_text_UPDATE.py\",\n      },\n      \"json\": {\n        \"code\": \"cell-basic_editor_json.py\",\n        \"update\": \"cell-basic_editor_json_UPDATE.py\",\n      },\n    }\n    _editors[\"cson\"] = _editors[\"text\"]\n\n    def _match_type(type, typelist):\n        typelist = list(typelist)\n        type2 = type\n        if isinstance(type, str):\n            type2 = (type,)\n        typelist2 = []\n        for t in typelist:\n            if isinstance(t, str):\n                typelist2.append((t,))\n            else:\n                typelist2.append(t)\n        matches = []\n        for n in range(len(typelist)):\n            ltype = typelist2[n]\n            k = min(len(type2), len(ltype))\n            if type2[:k] == ltype[:k]:\n                matches.append((n, k))\n        if not len(matches):\n            raise TypeError(\"Cannot find editor for cell type '{0}'\".format(type))\n        matches.sort(key=lambda v: -v[1])\n        bestmatch = matches[0][0]\n        return typelist[bestmatch]\n\n    editor_type = _match_type(editor_type, _editors.keys())\n    pinparams = {\n      \"value\": {\n        \"pin\": \"edit\",\n        \"dtype\": editor_type,\n        \"must_be_defined\": False\n      },\n      \"title\": {\n        \"pin\": \"input\",\n        \"dtype\": \"str\",\n      },\n    }\n    if editor_type == \"int\":\n        pinparams[\"maximum\"] = {\"pin\": \"input\", \"dtype\": \"int\"}\n    rc = ctx.rc = reactor(pinparams)\n    rc.title.cell().set(title)\n    forced = [\"title\"]\n    if editor_type == \"int\":\n        rc.maximum.set(9999999)\n        forced.append(\"maximum\")\n    rc.code_start.cell().fromfile(_editors[editor_type][\"code\"])\n    rc.code_stop.cell().set('w.destroy()')\n    upfile = _editors[editor_type][\"update\"]\n    c_up = rc.code_update.cell(True)\n    if upfile is not None:\n        c_up.fromfile(upfile)\n    else:\n        c_up.set(\"\")\n    ctx.export(rc, forced=forced)\n"
    },
    {
      "with_context": true,
      "dtype": [
        "text",
        "code",
        "python"
      ],
      "type_args": {
        "dtype": {
          "default": [
            "text",
            "html"
          ],
          "type": "dtype"
        },
        "title": {
          "default": "Browser",
          "type": "str"
        },
        "_order": [
          "dtype",
          "title"
        ]
      },
      "module_name": "seamless.lib.gui.browser",
      "func_name": "browser",
      "code": "@macro(OrderedDict((\n    (\"dtype\",{\"type\": \"dtype\", \"default\": (\"text\", \"html\")}),\n    (\"title\",{\"type\": \"str\", \"default\": \"Browser\"})\n)))\ndef browser(ctx, dtype, title):\n    from seamless import reactor\n    assert dtype[:2] == (\"text\", \"html\") #for now...\n    pinparams = {\n      \"value\": {\n        \"pin\": \"edit\",\n        \"dtype\": dtype\n      },\n      \"title\": {\n        \"pin\": \"input\",\n        \"dtype\": \"str\",\n      },\n    }\n    rc = ctx.rc = reactor(pinparams)\n    rc.title.cell().set(title)\n    rc.code_start.cell().fromfile(\"cell-browser.py\")\n    rc.code_stop.cell().set('widget.destroy()')\n    c_up = rc.code_update.cell(True)\n    c_up.fromfile(\"cell-browser_UPDATE.py\")\n    ctx.export(rc, forced=[\"title\"])\n"
    },
    {
      "with_context": false,
      "dtype": [
        "text",
        "code",
        "python"
      ],
      "type_args": {
        "dtype": "dtype",
        "options": "json",
        "title": {
          "default": "Combobox",
          "type": "str"
        },
        "_order": [
          "dtype",
          "options",
          "title"
        ]
      },
      "module_name": "seamless.lib.gui.combobox",
      "func_name": "combobox",
      "code": "@macro(OrderedDict((\n    (\"dtype\",\"dtype\"),\n    (\"options\",\"json\"),\n    (\"title\",{\"type\": \"str\", \"default\": \"Combobox\"})\n)), with_context=False)\ndef combobox(dtype, options, title):\n    from seamless import reactor\n    pinparams = {\n      \"value\": {\n        \"pin\": \"edit\",\n        \"dtype\": dtype,\n        \"must_be_defined\": False\n      },\n      \"options\": {\n        \"pin\": \"input\",\n        \"dtype\": \"json\",\n      },\n      \"title\": {\n        \"pin\": \"input\",\n        \"dtype\": \"str\",\n      },\n    }\n    rc = reactor(pinparams)\n    rc.options.cell().set(options)\n    rc.title.cell().set(title)\n    rc.code_start.cell().fromfile(\"cell-combobox.py\")\n    rc.code_stop.cell().set('widget.destroy()')\n    c_up = rc.code_update.cell(True)\n    c_up.fromfile(\"cell-combobox_UPDATE.py\")\n    return rc\n"
    },
    {
      "with_context": true,
      "dtype": [
        "text",
        "code",
        "python"
      ],
      "type_args": {
        "template_definition": "json",
        "output_type": {
          "default": [
            "text",
            "html"
          ],
          "type": "dtype"
        },
        "_order": [
          "template_definition",
          "output_type"
        ]
      },
      "module_name": "seamless.lib.templateer",
      "func_name": "templateer",
      "code": "@macro(OrderedDict((\n  (\"template_definition\", \"json\"),\n  (\"output_type\", {\"type\": \"dtype\", \"default\": (\"text\", \"html\")}),\n)))\ndef templateer(ctx, template_definition, output_type):\n    from seamless import cell, reactor\n    templates = template_definition[\"templates\"]\n    assert isinstance(templates, list)\n    environment = template_definition[\"environment\"]\n    ed_params = {}\n    for t in templates:\n        assert t not in ed_params, t\n        ed_params[t] = {\"pin\": \"input\", \"dtype\": \"text\"}\n    for k,v in environment.items():\n        assert k not in ed_params, k\n        ed_params[k] = {\"pin\": \"input\", \"dtype\": v}\n    ed_params[\"TEMPLATE_DEFINITION\"] = {\"pin\": \"input\", \"dtype\": \"json\"}\n    ed_params[\"RESULT\"] = {\"pin\": \"output\", \"dtype\": output_type}\n    ctx.rc = reactor(ed_params)\n    ctx.rc.TEMPLATE_DEFINITION.cell().set(template_definition)\n    ctx.rc.code_start.cell().fromfile(\"cell-templateer.py\")\n    ctx.rc.code_update.cell().set(\"make_template()\")\n    ctx.rc.code_stop.cell().set(\"\")\n    ctx.export(ctx.rc)\n"
    },
    {
      "with_context": false,
      "dtype": [
        "text",
        "code",
        "python"
      ],
      "type_args": {
        "period": {
          "default": 0,
          "type": "float"
        },
        "_order": [
          "period"
        ]
      },
      "module_name": "seamless.lib.timer",
      "func_name": "timer",
      "code": "@macro(OrderedDict((\n    (\"period\", {\"type\": \"float\", \"default\": 0}),\n)), with_context=False)\ndef timer(period):\n    from seamless import reactor\n    timer = reactor({\n        \"period\": {\"pin\": \"input\", \"dtype\": \"float\"},\n        \"trigger\": {\"pin\": \"output\", \"dtype\": \"signal\"}\n    })\n    timer.code_start.cell().fromfile(\"cell-timer.py\")\n    timer.code_update.cell().set(\"\")\n    timer.code_stop.cell().set(\"t.cancel(); dead = True\")\n    if period > 0:\n        timer.period.cell().set(period)\n    return timer\n"
    }
  ],
  "main": {
    "type": "context",
    "like_worker": false,
    "like_cell": false,
    "pins": {},
    "auto": [],
    "children": {
      "attrib": {
        "dtype": "cson",
        "resource": {
          "filepath": "plotdata/attrib.cson",
          "lib": false,
          "mode": 5,
          "save_policy": 1
        },
        "data": "[\n  {\n    \"type\": \"bar\",\n    \"marker\": {\n      \"color\": [\n        \"hsl(30,100,50)\",\n        \"hsl(50,90,50)\",\n        \"hsl(50,90,50)\",\n        \"hsl(30,100,50)\",\n        \"hsl(50,90,50)\",\n        \"hsl(50,90,50)\",\n        \"hsl(50,90,50)\",\n        \"hsl(30,100,50)\",\n        \"hsl(0,100,50)\",\n        \"hsl(50,90,50)\",\n        \"hsl(30,100,50)\",\n        \"hsl(50,90,50)\",\n        \"hsl(30,100,50)\",\n        \"hsl(50,90,50)\",\n        \"hsl(50,90,50)\",\n        \"hsl(30,100,50)\",\n        \"hsl(50,90,50)\",\n        \"hsl(50,90,50)\",\n        \"hsl(30,100,50)\",\n        \"hsl(50,90,50)\",\n        \"hsl(50,90,50)\",\n        \"hsl(50,90,50)\",\n        \"hsl(30,100,50)\",\n        \"hsl(0,100,50)\",\n        \"hsl(50,90,50)\",\n        \"hsl(30,100,50)\",\n        \"hsl(50,90,50)\",\n        \"hsl(50,90,50)\",\n        \"hsl(30,100,50)\",\n        \"hsl(50,90,50)\",\n        \"hsl(50,90,50)\",\n        \"hsl(30,100,50)\",\n        \"hsl(50,90,50)\",\n        \"hsl(30,100,50)\",\n        \"hsl(50,90,50)\",\n        \"hsl(50,90,50)\",\n        \"hsl(30,100,50)\",\n        \"hsl(50,90,50)\",\n        \"hsl(50,90,50)\",\n        \"hsl(30,100,50)\",\n        \"hsl(50,90,50)\",\n        \"hsl(50,90,50)\",\n        \"hsl(30,100,50)\",\n        \"hsl(50,90,50)\"\n      ]\n    }\n  },\n  {\n    \"type\": \"bar\",\n    \"marker\": {\n      \"color\": [\n        \"hsl(30,90,70)\",\n        \"hsl(50,90,70)\",\n        \"hsl(50,90,70)\",\n        \"hsl(30,90,70)\",\n        \"hsl(50,90,70)\",\n        \"hsl(50,90,70)\",\n        \"hsl(50,90,70)\",\n        \"hsl(30,90,70)\",\n        \"hsl(0,70,70)\",\n        \"hsl(50,90,70)\",\n        \"hsl(30,90,70)\",\n        \"hsl(50,90,70)\",\n        \"hsl(30,90,70)\",\n        \"hsl(50,90,70)\",\n        \"hsl(50,90,70)\",\n        \"hsl(30,90,70)\",\n        \"hsl(50,90,70)\",\n        \"hsl(50,90,70)\",\n        \"hsl(30,90,70)\",\n        \"hsl(50,90,70)\",\n        \"hsl(50,90,70)\",\n        \"hsl(50,90,70)\",\n        \"hsl(30,90,70)\",\n        \"hsl(0,70,70)\",\n        \"hsl(50,90,70)\",\n        \"hsl(30,90,70)\",\n        \"hsl(50,90,70)\",\n        \"hsl(50,90,70)\",\n        \"hsl(30,90,70)\",\n        \"hsl(50,90,70)\",\n        \"hsl(50,90,70)\",\n        \"hsl(30,90,70)\",\n        \"hsl(50,90,70)\",\n        \"hsl(30,90,70)\",\n        \"hsl(50,90,70)\",\n        \"hsl(50,90,70)\",\n        \"hsl(30,90,70)\",\n        \"hsl(50,90,70)\",\n        \"hsl(50,90,70)\",\n        \"hsl(30,90,70)\",\n        \"hsl(50,90,70)\",\n        \"hsl(50,90,70)\",\n        \"hsl(30,90,70)\",\n        \"hsl(50,90,70)\"\n      ]\n    }\n  },\n  {\n    \"type\": \"scatter\",\n    \"marker\": {\n      \"color\": \"black\"\n    },\n    \"mode\": \"markers\"\n  }\n]"
      },
      "browser": {
        "type": "context",
        "like_worker": true,
        "like_cell": false,
        "pins": {
          "title": [
            "ExportedInputPin",
            "browser.rc.title"
          ],
          "value": [
            "ExportedEditPin",
            "browser.rc.value"
          ]
        },
        "auto": [
          "cell1",
          "cell2",
          "cell3",
          "cell4"
        ],
        "children": {
          "cell1": {
            "dtype": "str",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "Browser"
          },
          "cell2": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "resource": {
              "filepath": "/gui/cell-browser.py",
              "lib": true,
              "mode": 2,
              "save_policy": 1
            },
            "data": "import os\nfrom seamless.qt.QtWebEngineWidgets import QWebEngineView\nfrom seamless.qt.Qt import QUrl\nfrom seamless.qt import QtWidgets, QtGui\n\nwidget = QWebEngineView()\nfake_url = QUrl.fromLocalFile(os.path.abspath(\"seamless.html\"))\nwidget.setWindowTitle(PINS.title.get())\nreloadAction = QtWidgets.QAction(QtGui.QIcon('exit.png'), '&Reload', widget)\nreloadAction.setShortcut('F5')\nreloadAction.setStatusTip('Reload')\nreloadAction.triggered.connect(widget.reload)\nwidget.addAction(reloadAction)\nwidget.setHtml(PINS.value.get(), fake_url)\nwidget.show()\n"
          },
          "cell3": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "widget.destroy()"
          },
          "cell4": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "resource": {
              "filepath": "/gui/cell-browser_UPDATE.py",
              "lib": true,
              "mode": 2,
              "save_policy": 1
            },
            "data": "if PINS.value.updated:\n    widget.setHtml(PINS.value.get(), fake_url)\nif PINS.title.updated:\n    widget.setWindowTitle(PINS.title.get())\n",
            "owner": "browser.rc.code_update"
          },
          "rc": {
            "type": "reactor",
            "mode": "sync",
            "params": {
              "title": {
                "dtype": "str",
                "pin": "input"
              },
              "value": {
                "dtype": [
                  "text",
                  "html"
                ],
                "pin": "edit"
              }
            }
          }
        }
      },
      "browser_dynamic": {
        "type": "context",
        "like_worker": true,
        "like_cell": false,
        "pins": {
          "title": [
            "ExportedInputPin",
            "browser_dynamic.rc.title"
          ],
          "value": [
            "ExportedEditPin",
            "browser_dynamic.rc.value"
          ]
        },
        "auto": [
          "cell1",
          "cell2",
          "cell3",
          "cell4"
        ],
        "children": {
          "cell1": {
            "dtype": "str",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "Browser"
          },
          "cell2": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "resource": {
              "filepath": "/gui/cell-browser.py",
              "lib": true,
              "mode": 2,
              "save_policy": 1
            },
            "data": "import os\nfrom seamless.qt.QtWebEngineWidgets import QWebEngineView\nfrom seamless.qt.Qt import QUrl\nfrom seamless.qt import QtWidgets, QtGui\n\nwidget = QWebEngineView()\nfake_url = QUrl.fromLocalFile(os.path.abspath(\"seamless.html\"))\nwidget.setWindowTitle(PINS.title.get())\nreloadAction = QtWidgets.QAction(QtGui.QIcon('exit.png'), '&Reload', widget)\nreloadAction.setShortcut('F5')\nreloadAction.setStatusTip('Reload')\nreloadAction.triggered.connect(widget.reload)\nwidget.addAction(reloadAction)\nwidget.setHtml(PINS.value.get(), fake_url)\nwidget.show()\n"
          },
          "cell3": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "widget.destroy()"
          },
          "cell4": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "resource": {
              "filepath": "/gui/cell-browser_UPDATE.py",
              "lib": true,
              "mode": 2,
              "save_policy": 1
            },
            "data": "if PINS.value.updated:\n    widget.setHtml(PINS.value.get(), fake_url)\nif PINS.title.updated:\n    widget.setWindowTitle(PINS.title.get())\n",
            "owner": "browser_dynamic.rc.code_update"
          },
          "rc": {
            "type": "reactor",
            "mode": "sync",
            "params": {
              "title": {
                "dtype": "str",
                "pin": "input"
              },
              "value": {
                "dtype": [
                  "text",
                  "html"
                ],
                "pin": "edit"
              }
            }
          }
        }
      },
      "code": {
        "type": "context",
        "like_worker": false,
        "like_cell": false,
        "pins": {},
        "auto": [
          "cell1",
          "cell10",
          "cell11",
          "cell12",
          "cell13",
          "cell14",
          "cell15",
          "cell16",
          "cell17",
          "cell18",
          "cell2",
          "cell3",
          "cell4",
          "cell5",
          "cell6",
          "cell7",
          "cell8",
          "cell9"
        ],
        "children": {
          "cell1": {
            "dtype": "str",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "./cell-integrate-data.py"
          },
          "cell10": {
            "dtype": "float",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "0.2"
          },
          "cell11": {
            "dtype": "float",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "0.2"
          },
          "cell12": {
            "dtype": "str",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "plotdata/plotly_dynamic.html"
          },
          "cell13": {
            "dtype": "float",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "0.2"
          },
          "cell14": {
            "dtype": "int",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "500"
          },
          "cell15": {
            "dtype": "int",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "500"
          },
          "cell16": {
            "dtype": "str",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "./template-body-dynamic.jinja"
          },
          "cell17": {
            "dtype": "float",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "0.2"
          },
          "cell18": {
            "dtype": "text",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "\nPlotly.purge(divname);\nPlotly.newPlot(divname, plotly_data, layout, config);\n"
          },
          "cell2": {
            "dtype": "float",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "0.2"
          },
          "cell3": {
            "dtype": "str",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "plotdata/data.json"
          },
          "cell4": {
            "dtype": "float",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "0.2"
          },
          "cell5": {
            "dtype": "str",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "plotdata/attrib.cson"
          },
          "cell6": {
            "dtype": "float",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "0.2"
          },
          "cell7": {
            "dtype": "str",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "./cell-load-data-columns.py"
          },
          "cell8": {
            "dtype": "float",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "0.2"
          },
          "cell9": {
            "dtype": "str",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "plotdata/data.csv"
          },
          "integrate_data": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "resource": {
              "filepath": "./cell-integrate-data.py",
              "lib": false,
              "mode": 5,
              "save_policy": 1
            },
            "data": "import copy\nresult = []\nfor n in range(len(data)):\n    series = {}\n    if n >= len(attrib):\n        if len(attrib) > 0:\n            series = attrib[-1]\n    else:\n        series = attrib[n]\n    series = copy.deepcopy(series)\n    series.update(data[n])\n    result.append(series)\nreturn result\n"
          },
          "load_data_columns": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "resource": {
              "filepath": "./cell-load-data-columns.py",
              "lib": false,
              "mode": 5,
              "save_policy": 1
            },
            "data": "import pandas as pd\nfrom io import StringIO\nfrom numpy import random\n#result = [{\"x\": [0, 100], \"y\": [0, 100]}]\n\ndf = pd.read_csv(StringIO(csv))\n#x = list(df.columns)[2:4]\nx = []\ncutoff3 = []\ncutoff53 = []\nbest = []\nfor row in df.index:\n    r = df.ix[row].tolist()\n    x.append(r[0]+r[1])\n    cutoff3.append(r[2])\n    cutoff53.append(r[3]-r[2])\n    best.append(r[4])\nreturn [{\"x\": x, \"y\": cutoff3, \"name\": \"cutoff3\"},\n        {\"x\": x, \"y\": cutoff53, \"name\": \"cutoff5\"},\n        {\"x\": x, \"y\": best, \"name\": \"best\"}\n]\n"
          }
        }
      },
      "csv": {
        "dtype": "text",
        "resource": {
          "filepath": "plotdata/data.csv",
          "lib": false,
          "mode": 5,
          "save_policy": 1
        },
        "data": ""
      },
      "data": {
        "dtype": "json",
        "resource": {
          "filepath": "plotdata/data.json",
          "lib": false,
          "mode": 5,
          "save_policy": 1
        },
        "hash": "dac7cdfbaccda73da83517506d7aac0a"
      },
      "divname": {
        "dtype": "str",
        "resource": {
          "filepath": null,
          "lib": null,
          "mode": null,
          "save_policy": 1
        },
        "data": "plotlydiv"
      },
      "dynamic_html_maker": {
        "type": "context",
        "like_worker": true,
        "like_cell": false,
        "pins": {
          "attrib": [
            "ExportedInputPin",
            "dynamic_html_maker.rc.attrib"
          ],
          "config": [
            "ExportedInputPin",
            "dynamic_html_maker.rc.config"
          ],
          "divname": [
            "ExportedInputPin",
            "dynamic_html_maker.rc.divname"
          ],
          "dynamic_html": [
            "ExportedOutputPin",
            "dynamic_html_maker.rc.dynamic_html"
          ],
          "layout": [
            "ExportedInputPin",
            "dynamic_html_maker.rc.layout"
          ],
          "make_plot": [
            "ExportedInputPin",
            "dynamic_html_maker.rc.make_plot"
          ],
          "plotly_data": [
            "ExportedInputPin",
            "dynamic_html_maker.rc.plotly_data"
          ]
        },
        "auto": [
          "cell1",
          "cell2",
          "cell3",
          "cell4",
          "cell5",
          "cell6"
        ],
        "children": {
          "cell1": {
            "dtype": [
              "text",
              "html"
            ],
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "hash": "1db5f9c712acd510f73cccfd33d7a47e",
            "owner": "dynamic_html_maker.rc"
          },
          "cell2": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "resource": {
              "filepath": "/cell-dynamic-html-start.py",
              "lib": true,
              "mode": 2,
              "save_policy": 1
            },
            "data": "import jinja2\n\nparams = PINS.DYNAMIC_HTML_PARAMS.get()\ntmpl = PINS.DYNAMIC_HTML_TEMPLATE.get()\nvars_ = []\nvars_full = []\nfor var_name, v in params[\"vars\"].items():\n    vv = v[0]\n    vars_.append(vv)\n    chars = \".[]{}\"\n    full_var = True\n    for char in chars:\n        if char in vv:\n            full_var = False\n            break\n    if full_var:\n        vars_full.append(vv)\ndynamic_html0 = jinja2.Template(tmpl).render(\n    {\"vars\": vars_, \"vars_full\": vars_full}\n)\n\nfrom seamless.websocketserver import websocketserver\nwebsocketserver.start() #no-op if the websocketserver has already started\n\ndynamic_html = jinja2.Template(dynamic_html0).render({\n    \"IDENTIFIER\": IDENTIFIER,\n    \"socket\": websocketserver.socket,\n})\nPINS.dynamic_html.set(dynamic_html)\n\ndef update(on_start):\n    do_evals = set()\n    for var_name in params[\"vars\"]:\n        pin = getattr(PINS, var_name)\n        if not pin.updated:\n            continue\n        value = pin.get()\n        var, evals = params[\"vars\"][var_name]\n        msg = {\"type\":\"var\", \"var\": var, \"value\": value}\n        #print(\"MSG\", msg, IDENTIFIER)\n        websocketserver.send_message(IDENTIFIER, msg)\n        for e in evals:\n            do_evals.add(e)\n    for html_name in params[\"html\"]:\n        pin = getattr(PINS, html_name)\n        if not pin.updated:\n            continue\n        value = pin.get()\n        id_ = params[\"html\"][html_name]\n        msg = {\"type\":\"html\", \"id\": id_, \"value\": value}\n        #print(\"MSG\", msg, IDENTIFIER)\n        websocketserver.send_message(IDENTIFIER, msg)\n    for e in params[\"evals\"]:\n        do_eval = False\n        do_on_start = params[\"evals\"][e]\n        if on_start:\n            if do_on_start == True:\n                do_eval = True\n            elif do_on_start == False:\n                do_eval = False\n            else:\n                do_eval = (e in do_evals)\n        else:\n            do_eval = (e in do_evals)\n        if do_eval:\n            pin = getattr(PINS, e)\n            value = pin.get()\n            msg = {\"type\":\"eval\", \"value\": value}\n            #print(\"MSG\", msg, IDENTIFIER)\n            websocketserver.send_message(IDENTIFIER, msg)\n\nupdate(on_start=True)\n"
          },
          "cell3": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "update(on_start=False)"
          },
          "cell4": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": ""
          },
          "cell5": {
            "dtype": "json",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "{\n  \"html\": {},\n  \"vars\": {\n    \"divname\": [\n      \"divname\",\n      []\n    ],\n    \"attrib\": [\n      \"attrib\",\n      [\n        \"make_plot\"\n      ]\n    ],\n    \"layout\": [\n      \"layout\",\n      [\n        \"make_plot\"\n      ]\n    ],\n    \"plotly_data\": [\n      \"plotly_data\",\n      [\n        \"make_plot\"\n      ]\n    ],\n    \"config\": [\n      \"config\",\n      [\n        \"make_plot\"\n      ]\n    ]\n  },\n  \"evals\": {\n    \"make_plot\": true\n  }\n}"
          },
          "cell6": {
            "dtype": "text",
            "resource": {
              "filepath": "/dynamic-html.jinja",
              "lib": true,
              "mode": 2,
              "save_policy": 1
            },
            "data": "<script>\n{% for var in vars_full %}\n    var {{var}} = null;\n{% endfor %}\n    var ws = new WebSocket(\"ws://127.0.0.1:{% raw %}{{socket}}{% endraw %}/\");\n    ws.onopen = function () {\n        ws.send(\"{% raw %}{{IDENTIFIER}}{% endraw %}\");\n    }\n    ws.onmessage = function (event) {\n        var message = JSON.parse(event.data);\n        if (message.type == \"var\") {\n          if (0) {}\n          {% for var in vars %}\n          else if (message.var == \"{{var}}\") {\n            {{var}} = message.value;\n          }\n          {% endfor %}\n        }\n        else if (message.type == \"html\") {\n          var ele = document.getElementById(message.id);\n          ele.innerHTML = message.value;\n        }\n        else if (message.type == \"eval\") {\n          eval(message.value);\n        }\n    };\n</script>\n"
          },
          "rc": {
            "type": "reactor",
            "mode": "sync",
            "params": {
              "DYNAMIC_HTML_PARAMS": {
                "dtype": "json",
                "pin": "input"
              },
              "DYNAMIC_HTML_TEMPLATE": {
                "dtype": "text",
                "pin": "input"
              },
              "attrib": {
                "dtype": "json",
                "pin": "input"
              },
              "config": {
                "dtype": "json",
                "pin": "input"
              },
              "divname": {
                "dtype": "str",
                "pin": "input"
              },
              "dynamic_html": {
                "dtype": [
                  "text",
                  "html"
                ],
                "pin": "output"
              },
              "layout": {
                "dtype": "json",
                "pin": "input"
              },
              "make_plot": {
                "dtype": "text",
                "pin": "input"
              },
              "plotly_data": {
                "dtype": "json",
                "pin": "input"
              }
            }
          }
        }
      },
      "edit": {
        "type": "context",
        "like_worker": false,
        "like_cell": false,
        "pins": {},
        "auto": [
          "cell1",
          "cell2",
          "cell3",
          "cell4"
        ],
        "children": {
          "cell1": {
            "dtype": "str",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "plotdata/plotly.html"
          },
          "cell2": {
            "dtype": "float",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "0.2"
          },
          "cell3": {
            "dtype": "str",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "./template-html-head-body.jinja"
          },
          "cell4": {
            "dtype": "float",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "0.2"
          }
        }
      },
      "html": {
        "dtype": [
          "text",
          "html"
        ],
        "resource": {
          "filepath": "plotdata/plotly.html",
          "lib": false,
          "mode": 5,
          "save_policy": 1
        },
        "hash": "c143621967917717158f2915c7a199cc"
      },
      "html_dynamic": {
        "dtype": [
          "text",
          "html"
        ],
        "resource": {
          "filepath": "plotdata/plotly_dynamic.html",
          "lib": false,
          "mode": 5,
          "save_policy": 1
        },
        "hash": "5a6c58e4cd37dbf6ba12934cee660383"
      },
      "integrate_data": {
        "type": "transformer",
        "mode": "thread",
        "params": {
          "attrib": {
            "dtype": "json",
            "pin": "input"
          },
          "data": {
            "dtype": "json",
            "pin": "input"
          },
          "plotly_data": {
            "dtype": "json",
            "pin": "output"
          }
        }
      },
      "links": {
        "type": "context",
        "like_worker": false,
        "like_cell": false,
        "pins": {},
        "auto": [],
        "children": {
          "attrib": {
            "type": "context",
            "like_worker": true,
            "like_cell": false,
            "pins": {
              "filepath": [
                "ExportedInputPin",
                "links.attrib.rc.filepath"
              ],
              "latency": [
                "ExportedInputPin",
                "links.attrib.rc.latency"
              ],
              "value": [
                "ExportedEditPin",
                "links.attrib.rc.value"
              ]
            },
            "auto": [
              "cell1",
              "cell2",
              "cell3"
            ],
            "children": {
              "cell1": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": "/cell-filelink-start.py",
                  "lib": true,
                  "mode": 2,
                  "save_policy": 1
                },
                "data": "if __name__ == \"__main__\":\n    #test with ipython -i\n    import sys, os\n\n    class dummy:\n        pass\n\n    class EditPin:\n        def __init__(self, value):\n            self.value = value\n            self.defined = True\n        def set(self, value):\n            print(\"SET\", value)\n            self.value = value\n        def get(self):\n            return self.value\n\n    class Getter:\n        def __init__(self, arg):\n            self.arg = arg\n        def get(self):\n            return self.arg\n    PINS = dummy()\n    PINS.value = EditPin(\"test\")\n    directory = sys.argv[1]\n    filename = sys.argv[2]\n    PINS.filepath = Getter(os.path.join(directory, filename))\n    PINS.latency = Getter(float(sys.argv[3]))\n    def serializer(v):\n        return str(v.get())\n    print(\"Edit in \" + filepath.get())\nelse:\n    from seamless.dtypes import serialize\n    def serializer(v):\n        return serialize(v._dtype, v.get())\n\n\nimport os, time, functools, traceback\nfrom threading import Thread, RLock, Event\nlast_value = None\nlast_serialized_value = None\nlast_exc = None\nlast_mtime = None\n\ndef write_file(fpath):\n    global last_mtime, last_value, last_serialized_value\n    if not PINS.value.defined:\n        last_mtime = -1 #will trigger a file read\n        return\n    if last_value == PINS.value.get():\n        return\n    val = serializer(PINS.value)\n    if last_serialized_value == val:\n        return\n    with lock:\n        if last_serialized_value != val:\n            #print(\"WRITE\", val)\n            if PINS.value._dtype == \"object\":\n                with open(fpath, \"wb\") as f:\n                    f.write(val)\n                    last_value = PINS.value.get()\n                    last_serialized_value = val\n            else:\n                with open(fpath, \"w\", encoding=\"utf-8\") as f:\n                    f.write(val)\n                    last_value = PINS.value.get()\n                    last_serialized_value = val\n            last_time = time.time()\n            try:\n                stat = os.stat(fpath)\n                last_mtime = stat.st_mtime\n            except Exception:\n                pass\n\nsleeptime = 0.01\n\ndef poll():\n    global last_time, last_mtime, last_value, last_serialized_value, last_exc\n    fpath = PINS.filepath.get()\n    while 1:\n        sleeps = int(PINS.latency.get() / sleeptime + 0.9999)\n        for n in range(sleeps):\n            time.sleep(sleeptime)\n            if terminate.is_set():\n                break\n        if terminate.is_set():\n            break\n        curr_time = time.time()\n        last_time = curr_time\n        if not os.path.exists(fpath):\n            try:\n                write_file(fpath)\n            except Exception:\n                exc = traceback.format_exc()\n                if exc != last_exc:\n                    print(exc)\n                    last_exc = exc\n        else:\n            with lock:\n                stat = os.stat(fpath)\n                try:\n                    if last_mtime is None or stat.st_mtime > last_mtime:\n                        data = None\n                        if PINS.value._dtype == \"object\":\n                            with open(fpath, \"rb\") as f:\n                                data = f.read()\n                        else:\n                            with open(fpath, encoding=\"utf-8\") as f:\n                                data = f.read()\n                        if data is not None:\n                            if last_serialized_value != data:\n                                #print(\"LOAD\")\n                                PINS.value.set(data)\n                                last_value = None\n                                last_serialized_value = data\n                        last_mtime = stat.st_mtime\n                except Exception:\n                    exc = traceback.format_exc()\n                    if exc != last_exc:\n                        print(exc)\n                        last_exc = exc\n\nterminate = Event()\nt = Thread(target=poll)\nt.setDaemon(True)\nlock = RLock()\nwrite_file(PINS.filepath.get())\nt.start()\n"
              },
              "cell2": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": null,
                  "lib": null,
                  "mode": null,
                  "save_policy": 1
                },
                "data": "write_file(PINS.filepath.get())"
              },
              "cell3": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": null,
                  "lib": null,
                  "mode": null,
                  "save_policy": 1
                },
                "data": "terminate.set(); t.join()"
              },
              "rc": {
                "type": "reactor",
                "mode": "sync",
                "params": {
                  "filepath": {
                    "dtype": "str",
                    "pin": "input"
                  },
                  "latency": {
                    "dtype": "float",
                    "pin": "input"
                  },
                  "value": {
                    "dtype": "cson",
                    "must_be_defined": false,
                    "pin": "edit"
                  }
                }
              }
            }
          },
          "code_integrate_data": {
            "type": "context",
            "like_worker": true,
            "like_cell": false,
            "pins": {
              "filepath": [
                "ExportedInputPin",
                "links.code_integrate_data.rc.filepath"
              ],
              "latency": [
                "ExportedInputPin",
                "links.code_integrate_data.rc.latency"
              ],
              "value": [
                "ExportedEditPin",
                "links.code_integrate_data.rc.value"
              ]
            },
            "auto": [
              "cell1",
              "cell2",
              "cell3"
            ],
            "children": {
              "cell1": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": "/cell-filelink-start.py",
                  "lib": true,
                  "mode": 2,
                  "save_policy": 1
                },
                "data": "if __name__ == \"__main__\":\n    #test with ipython -i\n    import sys, os\n\n    class dummy:\n        pass\n\n    class EditPin:\n        def __init__(self, value):\n            self.value = value\n            self.defined = True\n        def set(self, value):\n            print(\"SET\", value)\n            self.value = value\n        def get(self):\n            return self.value\n\n    class Getter:\n        def __init__(self, arg):\n            self.arg = arg\n        def get(self):\n            return self.arg\n    PINS = dummy()\n    PINS.value = EditPin(\"test\")\n    directory = sys.argv[1]\n    filename = sys.argv[2]\n    PINS.filepath = Getter(os.path.join(directory, filename))\n    PINS.latency = Getter(float(sys.argv[3]))\n    def serializer(v):\n        return str(v.get())\n    print(\"Edit in \" + filepath.get())\nelse:\n    from seamless.dtypes import serialize\n    def serializer(v):\n        return serialize(v._dtype, v.get())\n\n\nimport os, time, functools, traceback\nfrom threading import Thread, RLock, Event\nlast_value = None\nlast_serialized_value = None\nlast_exc = None\nlast_mtime = None\n\ndef write_file(fpath):\n    global last_mtime, last_value, last_serialized_value\n    if not PINS.value.defined:\n        last_mtime = -1 #will trigger a file read\n        return\n    if last_value == PINS.value.get():\n        return\n    val = serializer(PINS.value)\n    if last_serialized_value == val:\n        return\n    with lock:\n        if last_serialized_value != val:\n            #print(\"WRITE\", val)\n            if PINS.value._dtype == \"object\":\n                with open(fpath, \"wb\") as f:\n                    f.write(val)\n                    last_value = PINS.value.get()\n                    last_serialized_value = val\n            else:\n                with open(fpath, \"w\", encoding=\"utf-8\") as f:\n                    f.write(val)\n                    last_value = PINS.value.get()\n                    last_serialized_value = val\n            last_time = time.time()\n            try:\n                stat = os.stat(fpath)\n                last_mtime = stat.st_mtime\n            except Exception:\n                pass\n\nsleeptime = 0.01\n\ndef poll():\n    global last_time, last_mtime, last_value, last_serialized_value, last_exc\n    fpath = PINS.filepath.get()\n    while 1:\n        sleeps = int(PINS.latency.get() / sleeptime + 0.9999)\n        for n in range(sleeps):\n            time.sleep(sleeptime)\n            if terminate.is_set():\n                break\n        if terminate.is_set():\n            break\n        curr_time = time.time()\n        last_time = curr_time\n        if not os.path.exists(fpath):\n            try:\n                write_file(fpath)\n            except Exception:\n                exc = traceback.format_exc()\n                if exc != last_exc:\n                    print(exc)\n                    last_exc = exc\n        else:\n            with lock:\n                stat = os.stat(fpath)\n                try:\n                    if last_mtime is None or stat.st_mtime > last_mtime:\n                        data = None\n                        if PINS.value._dtype == \"object\":\n                            with open(fpath, \"rb\") as f:\n                                data = f.read()\n                        else:\n                            with open(fpath, encoding=\"utf-8\") as f:\n                                data = f.read()\n                        if data is not None:\n                            if last_serialized_value != data:\n                                #print(\"LOAD\")\n                                PINS.value.set(data)\n                                last_value = None\n                                last_serialized_value = data\n                        last_mtime = stat.st_mtime\n                except Exception:\n                    exc = traceback.format_exc()\n                    if exc != last_exc:\n                        print(exc)\n                        last_exc = exc\n\nterminate = Event()\nt = Thread(target=poll)\nt.setDaemon(True)\nlock = RLock()\nwrite_file(PINS.filepath.get())\nt.start()\n"
              },
              "cell2": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": null,
                  "lib": null,
                  "mode": null,
                  "save_policy": 1
                },
                "data": "write_file(PINS.filepath.get())"
              },
              "cell3": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": null,
                  "lib": null,
                  "mode": null,
                  "save_policy": 1
                },
                "data": "terminate.set(); t.join()"
              },
              "rc": {
                "type": "reactor",
                "mode": "sync",
                "params": {
                  "filepath": {
                    "dtype": "str",
                    "pin": "input"
                  },
                  "latency": {
                    "dtype": "float",
                    "pin": "input"
                  },
                  "value": {
                    "dtype": [
                      "text",
                      "code",
                      "python"
                    ],
                    "must_be_defined": false,
                    "pin": "edit"
                  }
                }
              }
            }
          },
          "code_load_data_columns": {
            "type": "context",
            "like_worker": true,
            "like_cell": false,
            "pins": {
              "filepath": [
                "ExportedInputPin",
                "links.code_load_data_columns.rc.filepath"
              ],
              "latency": [
                "ExportedInputPin",
                "links.code_load_data_columns.rc.latency"
              ],
              "value": [
                "ExportedEditPin",
                "links.code_load_data_columns.rc.value"
              ]
            },
            "auto": [
              "cell1",
              "cell2",
              "cell3"
            ],
            "children": {
              "cell1": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": "/cell-filelink-start.py",
                  "lib": true,
                  "mode": 2,
                  "save_policy": 1
                },
                "data": "if __name__ == \"__main__\":\n    #test with ipython -i\n    import sys, os\n\n    class dummy:\n        pass\n\n    class EditPin:\n        def __init__(self, value):\n            self.value = value\n            self.defined = True\n        def set(self, value):\n            print(\"SET\", value)\n            self.value = value\n        def get(self):\n            return self.value\n\n    class Getter:\n        def __init__(self, arg):\n            self.arg = arg\n        def get(self):\n            return self.arg\n    PINS = dummy()\n    PINS.value = EditPin(\"test\")\n    directory = sys.argv[1]\n    filename = sys.argv[2]\n    PINS.filepath = Getter(os.path.join(directory, filename))\n    PINS.latency = Getter(float(sys.argv[3]))\n    def serializer(v):\n        return str(v.get())\n    print(\"Edit in \" + filepath.get())\nelse:\n    from seamless.dtypes import serialize\n    def serializer(v):\n        return serialize(v._dtype, v.get())\n\n\nimport os, time, functools, traceback\nfrom threading import Thread, RLock, Event\nlast_value = None\nlast_serialized_value = None\nlast_exc = None\nlast_mtime = None\n\ndef write_file(fpath):\n    global last_mtime, last_value, last_serialized_value\n    if not PINS.value.defined:\n        last_mtime = -1 #will trigger a file read\n        return\n    if last_value == PINS.value.get():\n        return\n    val = serializer(PINS.value)\n    if last_serialized_value == val:\n        return\n    with lock:\n        if last_serialized_value != val:\n            #print(\"WRITE\", val)\n            if PINS.value._dtype == \"object\":\n                with open(fpath, \"wb\") as f:\n                    f.write(val)\n                    last_value = PINS.value.get()\n                    last_serialized_value = val\n            else:\n                with open(fpath, \"w\", encoding=\"utf-8\") as f:\n                    f.write(val)\n                    last_value = PINS.value.get()\n                    last_serialized_value = val\n            last_time = time.time()\n            try:\n                stat = os.stat(fpath)\n                last_mtime = stat.st_mtime\n            except Exception:\n                pass\n\nsleeptime = 0.01\n\ndef poll():\n    global last_time, last_mtime, last_value, last_serialized_value, last_exc\n    fpath = PINS.filepath.get()\n    while 1:\n        sleeps = int(PINS.latency.get() / sleeptime + 0.9999)\n        for n in range(sleeps):\n            time.sleep(sleeptime)\n            if terminate.is_set():\n                break\n        if terminate.is_set():\n            break\n        curr_time = time.time()\n        last_time = curr_time\n        if not os.path.exists(fpath):\n            try:\n                write_file(fpath)\n            except Exception:\n                exc = traceback.format_exc()\n                if exc != last_exc:\n                    print(exc)\n                    last_exc = exc\n        else:\n            with lock:\n                stat = os.stat(fpath)\n                try:\n                    if last_mtime is None or stat.st_mtime > last_mtime:\n                        data = None\n                        if PINS.value._dtype == \"object\":\n                            with open(fpath, \"rb\") as f:\n                                data = f.read()\n                        else:\n                            with open(fpath, encoding=\"utf-8\") as f:\n                                data = f.read()\n                        if data is not None:\n                            if last_serialized_value != data:\n                                #print(\"LOAD\")\n                                PINS.value.set(data)\n                                last_value = None\n                                last_serialized_value = data\n                        last_mtime = stat.st_mtime\n                except Exception:\n                    exc = traceback.format_exc()\n                    if exc != last_exc:\n                        print(exc)\n                        last_exc = exc\n\nterminate = Event()\nt = Thread(target=poll)\nt.setDaemon(True)\nlock = RLock()\nwrite_file(PINS.filepath.get())\nt.start()\n"
              },
              "cell2": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": null,
                  "lib": null,
                  "mode": null,
                  "save_policy": 1
                },
                "data": "write_file(PINS.filepath.get())"
              },
              "cell3": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": null,
                  "lib": null,
                  "mode": null,
                  "save_policy": 1
                },
                "data": "terminate.set(); t.join()"
              },
              "rc": {
                "type": "reactor",
                "mode": "sync",
                "params": {
                  "filepath": {
                    "dtype": "str",
                    "pin": "input"
                  },
                  "latency": {
                    "dtype": "float",
                    "pin": "input"
                  },
                  "value": {
                    "dtype": [
                      "text",
                      "code",
                      "python"
                    ],
                    "must_be_defined": false,
                    "pin": "edit"
                  }
                }
              }
            }
          },
          "csv": {
            "type": "context",
            "like_worker": true,
            "like_cell": false,
            "pins": {
              "filepath": [
                "ExportedInputPin",
                "links.csv.rc.filepath"
              ],
              "latency": [
                "ExportedInputPin",
                "links.csv.rc.latency"
              ],
              "value": [
                "ExportedEditPin",
                "links.csv.rc.value"
              ]
            },
            "auto": [
              "cell1",
              "cell2",
              "cell3"
            ],
            "children": {
              "cell1": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": "/cell-filelink-start.py",
                  "lib": true,
                  "mode": 2,
                  "save_policy": 1
                },
                "data": "if __name__ == \"__main__\":\n    #test with ipython -i\n    import sys, os\n\n    class dummy:\n        pass\n\n    class EditPin:\n        def __init__(self, value):\n            self.value = value\n            self.defined = True\n        def set(self, value):\n            print(\"SET\", value)\n            self.value = value\n        def get(self):\n            return self.value\n\n    class Getter:\n        def __init__(self, arg):\n            self.arg = arg\n        def get(self):\n            return self.arg\n    PINS = dummy()\n    PINS.value = EditPin(\"test\")\n    directory = sys.argv[1]\n    filename = sys.argv[2]\n    PINS.filepath = Getter(os.path.join(directory, filename))\n    PINS.latency = Getter(float(sys.argv[3]))\n    def serializer(v):\n        return str(v.get())\n    print(\"Edit in \" + filepath.get())\nelse:\n    from seamless.dtypes import serialize\n    def serializer(v):\n        return serialize(v._dtype, v.get())\n\n\nimport os, time, functools, traceback\nfrom threading import Thread, RLock, Event\nlast_value = None\nlast_serialized_value = None\nlast_exc = None\nlast_mtime = None\n\ndef write_file(fpath):\n    global last_mtime, last_value, last_serialized_value\n    if not PINS.value.defined:\n        last_mtime = -1 #will trigger a file read\n        return\n    if last_value == PINS.value.get():\n        return\n    val = serializer(PINS.value)\n    if last_serialized_value == val:\n        return\n    with lock:\n        if last_serialized_value != val:\n            #print(\"WRITE\", val)\n            if PINS.value._dtype == \"object\":\n                with open(fpath, \"wb\") as f:\n                    f.write(val)\n                    last_value = PINS.value.get()\n                    last_serialized_value = val\n            else:\n                with open(fpath, \"w\", encoding=\"utf-8\") as f:\n                    f.write(val)\n                    last_value = PINS.value.get()\n                    last_serialized_value = val\n            last_time = time.time()\n            try:\n                stat = os.stat(fpath)\n                last_mtime = stat.st_mtime\n            except Exception:\n                pass\n\nsleeptime = 0.01\n\ndef poll():\n    global last_time, last_mtime, last_value, last_serialized_value, last_exc\n    fpath = PINS.filepath.get()\n    while 1:\n        sleeps = int(PINS.latency.get() / sleeptime + 0.9999)\n        for n in range(sleeps):\n            time.sleep(sleeptime)\n            if terminate.is_set():\n                break\n        if terminate.is_set():\n            break\n        curr_time = time.time()\n        last_time = curr_time\n        if not os.path.exists(fpath):\n            try:\n                write_file(fpath)\n            except Exception:\n                exc = traceback.format_exc()\n                if exc != last_exc:\n                    print(exc)\n                    last_exc = exc\n        else:\n            with lock:\n                stat = os.stat(fpath)\n                try:\n                    if last_mtime is None or stat.st_mtime > last_mtime:\n                        data = None\n                        if PINS.value._dtype == \"object\":\n                            with open(fpath, \"rb\") as f:\n                                data = f.read()\n                        else:\n                            with open(fpath, encoding=\"utf-8\") as f:\n                                data = f.read()\n                        if data is not None:\n                            if last_serialized_value != data:\n                                #print(\"LOAD\")\n                                PINS.value.set(data)\n                                last_value = None\n                                last_serialized_value = data\n                        last_mtime = stat.st_mtime\n                except Exception:\n                    exc = traceback.format_exc()\n                    if exc != last_exc:\n                        print(exc)\n                        last_exc = exc\n\nterminate = Event()\nt = Thread(target=poll)\nt.setDaemon(True)\nlock = RLock()\nwrite_file(PINS.filepath.get())\nt.start()\n"
              },
              "cell2": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": null,
                  "lib": null,
                  "mode": null,
                  "save_policy": 1
                },
                "data": "write_file(PINS.filepath.get())"
              },
              "cell3": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": null,
                  "lib": null,
                  "mode": null,
                  "save_policy": 1
                },
                "data": "terminate.set(); t.join()"
              },
              "rc": {
                "type": "reactor",
                "mode": "sync",
                "params": {
                  "filepath": {
                    "dtype": "str",
                    "pin": "input"
                  },
                  "latency": {
                    "dtype": "float",
                    "pin": "input"
                  },
                  "value": {
                    "dtype": "text",
                    "must_be_defined": false,
                    "pin": "edit"
                  }
                }
              }
            }
          },
          "data": {
            "type": "context",
            "like_worker": true,
            "like_cell": false,
            "pins": {
              "filepath": [
                "ExportedInputPin",
                "links.data.rc.filepath"
              ],
              "latency": [
                "ExportedInputPin",
                "links.data.rc.latency"
              ],
              "value": [
                "ExportedEditPin",
                "links.data.rc.value"
              ]
            },
            "auto": [
              "cell1",
              "cell2",
              "cell3"
            ],
            "children": {
              "cell1": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": "/cell-filelink-start.py",
                  "lib": true,
                  "mode": 2,
                  "save_policy": 1
                },
                "data": "if __name__ == \"__main__\":\n    #test with ipython -i\n    import sys, os\n\n    class dummy:\n        pass\n\n    class EditPin:\n        def __init__(self, value):\n            self.value = value\n            self.defined = True\n        def set(self, value):\n            print(\"SET\", value)\n            self.value = value\n        def get(self):\n            return self.value\n\n    class Getter:\n        def __init__(self, arg):\n            self.arg = arg\n        def get(self):\n            return self.arg\n    PINS = dummy()\n    PINS.value = EditPin(\"test\")\n    directory = sys.argv[1]\n    filename = sys.argv[2]\n    PINS.filepath = Getter(os.path.join(directory, filename))\n    PINS.latency = Getter(float(sys.argv[3]))\n    def serializer(v):\n        return str(v.get())\n    print(\"Edit in \" + filepath.get())\nelse:\n    from seamless.dtypes import serialize\n    def serializer(v):\n        return serialize(v._dtype, v.get())\n\n\nimport os, time, functools, traceback\nfrom threading import Thread, RLock, Event\nlast_value = None\nlast_serialized_value = None\nlast_exc = None\nlast_mtime = None\n\ndef write_file(fpath):\n    global last_mtime, last_value, last_serialized_value\n    if not PINS.value.defined:\n        last_mtime = -1 #will trigger a file read\n        return\n    if last_value == PINS.value.get():\n        return\n    val = serializer(PINS.value)\n    if last_serialized_value == val:\n        return\n    with lock:\n        if last_serialized_value != val:\n            #print(\"WRITE\", val)\n            if PINS.value._dtype == \"object\":\n                with open(fpath, \"wb\") as f:\n                    f.write(val)\n                    last_value = PINS.value.get()\n                    last_serialized_value = val\n            else:\n                with open(fpath, \"w\", encoding=\"utf-8\") as f:\n                    f.write(val)\n                    last_value = PINS.value.get()\n                    last_serialized_value = val\n            last_time = time.time()\n            try:\n                stat = os.stat(fpath)\n                last_mtime = stat.st_mtime\n            except Exception:\n                pass\n\nsleeptime = 0.01\n\ndef poll():\n    global last_time, last_mtime, last_value, last_serialized_value, last_exc\n    fpath = PINS.filepath.get()\n    while 1:\n        sleeps = int(PINS.latency.get() / sleeptime + 0.9999)\n        for n in range(sleeps):\n            time.sleep(sleeptime)\n            if terminate.is_set():\n                break\n        if terminate.is_set():\n            break\n        curr_time = time.time()\n        last_time = curr_time\n        if not os.path.exists(fpath):\n            try:\n                write_file(fpath)\n            except Exception:\n                exc = traceback.format_exc()\n                if exc != last_exc:\n                    print(exc)\n                    last_exc = exc\n        else:\n            with lock:\n                stat = os.stat(fpath)\n                try:\n                    if last_mtime is None or stat.st_mtime > last_mtime:\n                        data = None\n                        if PINS.value._dtype == \"object\":\n                            with open(fpath, \"rb\") as f:\n                                data = f.read()\n                        else:\n                            with open(fpath, encoding=\"utf-8\") as f:\n                                data = f.read()\n                        if data is not None:\n                            if last_serialized_value != data:\n                                #print(\"LOAD\")\n                                PINS.value.set(data)\n                                last_value = None\n                                last_serialized_value = data\n                        last_mtime = stat.st_mtime\n                except Exception:\n                    exc = traceback.format_exc()\n                    if exc != last_exc:\n                        print(exc)\n                        last_exc = exc\n\nterminate = Event()\nt = Thread(target=poll)\nt.setDaemon(True)\nlock = RLock()\nwrite_file(PINS.filepath.get())\nt.start()\n"
              },
              "cell2": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": null,
                  "lib": null,
                  "mode": null,
                  "save_policy": 1
                },
                "data": "write_file(PINS.filepath.get())"
              },
              "cell3": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": null,
                  "lib": null,
                  "mode": null,
                  "save_policy": 1
                },
                "data": "terminate.set(); t.join()"
              },
              "rc": {
                "type": "reactor",
                "mode": "sync",
                "params": {
                  "filepath": {
                    "dtype": "str",
                    "pin": "input"
                  },
                  "latency": {
                    "dtype": "float",
                    "pin": "input"
                  },
                  "value": {
                    "dtype": "json",
                    "must_be_defined": false,
                    "pin": "edit"
                  }
                }
              }
            }
          },
          "html": {
            "type": "context",
            "like_worker": true,
            "like_cell": false,
            "pins": {
              "filepath": [
                "ExportedInputPin",
                "links.html.rc.filepath"
              ],
              "latency": [
                "ExportedInputPin",
                "links.html.rc.latency"
              ],
              "value": [
                "ExportedEditPin",
                "links.html.rc.value"
              ]
            },
            "auto": [
              "cell1",
              "cell2",
              "cell3"
            ],
            "children": {
              "cell1": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": "/cell-filelink-start.py",
                  "lib": true,
                  "mode": 2,
                  "save_policy": 1
                },
                "data": "if __name__ == \"__main__\":\n    #test with ipython -i\n    import sys, os\n\n    class dummy:\n        pass\n\n    class EditPin:\n        def __init__(self, value):\n            self.value = value\n            self.defined = True\n        def set(self, value):\n            print(\"SET\", value)\n            self.value = value\n        def get(self):\n            return self.value\n\n    class Getter:\n        def __init__(self, arg):\n            self.arg = arg\n        def get(self):\n            return self.arg\n    PINS = dummy()\n    PINS.value = EditPin(\"test\")\n    directory = sys.argv[1]\n    filename = sys.argv[2]\n    PINS.filepath = Getter(os.path.join(directory, filename))\n    PINS.latency = Getter(float(sys.argv[3]))\n    def serializer(v):\n        return str(v.get())\n    print(\"Edit in \" + filepath.get())\nelse:\n    from seamless.dtypes import serialize\n    def serializer(v):\n        return serialize(v._dtype, v.get())\n\n\nimport os, time, functools, traceback\nfrom threading import Thread, RLock, Event\nlast_value = None\nlast_serialized_value = None\nlast_exc = None\nlast_mtime = None\n\ndef write_file(fpath):\n    global last_mtime, last_value, last_serialized_value\n    if not PINS.value.defined:\n        last_mtime = -1 #will trigger a file read\n        return\n    if last_value == PINS.value.get():\n        return\n    val = serializer(PINS.value)\n    if last_serialized_value == val:\n        return\n    with lock:\n        if last_serialized_value != val:\n            #print(\"WRITE\", val)\n            if PINS.value._dtype == \"object\":\n                with open(fpath, \"wb\") as f:\n                    f.write(val)\n                    last_value = PINS.value.get()\n                    last_serialized_value = val\n            else:\n                with open(fpath, \"w\", encoding=\"utf-8\") as f:\n                    f.write(val)\n                    last_value = PINS.value.get()\n                    last_serialized_value = val\n            last_time = time.time()\n            try:\n                stat = os.stat(fpath)\n                last_mtime = stat.st_mtime\n            except Exception:\n                pass\n\nsleeptime = 0.01\n\ndef poll():\n    global last_time, last_mtime, last_value, last_serialized_value, last_exc\n    fpath = PINS.filepath.get()\n    while 1:\n        sleeps = int(PINS.latency.get() / sleeptime + 0.9999)\n        for n in range(sleeps):\n            time.sleep(sleeptime)\n            if terminate.is_set():\n                break\n        if terminate.is_set():\n            break\n        curr_time = time.time()\n        last_time = curr_time\n        if not os.path.exists(fpath):\n            try:\n                write_file(fpath)\n            except Exception:\n                exc = traceback.format_exc()\n                if exc != last_exc:\n                    print(exc)\n                    last_exc = exc\n        else:\n            with lock:\n                stat = os.stat(fpath)\n                try:\n                    if last_mtime is None or stat.st_mtime > last_mtime:\n                        data = None\n                        if PINS.value._dtype == \"object\":\n                            with open(fpath, \"rb\") as f:\n                                data = f.read()\n                        else:\n                            with open(fpath, encoding=\"utf-8\") as f:\n                                data = f.read()\n                        if data is not None:\n                            if last_serialized_value != data:\n                                #print(\"LOAD\")\n                                PINS.value.set(data)\n                                last_value = None\n                                last_serialized_value = data\n                        last_mtime = stat.st_mtime\n                except Exception:\n                    exc = traceback.format_exc()\n                    if exc != last_exc:\n                        print(exc)\n                        last_exc = exc\n\nterminate = Event()\nt = Thread(target=poll)\nt.setDaemon(True)\nlock = RLock()\nwrite_file(PINS.filepath.get())\nt.start()\n"
              },
              "cell2": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": null,
                  "lib": null,
                  "mode": null,
                  "save_policy": 1
                },
                "data": "write_file(PINS.filepath.get())"
              },
              "cell3": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": null,
                  "lib": null,
                  "mode": null,
                  "save_policy": 1
                },
                "data": "terminate.set(); t.join()"
              },
              "rc": {
                "type": "reactor",
                "mode": "sync",
                "params": {
                  "filepath": {
                    "dtype": "str",
                    "pin": "input"
                  },
                  "latency": {
                    "dtype": "float",
                    "pin": "input"
                  },
                  "value": {
                    "dtype": [
                      "text",
                      "html"
                    ],
                    "must_be_defined": false,
                    "pin": "edit"
                  }
                }
              }
            }
          },
          "html_dynamic": {
            "type": "context",
            "like_worker": true,
            "like_cell": false,
            "pins": {
              "filepath": [
                "ExportedInputPin",
                "links.html_dynamic.rc.filepath"
              ],
              "latency": [
                "ExportedInputPin",
                "links.html_dynamic.rc.latency"
              ],
              "value": [
                "ExportedEditPin",
                "links.html_dynamic.rc.value"
              ]
            },
            "auto": [
              "cell1",
              "cell2",
              "cell3"
            ],
            "children": {
              "cell1": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": "/cell-filelink-start.py",
                  "lib": true,
                  "mode": 2,
                  "save_policy": 1
                },
                "data": "if __name__ == \"__main__\":\n    #test with ipython -i\n    import sys, os\n\n    class dummy:\n        pass\n\n    class EditPin:\n        def __init__(self, value):\n            self.value = value\n            self.defined = True\n        def set(self, value):\n            print(\"SET\", value)\n            self.value = value\n        def get(self):\n            return self.value\n\n    class Getter:\n        def __init__(self, arg):\n            self.arg = arg\n        def get(self):\n            return self.arg\n    PINS = dummy()\n    PINS.value = EditPin(\"test\")\n    directory = sys.argv[1]\n    filename = sys.argv[2]\n    PINS.filepath = Getter(os.path.join(directory, filename))\n    PINS.latency = Getter(float(sys.argv[3]))\n    def serializer(v):\n        return str(v.get())\n    print(\"Edit in \" + filepath.get())\nelse:\n    from seamless.dtypes import serialize\n    def serializer(v):\n        return serialize(v._dtype, v.get())\n\n\nimport os, time, functools, traceback\nfrom threading import Thread, RLock, Event\nlast_value = None\nlast_serialized_value = None\nlast_exc = None\nlast_mtime = None\n\ndef write_file(fpath):\n    global last_mtime, last_value, last_serialized_value\n    if not PINS.value.defined:\n        last_mtime = -1 #will trigger a file read\n        return\n    if last_value == PINS.value.get():\n        return\n    val = serializer(PINS.value)\n    if last_serialized_value == val:\n        return\n    with lock:\n        if last_serialized_value != val:\n            #print(\"WRITE\", val)\n            if PINS.value._dtype == \"object\":\n                with open(fpath, \"wb\") as f:\n                    f.write(val)\n                    last_value = PINS.value.get()\n                    last_serialized_value = val\n            else:\n                with open(fpath, \"w\", encoding=\"utf-8\") as f:\n                    f.write(val)\n                    last_value = PINS.value.get()\n                    last_serialized_value = val\n            last_time = time.time()\n            try:\n                stat = os.stat(fpath)\n                last_mtime = stat.st_mtime\n            except Exception:\n                pass\n\nsleeptime = 0.01\n\ndef poll():\n    global last_time, last_mtime, last_value, last_serialized_value, last_exc\n    fpath = PINS.filepath.get()\n    while 1:\n        sleeps = int(PINS.latency.get() / sleeptime + 0.9999)\n        for n in range(sleeps):\n            time.sleep(sleeptime)\n            if terminate.is_set():\n                break\n        if terminate.is_set():\n            break\n        curr_time = time.time()\n        last_time = curr_time\n        if not os.path.exists(fpath):\n            try:\n                write_file(fpath)\n            except Exception:\n                exc = traceback.format_exc()\n                if exc != last_exc:\n                    print(exc)\n                    last_exc = exc\n        else:\n            with lock:\n                stat = os.stat(fpath)\n                try:\n                    if last_mtime is None or stat.st_mtime > last_mtime:\n                        data = None\n                        if PINS.value._dtype == \"object\":\n                            with open(fpath, \"rb\") as f:\n                                data = f.read()\n                        else:\n                            with open(fpath, encoding=\"utf-8\") as f:\n                                data = f.read()\n                        if data is not None:\n                            if last_serialized_value != data:\n                                #print(\"LOAD\")\n                                PINS.value.set(data)\n                                last_value = None\n                                last_serialized_value = data\n                        last_mtime = stat.st_mtime\n                except Exception:\n                    exc = traceback.format_exc()\n                    if exc != last_exc:\n                        print(exc)\n                        last_exc = exc\n\nterminate = Event()\nt = Thread(target=poll)\nt.setDaemon(True)\nlock = RLock()\nwrite_file(PINS.filepath.get())\nt.start()\n"
              },
              "cell2": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": null,
                  "lib": null,
                  "mode": null,
                  "save_policy": 1
                },
                "data": "write_file(PINS.filepath.get())"
              },
              "cell3": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": null,
                  "lib": null,
                  "mode": null,
                  "save_policy": 1
                },
                "data": "terminate.set(); t.join()"
              },
              "rc": {
                "type": "reactor",
                "mode": "sync",
                "params": {
                  "filepath": {
                    "dtype": "str",
                    "pin": "input"
                  },
                  "latency": {
                    "dtype": "float",
                    "pin": "input"
                  },
                  "value": {
                    "dtype": [
                      "text",
                      "html"
                    ],
                    "must_be_defined": false,
                    "pin": "edit"
                  }
                }
              }
            }
          },
          "params_templateer_static": {
            "type": "context",
            "like_worker": true,
            "like_cell": false,
            "pins": {
              "filepath": [
                "ExportedInputPin",
                "links.params_templateer_static.rc.filepath"
              ],
              "latency": [
                "ExportedInputPin",
                "links.params_templateer_static.rc.latency"
              ],
              "value": [
                "ExportedEditPin",
                "links.params_templateer_static.rc.value"
              ]
            },
            "auto": [
              "cell1",
              "cell2",
              "cell3"
            ],
            "children": {
              "cell1": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": "/cell-filelink-start.py",
                  "lib": true,
                  "mode": 2,
                  "save_policy": 1
                },
                "data": "if __name__ == \"__main__\":\n    #test with ipython -i\n    import sys, os\n\n    class dummy:\n        pass\n\n    class EditPin:\n        def __init__(self, value):\n            self.value = value\n            self.defined = True\n        def set(self, value):\n            print(\"SET\", value)\n            self.value = value\n        def get(self):\n            return self.value\n\n    class Getter:\n        def __init__(self, arg):\n            self.arg = arg\n        def get(self):\n            return self.arg\n    PINS = dummy()\n    PINS.value = EditPin(\"test\")\n    directory = sys.argv[1]\n    filename = sys.argv[2]\n    PINS.filepath = Getter(os.path.join(directory, filename))\n    PINS.latency = Getter(float(sys.argv[3]))\n    def serializer(v):\n        return str(v.get())\n    print(\"Edit in \" + filepath.get())\nelse:\n    from seamless.dtypes import serialize\n    def serializer(v):\n        return serialize(v._dtype, v.get())\n\n\nimport os, time, functools, traceback\nfrom threading import Thread, RLock, Event\nlast_value = None\nlast_serialized_value = None\nlast_exc = None\nlast_mtime = None\n\ndef write_file(fpath):\n    global last_mtime, last_value, last_serialized_value\n    if not PINS.value.defined:\n        last_mtime = -1 #will trigger a file read\n        return\n    if last_value == PINS.value.get():\n        return\n    val = serializer(PINS.value)\n    if last_serialized_value == val:\n        return\n    with lock:\n        if last_serialized_value != val:\n            #print(\"WRITE\", val)\n            if PINS.value._dtype == \"object\":\n                with open(fpath, \"wb\") as f:\n                    f.write(val)\n                    last_value = PINS.value.get()\n                    last_serialized_value = val\n            else:\n                with open(fpath, \"w\", encoding=\"utf-8\") as f:\n                    f.write(val)\n                    last_value = PINS.value.get()\n                    last_serialized_value = val\n            last_time = time.time()\n            try:\n                stat = os.stat(fpath)\n                last_mtime = stat.st_mtime\n            except Exception:\n                pass\n\nsleeptime = 0.01\n\ndef poll():\n    global last_time, last_mtime, last_value, last_serialized_value, last_exc\n    fpath = PINS.filepath.get()\n    while 1:\n        sleeps = int(PINS.latency.get() / sleeptime + 0.9999)\n        for n in range(sleeps):\n            time.sleep(sleeptime)\n            if terminate.is_set():\n                break\n        if terminate.is_set():\n            break\n        curr_time = time.time()\n        last_time = curr_time\n        if not os.path.exists(fpath):\n            try:\n                write_file(fpath)\n            except Exception:\n                exc = traceback.format_exc()\n                if exc != last_exc:\n                    print(exc)\n                    last_exc = exc\n        else:\n            with lock:\n                stat = os.stat(fpath)\n                try:\n                    if last_mtime is None or stat.st_mtime > last_mtime:\n                        data = None\n                        if PINS.value._dtype == \"object\":\n                            with open(fpath, \"rb\") as f:\n                                data = f.read()\n                        else:\n                            with open(fpath, encoding=\"utf-8\") as f:\n                                data = f.read()\n                        if data is not None:\n                            if last_serialized_value != data:\n                                #print(\"LOAD\")\n                                PINS.value.set(data)\n                                last_value = None\n                                last_serialized_value = data\n                        last_mtime = stat.st_mtime\n                except Exception:\n                    exc = traceback.format_exc()\n                    if exc != last_exc:\n                        print(exc)\n                        last_exc = exc\n\nterminate = Event()\nt = Thread(target=poll)\nt.setDaemon(True)\nlock = RLock()\nwrite_file(PINS.filepath.get())\nt.start()\n"
              },
              "cell2": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": null,
                  "lib": null,
                  "mode": null,
                  "save_policy": 1
                },
                "data": "write_file(PINS.filepath.get())"
              },
              "cell3": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": null,
                  "lib": null,
                  "mode": null,
                  "save_policy": 1
                },
                "data": "terminate.set(); t.join()"
              },
              "rc": {
                "type": "reactor",
                "mode": "sync",
                "params": {
                  "filepath": {
                    "dtype": "str",
                    "pin": "input"
                  },
                  "latency": {
                    "dtype": "float",
                    "pin": "input"
                  },
                  "value": {
                    "dtype": "cson",
                    "must_be_defined": false,
                    "pin": "edit"
                  }
                }
              }
            }
          },
          "plotly_config": {
            "type": "context",
            "like_worker": true,
            "like_cell": false,
            "pins": {
              "filepath": [
                "ExportedInputPin",
                "links.plotly_config.rc.filepath"
              ],
              "latency": [
                "ExportedInputPin",
                "links.plotly_config.rc.latency"
              ],
              "value": [
                "ExportedEditPin",
                "links.plotly_config.rc.value"
              ]
            },
            "auto": [
              "cell1",
              "cell2",
              "cell3"
            ],
            "children": {
              "cell1": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": "/cell-filelink-start.py",
                  "lib": true,
                  "mode": 2,
                  "save_policy": 1
                },
                "data": "if __name__ == \"__main__\":\n    #test with ipython -i\n    import sys, os\n\n    class dummy:\n        pass\n\n    class EditPin:\n        def __init__(self, value):\n            self.value = value\n            self.defined = True\n        def set(self, value):\n            print(\"SET\", value)\n            self.value = value\n        def get(self):\n            return self.value\n\n    class Getter:\n        def __init__(self, arg):\n            self.arg = arg\n        def get(self):\n            return self.arg\n    PINS = dummy()\n    PINS.value = EditPin(\"test\")\n    directory = sys.argv[1]\n    filename = sys.argv[2]\n    PINS.filepath = Getter(os.path.join(directory, filename))\n    PINS.latency = Getter(float(sys.argv[3]))\n    def serializer(v):\n        return str(v.get())\n    print(\"Edit in \" + filepath.get())\nelse:\n    from seamless.dtypes import serialize\n    def serializer(v):\n        return serialize(v._dtype, v.get())\n\n\nimport os, time, functools, traceback\nfrom threading import Thread, RLock, Event\nlast_value = None\nlast_serialized_value = None\nlast_exc = None\nlast_mtime = None\n\ndef write_file(fpath):\n    global last_mtime, last_value, last_serialized_value\n    if not PINS.value.defined:\n        last_mtime = -1 #will trigger a file read\n        return\n    if last_value == PINS.value.get():\n        return\n    val = serializer(PINS.value)\n    if last_serialized_value == val:\n        return\n    with lock:\n        if last_serialized_value != val:\n            #print(\"WRITE\", val)\n            if PINS.value._dtype == \"object\":\n                with open(fpath, \"wb\") as f:\n                    f.write(val)\n                    last_value = PINS.value.get()\n                    last_serialized_value = val\n            else:\n                with open(fpath, \"w\", encoding=\"utf-8\") as f:\n                    f.write(val)\n                    last_value = PINS.value.get()\n                    last_serialized_value = val\n            last_time = time.time()\n            try:\n                stat = os.stat(fpath)\n                last_mtime = stat.st_mtime\n            except Exception:\n                pass\n\nsleeptime = 0.01\n\ndef poll():\n    global last_time, last_mtime, last_value, last_serialized_value, last_exc\n    fpath = PINS.filepath.get()\n    while 1:\n        sleeps = int(PINS.latency.get() / sleeptime + 0.9999)\n        for n in range(sleeps):\n            time.sleep(sleeptime)\n            if terminate.is_set():\n                break\n        if terminate.is_set():\n            break\n        curr_time = time.time()\n        last_time = curr_time\n        if not os.path.exists(fpath):\n            try:\n                write_file(fpath)\n            except Exception:\n                exc = traceback.format_exc()\n                if exc != last_exc:\n                    print(exc)\n                    last_exc = exc\n        else:\n            with lock:\n                stat = os.stat(fpath)\n                try:\n                    if last_mtime is None or stat.st_mtime > last_mtime:\n                        data = None\n                        if PINS.value._dtype == \"object\":\n                            with open(fpath, \"rb\") as f:\n                                data = f.read()\n                        else:\n                            with open(fpath, encoding=\"utf-8\") as f:\n                                data = f.read()\n                        if data is not None:\n                            if last_serialized_value != data:\n                                #print(\"LOAD\")\n                                PINS.value.set(data)\n                                last_value = None\n                                last_serialized_value = data\n                        last_mtime = stat.st_mtime\n                except Exception:\n                    exc = traceback.format_exc()\n                    if exc != last_exc:\n                        print(exc)\n                        last_exc = exc\n\nterminate = Event()\nt = Thread(target=poll)\nt.setDaemon(True)\nlock = RLock()\nwrite_file(PINS.filepath.get())\nt.start()\n"
              },
              "cell2": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": null,
                  "lib": null,
                  "mode": null,
                  "save_policy": 1
                },
                "data": "write_file(PINS.filepath.get())"
              },
              "cell3": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": null,
                  "lib": null,
                  "mode": null,
                  "save_policy": 1
                },
                "data": "terminate.set(); t.join()"
              },
              "rc": {
                "type": "reactor",
                "mode": "sync",
                "params": {
                  "filepath": {
                    "dtype": "str",
                    "pin": "input"
                  },
                  "latency": {
                    "dtype": "float",
                    "pin": "input"
                  },
                  "value": {
                    "dtype": "cson",
                    "must_be_defined": false,
                    "pin": "edit"
                  }
                }
              }
            }
          },
          "plotly_data": {
            "type": "context",
            "like_worker": true,
            "like_cell": false,
            "pins": {
              "filepath": [
                "ExportedInputPin",
                "links.plotly_data.rc.filepath"
              ],
              "latency": [
                "ExportedInputPin",
                "links.plotly_data.rc.latency"
              ],
              "value": [
                "ExportedEditPin",
                "links.plotly_data.rc.value"
              ]
            },
            "auto": [
              "cell1",
              "cell2",
              "cell3"
            ],
            "children": {
              "cell1": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": "/cell-filelink-start.py",
                  "lib": true,
                  "mode": 2,
                  "save_policy": 1
                },
                "data": "if __name__ == \"__main__\":\n    #test with ipython -i\n    import sys, os\n\n    class dummy:\n        pass\n\n    class EditPin:\n        def __init__(self, value):\n            self.value = value\n            self.defined = True\n        def set(self, value):\n            print(\"SET\", value)\n            self.value = value\n        def get(self):\n            return self.value\n\n    class Getter:\n        def __init__(self, arg):\n            self.arg = arg\n        def get(self):\n            return self.arg\n    PINS = dummy()\n    PINS.value = EditPin(\"test\")\n    directory = sys.argv[1]\n    filename = sys.argv[2]\n    PINS.filepath = Getter(os.path.join(directory, filename))\n    PINS.latency = Getter(float(sys.argv[3]))\n    def serializer(v):\n        return str(v.get())\n    print(\"Edit in \" + filepath.get())\nelse:\n    from seamless.dtypes import serialize\n    def serializer(v):\n        return serialize(v._dtype, v.get())\n\n\nimport os, time, functools, traceback\nfrom threading import Thread, RLock, Event\nlast_value = None\nlast_serialized_value = None\nlast_exc = None\nlast_mtime = None\n\ndef write_file(fpath):\n    global last_mtime, last_value, last_serialized_value\n    if not PINS.value.defined:\n        last_mtime = -1 #will trigger a file read\n        return\n    if last_value == PINS.value.get():\n        return\n    val = serializer(PINS.value)\n    if last_serialized_value == val:\n        return\n    with lock:\n        if last_serialized_value != val:\n            #print(\"WRITE\", val)\n            if PINS.value._dtype == \"object\":\n                with open(fpath, \"wb\") as f:\n                    f.write(val)\n                    last_value = PINS.value.get()\n                    last_serialized_value = val\n            else:\n                with open(fpath, \"w\", encoding=\"utf-8\") as f:\n                    f.write(val)\n                    last_value = PINS.value.get()\n                    last_serialized_value = val\n            last_time = time.time()\n            try:\n                stat = os.stat(fpath)\n                last_mtime = stat.st_mtime\n            except Exception:\n                pass\n\nsleeptime = 0.01\n\ndef poll():\n    global last_time, last_mtime, last_value, last_serialized_value, last_exc\n    fpath = PINS.filepath.get()\n    while 1:\n        sleeps = int(PINS.latency.get() / sleeptime + 0.9999)\n        for n in range(sleeps):\n            time.sleep(sleeptime)\n            if terminate.is_set():\n                break\n        if terminate.is_set():\n            break\n        curr_time = time.time()\n        last_time = curr_time\n        if not os.path.exists(fpath):\n            try:\n                write_file(fpath)\n            except Exception:\n                exc = traceback.format_exc()\n                if exc != last_exc:\n                    print(exc)\n                    last_exc = exc\n        else:\n            with lock:\n                stat = os.stat(fpath)\n                try:\n                    if last_mtime is None or stat.st_mtime > last_mtime:\n                        data = None\n                        if PINS.value._dtype == \"object\":\n                            with open(fpath, \"rb\") as f:\n                                data = f.read()\n                        else:\n                            with open(fpath, encoding=\"utf-8\") as f:\n                                data = f.read()\n                        if data is not None:\n                            if last_serialized_value != data:\n                                #print(\"LOAD\")\n                                PINS.value.set(data)\n                                last_value = None\n                                last_serialized_value = data\n                        last_mtime = stat.st_mtime\n                except Exception:\n                    exc = traceback.format_exc()\n                    if exc != last_exc:\n                        print(exc)\n                        last_exc = exc\n\nterminate = Event()\nt = Thread(target=poll)\nt.setDaemon(True)\nlock = RLock()\nwrite_file(PINS.filepath.get())\nt.start()\n"
              },
              "cell2": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": null,
                  "lib": null,
                  "mode": null,
                  "save_policy": 1
                },
                "data": "write_file(PINS.filepath.get())"
              },
              "cell3": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": null,
                  "lib": null,
                  "mode": null,
                  "save_policy": 1
                },
                "data": "terminate.set(); t.join()"
              },
              "rc": {
                "type": "reactor",
                "mode": "sync",
                "params": {
                  "filepath": {
                    "dtype": "str",
                    "pin": "input"
                  },
                  "latency": {
                    "dtype": "float",
                    "pin": "input"
                  },
                  "value": {
                    "dtype": "cson",
                    "must_be_defined": false,
                    "pin": "edit"
                  }
                }
              }
            }
          },
          "plotly_layout": {
            "type": "context",
            "like_worker": true,
            "like_cell": false,
            "pins": {
              "filepath": [
                "ExportedInputPin",
                "links.plotly_layout.rc.filepath"
              ],
              "latency": [
                "ExportedInputPin",
                "links.plotly_layout.rc.latency"
              ],
              "value": [
                "ExportedEditPin",
                "links.plotly_layout.rc.value"
              ]
            },
            "auto": [
              "cell1",
              "cell2",
              "cell3"
            ],
            "children": {
              "cell1": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": "/cell-filelink-start.py",
                  "lib": true,
                  "mode": 2,
                  "save_policy": 1
                },
                "data": "if __name__ == \"__main__\":\n    #test with ipython -i\n    import sys, os\n\n    class dummy:\n        pass\n\n    class EditPin:\n        def __init__(self, value):\n            self.value = value\n            self.defined = True\n        def set(self, value):\n            print(\"SET\", value)\n            self.value = value\n        def get(self):\n            return self.value\n\n    class Getter:\n        def __init__(self, arg):\n            self.arg = arg\n        def get(self):\n            return self.arg\n    PINS = dummy()\n    PINS.value = EditPin(\"test\")\n    directory = sys.argv[1]\n    filename = sys.argv[2]\n    PINS.filepath = Getter(os.path.join(directory, filename))\n    PINS.latency = Getter(float(sys.argv[3]))\n    def serializer(v):\n        return str(v.get())\n    print(\"Edit in \" + filepath.get())\nelse:\n    from seamless.dtypes import serialize\n    def serializer(v):\n        return serialize(v._dtype, v.get())\n\n\nimport os, time, functools, traceback\nfrom threading import Thread, RLock, Event\nlast_value = None\nlast_serialized_value = None\nlast_exc = None\nlast_mtime = None\n\ndef write_file(fpath):\n    global last_mtime, last_value, last_serialized_value\n    if not PINS.value.defined:\n        last_mtime = -1 #will trigger a file read\n        return\n    if last_value == PINS.value.get():\n        return\n    val = serializer(PINS.value)\n    if last_serialized_value == val:\n        return\n    with lock:\n        if last_serialized_value != val:\n            #print(\"WRITE\", val)\n            if PINS.value._dtype == \"object\":\n                with open(fpath, \"wb\") as f:\n                    f.write(val)\n                    last_value = PINS.value.get()\n                    last_serialized_value = val\n            else:\n                with open(fpath, \"w\", encoding=\"utf-8\") as f:\n                    f.write(val)\n                    last_value = PINS.value.get()\n                    last_serialized_value = val\n            last_time = time.time()\n            try:\n                stat = os.stat(fpath)\n                last_mtime = stat.st_mtime\n            except Exception:\n                pass\n\nsleeptime = 0.01\n\ndef poll():\n    global last_time, last_mtime, last_value, last_serialized_value, last_exc\n    fpath = PINS.filepath.get()\n    while 1:\n        sleeps = int(PINS.latency.get() / sleeptime + 0.9999)\n        for n in range(sleeps):\n            time.sleep(sleeptime)\n            if terminate.is_set():\n                break\n        if terminate.is_set():\n            break\n        curr_time = time.time()\n        last_time = curr_time\n        if not os.path.exists(fpath):\n            try:\n                write_file(fpath)\n            except Exception:\n                exc = traceback.format_exc()\n                if exc != last_exc:\n                    print(exc)\n                    last_exc = exc\n        else:\n            with lock:\n                stat = os.stat(fpath)\n                try:\n                    if last_mtime is None or stat.st_mtime > last_mtime:\n                        data = None\n                        if PINS.value._dtype == \"object\":\n                            with open(fpath, \"rb\") as f:\n                                data = f.read()\n                        else:\n                            with open(fpath, encoding=\"utf-8\") as f:\n                                data = f.read()\n                        if data is not None:\n                            if last_serialized_value != data:\n                                #print(\"LOAD\")\n                                PINS.value.set(data)\n                                last_value = None\n                                last_serialized_value = data\n                        last_mtime = stat.st_mtime\n                except Exception:\n                    exc = traceback.format_exc()\n                    if exc != last_exc:\n                        print(exc)\n                        last_exc = exc\n\nterminate = Event()\nt = Thread(target=poll)\nt.setDaemon(True)\nlock = RLock()\nwrite_file(PINS.filepath.get())\nt.start()\n"
              },
              "cell2": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": null,
                  "lib": null,
                  "mode": null,
                  "save_policy": 1
                },
                "data": "write_file(PINS.filepath.get())"
              },
              "cell3": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": null,
                  "lib": null,
                  "mode": null,
                  "save_policy": 1
                },
                "data": "terminate.set(); t.join()"
              },
              "rc": {
                "type": "reactor",
                "mode": "sync",
                "params": {
                  "filepath": {
                    "dtype": "str",
                    "pin": "input"
                  },
                  "latency": {
                    "dtype": "float",
                    "pin": "input"
                  },
                  "value": {
                    "dtype": "cson",
                    "must_be_defined": false,
                    "pin": "edit"
                  }
                }
              }
            }
          },
          "template_body": {
            "type": "context",
            "like_worker": true,
            "like_cell": false,
            "pins": {
              "filepath": [
                "ExportedInputPin",
                "links.template_body.rc.filepath"
              ],
              "latency": [
                "ExportedInputPin",
                "links.template_body.rc.latency"
              ],
              "value": [
                "ExportedEditPin",
                "links.template_body.rc.value"
              ]
            },
            "auto": [
              "cell1",
              "cell2",
              "cell3"
            ],
            "children": {
              "cell1": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": "/cell-filelink-start.py",
                  "lib": true,
                  "mode": 2,
                  "save_policy": 1
                },
                "data": "if __name__ == \"__main__\":\n    #test with ipython -i\n    import sys, os\n\n    class dummy:\n        pass\n\n    class EditPin:\n        def __init__(self, value):\n            self.value = value\n            self.defined = True\n        def set(self, value):\n            print(\"SET\", value)\n            self.value = value\n        def get(self):\n            return self.value\n\n    class Getter:\n        def __init__(self, arg):\n            self.arg = arg\n        def get(self):\n            return self.arg\n    PINS = dummy()\n    PINS.value = EditPin(\"test\")\n    directory = sys.argv[1]\n    filename = sys.argv[2]\n    PINS.filepath = Getter(os.path.join(directory, filename))\n    PINS.latency = Getter(float(sys.argv[3]))\n    def serializer(v):\n        return str(v.get())\n    print(\"Edit in \" + filepath.get())\nelse:\n    from seamless.dtypes import serialize\n    def serializer(v):\n        return serialize(v._dtype, v.get())\n\n\nimport os, time, functools, traceback\nfrom threading import Thread, RLock, Event\nlast_value = None\nlast_serialized_value = None\nlast_exc = None\nlast_mtime = None\n\ndef write_file(fpath):\n    global last_mtime, last_value, last_serialized_value\n    if not PINS.value.defined:\n        last_mtime = -1 #will trigger a file read\n        return\n    if last_value == PINS.value.get():\n        return\n    val = serializer(PINS.value)\n    if last_serialized_value == val:\n        return\n    with lock:\n        if last_serialized_value != val:\n            #print(\"WRITE\", val)\n            if PINS.value._dtype == \"object\":\n                with open(fpath, \"wb\") as f:\n                    f.write(val)\n                    last_value = PINS.value.get()\n                    last_serialized_value = val\n            else:\n                with open(fpath, \"w\", encoding=\"utf-8\") as f:\n                    f.write(val)\n                    last_value = PINS.value.get()\n                    last_serialized_value = val\n            last_time = time.time()\n            try:\n                stat = os.stat(fpath)\n                last_mtime = stat.st_mtime\n            except Exception:\n                pass\n\nsleeptime = 0.01\n\ndef poll():\n    global last_time, last_mtime, last_value, last_serialized_value, last_exc\n    fpath = PINS.filepath.get()\n    while 1:\n        sleeps = int(PINS.latency.get() / sleeptime + 0.9999)\n        for n in range(sleeps):\n            time.sleep(sleeptime)\n            if terminate.is_set():\n                break\n        if terminate.is_set():\n            break\n        curr_time = time.time()\n        last_time = curr_time\n        if not os.path.exists(fpath):\n            try:\n                write_file(fpath)\n            except Exception:\n                exc = traceback.format_exc()\n                if exc != last_exc:\n                    print(exc)\n                    last_exc = exc\n        else:\n            with lock:\n                stat = os.stat(fpath)\n                try:\n                    if last_mtime is None or stat.st_mtime > last_mtime:\n                        data = None\n                        if PINS.value._dtype == \"object\":\n                            with open(fpath, \"rb\") as f:\n                                data = f.read()\n                        else:\n                            with open(fpath, encoding=\"utf-8\") as f:\n                                data = f.read()\n                        if data is not None:\n                            if last_serialized_value != data:\n                                #print(\"LOAD\")\n                                PINS.value.set(data)\n                                last_value = None\n                                last_serialized_value = data\n                        last_mtime = stat.st_mtime\n                except Exception:\n                    exc = traceback.format_exc()\n                    if exc != last_exc:\n                        print(exc)\n                        last_exc = exc\n\nterminate = Event()\nt = Thread(target=poll)\nt.setDaemon(True)\nlock = RLock()\nwrite_file(PINS.filepath.get())\nt.start()\n"
              },
              "cell2": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": null,
                  "lib": null,
                  "mode": null,
                  "save_policy": 1
                },
                "data": "write_file(PINS.filepath.get())"
              },
              "cell3": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": null,
                  "lib": null,
                  "mode": null,
                  "save_policy": 1
                },
                "data": "terminate.set(); t.join()"
              },
              "rc": {
                "type": "reactor",
                "mode": "sync",
                "params": {
                  "filepath": {
                    "dtype": "str",
                    "pin": "input"
                  },
                  "latency": {
                    "dtype": "float",
                    "pin": "input"
                  },
                  "value": {
                    "dtype": "text",
                    "must_be_defined": false,
                    "pin": "edit"
                  }
                }
              }
            }
          },
          "template_body_dynamic": {
            "type": "context",
            "like_worker": true,
            "like_cell": false,
            "pins": {
              "filepath": [
                "ExportedInputPin",
                "links.template_body_dynamic.rc.filepath"
              ],
              "latency": [
                "ExportedInputPin",
                "links.template_body_dynamic.rc.latency"
              ],
              "value": [
                "ExportedEditPin",
                "links.template_body_dynamic.rc.value"
              ]
            },
            "auto": [
              "cell1",
              "cell2",
              "cell3"
            ],
            "children": {
              "cell1": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": "/cell-filelink-start.py",
                  "lib": true,
                  "mode": 2,
                  "save_policy": 1
                },
                "data": "if __name__ == \"__main__\":\n    #test with ipython -i\n    import sys, os\n\n    class dummy:\n        pass\n\n    class EditPin:\n        def __init__(self, value):\n            self.value = value\n            self.defined = True\n        def set(self, value):\n            print(\"SET\", value)\n            self.value = value\n        def get(self):\n            return self.value\n\n    class Getter:\n        def __init__(self, arg):\n            self.arg = arg\n        def get(self):\n            return self.arg\n    PINS = dummy()\n    PINS.value = EditPin(\"test\")\n    directory = sys.argv[1]\n    filename = sys.argv[2]\n    PINS.filepath = Getter(os.path.join(directory, filename))\n    PINS.latency = Getter(float(sys.argv[3]))\n    def serializer(v):\n        return str(v.get())\n    print(\"Edit in \" + filepath.get())\nelse:\n    from seamless.dtypes import serialize\n    def serializer(v):\n        return serialize(v._dtype, v.get())\n\n\nimport os, time, functools, traceback\nfrom threading import Thread, RLock, Event\nlast_value = None\nlast_serialized_value = None\nlast_exc = None\nlast_mtime = None\n\ndef write_file(fpath):\n    global last_mtime, last_value, last_serialized_value\n    if not PINS.value.defined:\n        last_mtime = -1 #will trigger a file read\n        return\n    if last_value == PINS.value.get():\n        return\n    val = serializer(PINS.value)\n    if last_serialized_value == val:\n        return\n    with lock:\n        if last_serialized_value != val:\n            #print(\"WRITE\", val)\n            if PINS.value._dtype == \"object\":\n                with open(fpath, \"wb\") as f:\n                    f.write(val)\n                    last_value = PINS.value.get()\n                    last_serialized_value = val\n            else:\n                with open(fpath, \"w\", encoding=\"utf-8\") as f:\n                    f.write(val)\n                    last_value = PINS.value.get()\n                    last_serialized_value = val\n            last_time = time.time()\n            try:\n                stat = os.stat(fpath)\n                last_mtime = stat.st_mtime\n            except Exception:\n                pass\n\nsleeptime = 0.01\n\ndef poll():\n    global last_time, last_mtime, last_value, last_serialized_value, last_exc\n    fpath = PINS.filepath.get()\n    while 1:\n        sleeps = int(PINS.latency.get() / sleeptime + 0.9999)\n        for n in range(sleeps):\n            time.sleep(sleeptime)\n            if terminate.is_set():\n                break\n        if terminate.is_set():\n            break\n        curr_time = time.time()\n        last_time = curr_time\n        if not os.path.exists(fpath):\n            try:\n                write_file(fpath)\n            except Exception:\n                exc = traceback.format_exc()\n                if exc != last_exc:\n                    print(exc)\n                    last_exc = exc\n        else:\n            with lock:\n                stat = os.stat(fpath)\n                try:\n                    if last_mtime is None or stat.st_mtime > last_mtime:\n                        data = None\n                        if PINS.value._dtype == \"object\":\n                            with open(fpath, \"rb\") as f:\n                                data = f.read()\n                        else:\n                            with open(fpath, encoding=\"utf-8\") as f:\n                                data = f.read()\n                        if data is not None:\n                            if last_serialized_value != data:\n                                #print(\"LOAD\")\n                                PINS.value.set(data)\n                                last_value = None\n                                last_serialized_value = data\n                        last_mtime = stat.st_mtime\n                except Exception:\n                    exc = traceback.format_exc()\n                    if exc != last_exc:\n                        print(exc)\n                        last_exc = exc\n\nterminate = Event()\nt = Thread(target=poll)\nt.setDaemon(True)\nlock = RLock()\nwrite_file(PINS.filepath.get())\nt.start()\n"
              },
              "cell2": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": null,
                  "lib": null,
                  "mode": null,
                  "save_policy": 1
                },
                "data": "write_file(PINS.filepath.get())"
              },
              "cell3": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": null,
                  "lib": null,
                  "mode": null,
                  "save_policy": 1
                },
                "data": "terminate.set(); t.join()"
              },
              "rc": {
                "type": "reactor",
                "mode": "sync",
                "params": {
                  "filepath": {
                    "dtype": "str",
                    "pin": "input"
                  },
                  "latency": {
                    "dtype": "float",
                    "pin": "input"
                  },
                  "value": {
                    "dtype": "text",
                    "must_be_defined": false,
                    "pin": "edit"
                  }
                }
              }
            }
          },
          "template_head": {
            "type": "context",
            "like_worker": true,
            "like_cell": false,
            "pins": {
              "filepath": [
                "ExportedInputPin",
                "links.template_head.rc.filepath"
              ],
              "latency": [
                "ExportedInputPin",
                "links.template_head.rc.latency"
              ],
              "value": [
                "ExportedEditPin",
                "links.template_head.rc.value"
              ]
            },
            "auto": [
              "cell1",
              "cell2",
              "cell3"
            ],
            "children": {
              "cell1": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": "/cell-filelink-start.py",
                  "lib": true,
                  "mode": 2,
                  "save_policy": 1
                },
                "data": "if __name__ == \"__main__\":\n    #test with ipython -i\n    import sys, os\n\n    class dummy:\n        pass\n\n    class EditPin:\n        def __init__(self, value):\n            self.value = value\n            self.defined = True\n        def set(self, value):\n            print(\"SET\", value)\n            self.value = value\n        def get(self):\n            return self.value\n\n    class Getter:\n        def __init__(self, arg):\n            self.arg = arg\n        def get(self):\n            return self.arg\n    PINS = dummy()\n    PINS.value = EditPin(\"test\")\n    directory = sys.argv[1]\n    filename = sys.argv[2]\n    PINS.filepath = Getter(os.path.join(directory, filename))\n    PINS.latency = Getter(float(sys.argv[3]))\n    def serializer(v):\n        return str(v.get())\n    print(\"Edit in \" + filepath.get())\nelse:\n    from seamless.dtypes import serialize\n    def serializer(v):\n        return serialize(v._dtype, v.get())\n\n\nimport os, time, functools, traceback\nfrom threading import Thread, RLock, Event\nlast_value = None\nlast_serialized_value = None\nlast_exc = None\nlast_mtime = None\n\ndef write_file(fpath):\n    global last_mtime, last_value, last_serialized_value\n    if not PINS.value.defined:\n        last_mtime = -1 #will trigger a file read\n        return\n    if last_value == PINS.value.get():\n        return\n    val = serializer(PINS.value)\n    if last_serialized_value == val:\n        return\n    with lock:\n        if last_serialized_value != val:\n            #print(\"WRITE\", val)\n            if PINS.value._dtype == \"object\":\n                with open(fpath, \"wb\") as f:\n                    f.write(val)\n                    last_value = PINS.value.get()\n                    last_serialized_value = val\n            else:\n                with open(fpath, \"w\", encoding=\"utf-8\") as f:\n                    f.write(val)\n                    last_value = PINS.value.get()\n                    last_serialized_value = val\n            last_time = time.time()\n            try:\n                stat = os.stat(fpath)\n                last_mtime = stat.st_mtime\n            except Exception:\n                pass\n\nsleeptime = 0.01\n\ndef poll():\n    global last_time, last_mtime, last_value, last_serialized_value, last_exc\n    fpath = PINS.filepath.get()\n    while 1:\n        sleeps = int(PINS.latency.get() / sleeptime + 0.9999)\n        for n in range(sleeps):\n            time.sleep(sleeptime)\n            if terminate.is_set():\n                break\n        if terminate.is_set():\n            break\n        curr_time = time.time()\n        last_time = curr_time\n        if not os.path.exists(fpath):\n            try:\n                write_file(fpath)\n            except Exception:\n                exc = traceback.format_exc()\n                if exc != last_exc:\n                    print(exc)\n                    last_exc = exc\n        else:\n            with lock:\n                stat = os.stat(fpath)\n                try:\n                    if last_mtime is None or stat.st_mtime > last_mtime:\n                        data = None\n                        if PINS.value._dtype == \"object\":\n                            with open(fpath, \"rb\") as f:\n                                data = f.read()\n                        else:\n                            with open(fpath, encoding=\"utf-8\") as f:\n                                data = f.read()\n                        if data is not None:\n                            if last_serialized_value != data:\n                                #print(\"LOAD\")\n                                PINS.value.set(data)\n                                last_value = None\n                                last_serialized_value = data\n                        last_mtime = stat.st_mtime\n                except Exception:\n                    exc = traceback.format_exc()\n                    if exc != last_exc:\n                        print(exc)\n                        last_exc = exc\n\nterminate = Event()\nt = Thread(target=poll)\nt.setDaemon(True)\nlock = RLock()\nwrite_file(PINS.filepath.get())\nt.start()\n"
              },
              "cell2": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": null,
                  "lib": null,
                  "mode": null,
                  "save_policy": 1
                },
                "data": "write_file(PINS.filepath.get())"
              },
              "cell3": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": null,
                  "lib": null,
                  "mode": null,
                  "save_policy": 1
                },
                "data": "terminate.set(); t.join()"
              },
              "rc": {
                "type": "reactor",
                "mode": "sync",
                "params": {
                  "filepath": {
                    "dtype": "str",
                    "pin": "input"
                  },
                  "latency": {
                    "dtype": "float",
                    "pin": "input"
                  },
                  "value": {
                    "dtype": "text",
                    "must_be_defined": false,
                    "pin": "edit"
                  }
                }
              }
            }
          },
          "template_html_head_body": {
            "type": "context",
            "like_worker": true,
            "like_cell": false,
            "pins": {
              "filepath": [
                "ExportedInputPin",
                "links.template_html_head_body.rc.filepath"
              ],
              "latency": [
                "ExportedInputPin",
                "links.template_html_head_body.rc.latency"
              ],
              "value": [
                "ExportedEditPin",
                "links.template_html_head_body.rc.value"
              ]
            },
            "auto": [
              "cell1",
              "cell2",
              "cell3"
            ],
            "children": {
              "cell1": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": "/cell-filelink-start.py",
                  "lib": true,
                  "mode": 2,
                  "save_policy": 1
                },
                "data": "if __name__ == \"__main__\":\n    #test with ipython -i\n    import sys, os\n\n    class dummy:\n        pass\n\n    class EditPin:\n        def __init__(self, value):\n            self.value = value\n            self.defined = True\n        def set(self, value):\n            print(\"SET\", value)\n            self.value = value\n        def get(self):\n            return self.value\n\n    class Getter:\n        def __init__(self, arg):\n            self.arg = arg\n        def get(self):\n            return self.arg\n    PINS = dummy()\n    PINS.value = EditPin(\"test\")\n    directory = sys.argv[1]\n    filename = sys.argv[2]\n    PINS.filepath = Getter(os.path.join(directory, filename))\n    PINS.latency = Getter(float(sys.argv[3]))\n    def serializer(v):\n        return str(v.get())\n    print(\"Edit in \" + filepath.get())\nelse:\n    from seamless.dtypes import serialize\n    def serializer(v):\n        return serialize(v._dtype, v.get())\n\n\nimport os, time, functools, traceback\nfrom threading import Thread, RLock, Event\nlast_value = None\nlast_serialized_value = None\nlast_exc = None\nlast_mtime = None\n\ndef write_file(fpath):\n    global last_mtime, last_value, last_serialized_value\n    if not PINS.value.defined:\n        last_mtime = -1 #will trigger a file read\n        return\n    if last_value == PINS.value.get():\n        return\n    val = serializer(PINS.value)\n    if last_serialized_value == val:\n        return\n    with lock:\n        if last_serialized_value != val:\n            #print(\"WRITE\", val)\n            if PINS.value._dtype == \"object\":\n                with open(fpath, \"wb\") as f:\n                    f.write(val)\n                    last_value = PINS.value.get()\n                    last_serialized_value = val\n            else:\n                with open(fpath, \"w\", encoding=\"utf-8\") as f:\n                    f.write(val)\n                    last_value = PINS.value.get()\n                    last_serialized_value = val\n            last_time = time.time()\n            try:\n                stat = os.stat(fpath)\n                last_mtime = stat.st_mtime\n            except Exception:\n                pass\n\nsleeptime = 0.01\n\ndef poll():\n    global last_time, last_mtime, last_value, last_serialized_value, last_exc\n    fpath = PINS.filepath.get()\n    while 1:\n        sleeps = int(PINS.latency.get() / sleeptime + 0.9999)\n        for n in range(sleeps):\n            time.sleep(sleeptime)\n            if terminate.is_set():\n                break\n        if terminate.is_set():\n            break\n        curr_time = time.time()\n        last_time = curr_time\n        if not os.path.exists(fpath):\n            try:\n                write_file(fpath)\n            except Exception:\n                exc = traceback.format_exc()\n                if exc != last_exc:\n                    print(exc)\n                    last_exc = exc\n        else:\n            with lock:\n                stat = os.stat(fpath)\n                try:\n                    if last_mtime is None or stat.st_mtime > last_mtime:\n                        data = None\n                        if PINS.value._dtype == \"object\":\n                            with open(fpath, \"rb\") as f:\n                                data = f.read()\n                        else:\n                            with open(fpath, encoding=\"utf-8\") as f:\n                                data = f.read()\n                        if data is not None:\n                            if last_serialized_value != data:\n                                #print(\"LOAD\")\n                                PINS.value.set(data)\n                                last_value = None\n                                last_serialized_value = data\n                        last_mtime = stat.st_mtime\n                except Exception:\n                    exc = traceback.format_exc()\n                    if exc != last_exc:\n                        print(exc)\n                        last_exc = exc\n\nterminate = Event()\nt = Thread(target=poll)\nt.setDaemon(True)\nlock = RLock()\nwrite_file(PINS.filepath.get())\nt.start()\n"
              },
              "cell2": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": null,
                  "lib": null,
                  "mode": null,
                  "save_policy": 1
                },
                "data": "write_file(PINS.filepath.get())"
              },
              "cell3": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": null,
                  "lib": null,
                  "mode": null,
                  "save_policy": 1
                },
                "data": "terminate.set(); t.join()"
              },
              "rc": {
                "type": "reactor",
                "mode": "sync",
                "params": {
                  "filepath": {
                    "dtype": "str",
                    "pin": "input"
                  },
                  "latency": {
                    "dtype": "float",
                    "pin": "input"
                  },
                  "value": {
                    "dtype": [
                      "text",
                      "html"
                    ],
                    "must_be_defined": false,
                    "pin": "edit"
                  }
                }
              }
            }
          },
          "title": {
            "type": "context",
            "like_worker": true,
            "like_cell": false,
            "pins": {
              "filepath": [
                "ExportedInputPin",
                "links.title.rc.filepath"
              ],
              "latency": [
                "ExportedInputPin",
                "links.title.rc.latency"
              ],
              "value": [
                "ExportedEditPin",
                "links.title.rc.value"
              ]
            },
            "auto": [
              "cell1",
              "cell2",
              "cell3"
            ],
            "children": {
              "cell1": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": "/cell-filelink-start.py",
                  "lib": true,
                  "mode": 2,
                  "save_policy": 1
                },
                "data": "if __name__ == \"__main__\":\n    #test with ipython -i\n    import sys, os\n\n    class dummy:\n        pass\n\n    class EditPin:\n        def __init__(self, value):\n            self.value = value\n            self.defined = True\n        def set(self, value):\n            print(\"SET\", value)\n            self.value = value\n        def get(self):\n            return self.value\n\n    class Getter:\n        def __init__(self, arg):\n            self.arg = arg\n        def get(self):\n            return self.arg\n    PINS = dummy()\n    PINS.value = EditPin(\"test\")\n    directory = sys.argv[1]\n    filename = sys.argv[2]\n    PINS.filepath = Getter(os.path.join(directory, filename))\n    PINS.latency = Getter(float(sys.argv[3]))\n    def serializer(v):\n        return str(v.get())\n    print(\"Edit in \" + filepath.get())\nelse:\n    from seamless.dtypes import serialize\n    def serializer(v):\n        return serialize(v._dtype, v.get())\n\n\nimport os, time, functools, traceback\nfrom threading import Thread, RLock, Event\nlast_value = None\nlast_serialized_value = None\nlast_exc = None\nlast_mtime = None\n\ndef write_file(fpath):\n    global last_mtime, last_value, last_serialized_value\n    if not PINS.value.defined:\n        last_mtime = -1 #will trigger a file read\n        return\n    if last_value == PINS.value.get():\n        return\n    val = serializer(PINS.value)\n    if last_serialized_value == val:\n        return\n    with lock:\n        if last_serialized_value != val:\n            #print(\"WRITE\", val)\n            if PINS.value._dtype == \"object\":\n                with open(fpath, \"wb\") as f:\n                    f.write(val)\n                    last_value = PINS.value.get()\n                    last_serialized_value = val\n            else:\n                with open(fpath, \"w\", encoding=\"utf-8\") as f:\n                    f.write(val)\n                    last_value = PINS.value.get()\n                    last_serialized_value = val\n            last_time = time.time()\n            try:\n                stat = os.stat(fpath)\n                last_mtime = stat.st_mtime\n            except Exception:\n                pass\n\nsleeptime = 0.01\n\ndef poll():\n    global last_time, last_mtime, last_value, last_serialized_value, last_exc\n    fpath = PINS.filepath.get()\n    while 1:\n        sleeps = int(PINS.latency.get() / sleeptime + 0.9999)\n        for n in range(sleeps):\n            time.sleep(sleeptime)\n            if terminate.is_set():\n                break\n        if terminate.is_set():\n            break\n        curr_time = time.time()\n        last_time = curr_time\n        if not os.path.exists(fpath):\n            try:\n                write_file(fpath)\n            except Exception:\n                exc = traceback.format_exc()\n                if exc != last_exc:\n                    print(exc)\n                    last_exc = exc\n        else:\n            with lock:\n                stat = os.stat(fpath)\n                try:\n                    if last_mtime is None or stat.st_mtime > last_mtime:\n                        data = None\n                        if PINS.value._dtype == \"object\":\n                            with open(fpath, \"rb\") as f:\n                                data = f.read()\n                        else:\n                            with open(fpath, encoding=\"utf-8\") as f:\n                                data = f.read()\n                        if data is not None:\n                            if last_serialized_value != data:\n                                #print(\"LOAD\")\n                                PINS.value.set(data)\n                                last_value = None\n                                last_serialized_value = data\n                        last_mtime = stat.st_mtime\n                except Exception:\n                    exc = traceback.format_exc()\n                    if exc != last_exc:\n                        print(exc)\n                        last_exc = exc\n\nterminate = Event()\nt = Thread(target=poll)\nt.setDaemon(True)\nlock = RLock()\nwrite_file(PINS.filepath.get())\nt.start()\n"
              },
              "cell2": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": null,
                  "lib": null,
                  "mode": null,
                  "save_policy": 1
                },
                "data": "write_file(PINS.filepath.get())"
              },
              "cell3": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": null,
                  "lib": null,
                  "mode": null,
                  "save_policy": 1
                },
                "data": "terminate.set(); t.join()"
              },
              "rc": {
                "type": "reactor",
                "mode": "sync",
                "params": {
                  "filepath": {
                    "dtype": "str",
                    "pin": "input"
                  },
                  "latency": {
                    "dtype": "float",
                    "pin": "input"
                  },
                  "value": {
                    "dtype": "text",
                    "must_be_defined": false,
                    "pin": "edit"
                  }
                }
              }
            }
          }
        }
      },
      "load_data_columns": {
        "type": "transformer",
        "mode": "thread",
        "params": {
          "csv": {
            "dtype": "text",
            "pin": "input"
          },
          "data": {
            "dtype": "json",
            "pin": "output"
          },
          "point_shift": {
            "dtype": "float",
            "pin": "input"
          }
        }
      },
      "params": {
        "type": "context",
        "like_worker": false,
        "like_cell": false,
        "pins": {},
        "auto": [
          "cell1",
          "cell10",
          "cell11",
          "cell12",
          "cell13",
          "cell14",
          "cell15",
          "cell16",
          "cell2",
          "cell3",
          "cell4",
          "cell5",
          "cell6",
          "cell7",
          "cell8",
          "cell9"
        ],
        "children": {
          "cell1": {
            "dtype": "str",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "./params-templateer-static.cson"
          },
          "cell10": {
            "dtype": "int",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "500"
          },
          "cell11": {
            "dtype": "str",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "plotdata/plotly_data.cson"
          },
          "cell12": {
            "dtype": "float",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "0.2"
          },
          "cell13": {
            "dtype": "str",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "plotdata/layout.cson"
          },
          "cell14": {
            "dtype": "float",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "0.2"
          },
          "cell15": {
            "dtype": "str",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "plotdata/config.cson"
          },
          "cell16": {
            "dtype": "float",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "0.2"
          },
          "cell2": {
            "dtype": "float",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "0.2"
          },
          "cell3": {
            "dtype": "str",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "./template-head.jinja"
          },
          "cell4": {
            "dtype": "float",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "0.2"
          },
          "cell5": {
            "dtype": "str",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "plotdata/title.txt"
          },
          "cell6": {
            "dtype": "float",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "0.2"
          },
          "cell7": {
            "dtype": "str",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "./template-body.jinja"
          },
          "cell8": {
            "dtype": "float",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "0.2"
          },
          "cell9": {
            "dtype": "int",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "500"
          },
          "dynamic_html": {
            "dtype": "json",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "{\n  \"divname\": {\n    \"type\": \"var\",\n    \"dtype\": \"str\"\n  },\n  \"attrib\": {\n    \"evals\": [\n      \"make_plot\"\n    ],\n    \"type\": \"var\",\n    \"dtype\": \"json\"\n  },\n  \"layout\": {\n    \"evals\": [\n      \"make_plot\"\n    ],\n    \"type\": \"var\",\n    \"dtype\": \"json\"\n  },\n  \"make_plot\": {\n    \"on_start\": true,\n    \"type\": \"eval\"\n  },\n  \"plotly_data\": {\n    \"evals\": [\n      \"make_plot\"\n    ],\n    \"type\": \"var\",\n    \"dtype\": \"json\"\n  },\n  \"config\": {\n    \"evals\": [\n      \"make_plot\"\n    ],\n    \"type\": \"var\",\n    \"dtype\": \"json\"\n  }\n}"
          },
          "templateer_dynamic": {
            "dtype": "cson",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "{\n  \"result\": \"head_body\",\n  \"templates\": [\n    \"body\",\n    \"head\",\n    \"head_body\"\n  ],\n  \"environment\": {\n    \"width\": \"int\",\n    \"divname\": \"text\",\n    \"title\": \"text\",\n    \"height\": \"int\",\n    \"dynamic_html\": [\n      \"text\",\n      \"html\"\n    ]\n  }\n}"
          },
          "templateer_static": {
            "dtype": "cson",
            "resource": {
              "filepath": "./params-templateer-static.cson",
              "lib": false,
              "mode": 5,
              "save_policy": 1
            },
            "data": "{\n  \"result\": \"head_body\",\n  \"templates\": [\n    \"body\",\n    \"head\",\n    \"head_body\"\n  ],\n  \"environment\": {\n    \"divname\": \"str\",\n    \"layout\": \"json\",\n    \"width\": \"int\",\n    \"plotly_data\": \"json\",\n    \"title\": \"text\",\n    \"height\": \"int\",\n    \"config\": \"json\"\n  }\n}"
          }
        }
      },
      "plotly_config": {
        "dtype": "cson",
        "resource": {
          "filepath": "plotdata/config.cson",
          "lib": false,
          "mode": 5,
          "save_policy": 1
        },
        "data": "{}\n"
      },
      "plotly_data": {
        "dtype": "cson",
        "resource": {
          "filepath": "plotdata/plotly_data.cson",
          "lib": false,
          "mode": 5,
          "save_policy": 1
        },
        "hash": "147294e84f7940d273c6a62c9b5d3de2"
      },
      "plotly_layout": {
        "dtype": "cson",
        "resource": {
          "filepath": "plotdata/layout.cson",
          "lib": false,
          "mode": 5,
          "save_policy": 1
        },
        "data": "{\"barmode\": \"stack\"\n\"yaxis\": {\n    \"type\": \"log\",\n    \"range\": [-1, 2]\n  }\n\"autosize\": true\nwidth:1000\nheight: 400\n}\n"
      },
      "temp_body": {
        "dtype": "text",
        "resource": {
          "filepath": null,
          "lib": null,
          "mode": null,
          "save_policy": 1
        }
      },
      "templateer_dynamic": {
        "type": "context",
        "like_worker": true,
        "like_cell": false,
        "pins": {
          "RESULT": [
            "ExportedOutputPin",
            "templateer_dynamic.rc.RESULT"
          ],
          "body": [
            "ExportedInputPin",
            "templateer_dynamic.rc.body"
          ],
          "divname": [
            "ExportedInputPin",
            "templateer_dynamic.rc.divname"
          ],
          "dynamic_html": [
            "ExportedInputPin",
            "templateer_dynamic.rc.dynamic_html"
          ],
          "head": [
            "ExportedInputPin",
            "templateer_dynamic.rc.head"
          ],
          "head_body": [
            "ExportedInputPin",
            "templateer_dynamic.rc.head_body"
          ],
          "height": [
            "ExportedInputPin",
            "templateer_dynamic.rc.height"
          ],
          "title": [
            "ExportedInputPin",
            "templateer_dynamic.rc.title"
          ],
          "width": [
            "ExportedInputPin",
            "templateer_dynamic.rc.width"
          ]
        },
        "auto": [
          "cell1",
          "cell2",
          "cell3",
          "cell4",
          "cell5"
        ],
        "children": {
          "cell1": {
            "dtype": [
              "text",
              "html"
            ],
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "hash": "5a6c58e4cd37dbf6ba12934cee660383",
            "owner": "templateer_dynamic.rc"
          },
          "cell2": {
            "dtype": "json",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "{\n  \"environment\": {\n    \"width\": \"int\",\n    \"divname\": \"text\",\n    \"title\": \"text\",\n    \"height\": \"int\",\n    \"dynamic_html\": [\n      \"text\",\n      \"html\"\n    ]\n  },\n  \"templates\": [\n    \"body\",\n    \"head\",\n    \"head_body\"\n  ],\n  \"result\": \"head_body\"\n}"
          },
          "cell3": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "resource": {
              "filepath": "/cell-templateer.py",
              "lib": true,
              "mode": 2,
              "save_policy": 1
            },
            "data": "import jinja2, jinja2.meta\nimport json\n\nenv = {}\ndepsgraph = {}\ntemplates = []\njenv = jinja2.Environment()\n\nclass Node:\n    _ignore_deps = [\"range\"]\n    def __init__(self, name):\n        self.name = name\n        self.template = None\n        self.template_code = None\n        self.up_to_date = False\n        self.template_deps = []\n        self.env_deps = []\n        self.dependees = []\n\n    def render(self, visited=None):\n        if self.up_to_date:\n            return env[self.name]\n\n        if self.template is None:\n            raise RuntimeError(\"Cannot render template '{0}'\" % self.name)\n        if visited is None:\n            visited = []\n        if self.name in visited:\n            cycle = visited[visited.index(self.name):] + [self.name]\n            raise RuntimeError(\"Cyclic template dependency: {0}\".format(cycle))\n        visited.append(self.name)\n\n        for dep in sorted(self.template_deps):\n            #print(\"DEP\", self.name, dep)\n            depsgraph[dep].render(visited)\n        result = self.template.render(env)\n        self.up_to_date = True\n        #print(\"RENDER\", self.name)\n        env[self.name] = result\n        return result\n\n    def set_dirty(self):\n        self.up_to_date = False\n        for dependee in self.dependees:\n            depsgraph[dependee].set_dirty()\n\n    def set_template(self, template_code):\n        if template_code == self.template_code:\n            return\n        self.template_code = template_code\n        self.template = None\n        self.set_dirty()\n        ast = jenv.parse(template_code)\n        deps = jinja2.meta.find_undeclared_variables(ast)\n        new_env_deps = []\n        new_template_deps = []\n        for d in sorted(deps):\n            if d in env:\n                new_env_deps.append(d)\n            elif d in templates:\n                new_template_deps.append(d)\n            elif d in self._ignore_deps:\n                continue\n            else:\n                raise RuntimeError(\"Unknown dependency: '{0}'\".format(d))\n        self.template = jinja2.Template(ast)\n        for dep in self.template_deps + self.env_deps:\n            depsgraph[dep].dependees.remove(self.name)\n        self.env_deps = new_env_deps\n        self.template_deps = new_template_deps\n        for dep in self.template_deps  + self.env_deps:\n            depsgraph[dep].dependees.append(self.name)\n\ndef make_template():\n    global result_template\n    import jinja2\n    tempdef = PINS.TEMPLATE_DEFINITION.get()\n    if PINS.TEMPLATE_DEFINITION.updated:\n        env.clear()\n        depsgraph.clear()\n        templates[:] = tempdef[\"templates\"]\n        result_template = tempdef.get(\"result\", None)\n        if len(templates) > 1:\n            assert result_template is not None\n        else:\n            result_template = templates[0]\n        assert result_template in templates, (result_template, templates)\n\n    tempdef = PINS.TEMPLATE_DEFINITION.get()\n    environment = tempdef[\"environment\"]\n\n    env_updates = list()\n    for k, v in environment.items():\n        inp = getattr(PINS, k)\n        if inp.updated or k not in env:\n            val = inp.get()\n            if isinstance(val, (bytes, str)):\n                sval = val\n            else:\n                sval = json.dumps(val, indent=2)\n            env[k] = sval\n            env_updates.append(k)\n\n    for k in env_updates:\n        if k not in depsgraph:\n            node = Node(k)\n            node.up_to_date = True\n            depsgraph[k] = node\n        for nodename in depsgraph[k].dependees:\n            depsgraph[nodename].set_dirty()\n\n    templ_updates = []\n    for t in templates:\n        template = getattr(PINS, t)\n        if template.updated or t not in depsgraph:\n            if t not in depsgraph:\n                node = Node(t)\n                depsgraph[t] = node\n            templ_updates.append(t)\n    for t in templ_updates:\n        template = getattr(PINS, t)\n        node = depsgraph[t]\n        node.set_template(template.get())\n\n    firstnode = depsgraph[result_template]\n    result = firstnode.render()\n\n    PINS.RESULT.set(result)\n"
          },
          "cell4": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "make_template()"
          },
          "cell5": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": ""
          },
          "rc": {
            "type": "reactor",
            "mode": "sync",
            "params": {
              "RESULT": {
                "dtype": [
                  "text",
                  "html"
                ],
                "pin": "output"
              },
              "TEMPLATE_DEFINITION": {
                "dtype": "json",
                "pin": "input"
              },
              "body": {
                "dtype": "text",
                "pin": "input"
              },
              "divname": {
                "dtype": "text",
                "pin": "input"
              },
              "dynamic_html": {
                "dtype": [
                  "text",
                  "html"
                ],
                "pin": "input"
              },
              "head": {
                "dtype": "text",
                "pin": "input"
              },
              "head_body": {
                "dtype": "text",
                "pin": "input"
              },
              "height": {
                "dtype": "int",
                "pin": "input"
              },
              "title": {
                "dtype": "text",
                "pin": "input"
              },
              "width": {
                "dtype": "int",
                "pin": "input"
              }
            }
          }
        }
      },
      "templateer_static": {
        "type": "context",
        "like_worker": true,
        "like_cell": false,
        "pins": {
          "RESULT": [
            "ExportedOutputPin",
            "templateer_static.rc.RESULT"
          ],
          "body": [
            "ExportedInputPin",
            "templateer_static.rc.body"
          ],
          "config": [
            "ExportedInputPin",
            "templateer_static.rc.config"
          ],
          "divname": [
            "ExportedInputPin",
            "templateer_static.rc.divname"
          ],
          "head": [
            "ExportedInputPin",
            "templateer_static.rc.head"
          ],
          "head_body": [
            "ExportedInputPin",
            "templateer_static.rc.head_body"
          ],
          "height": [
            "ExportedInputPin",
            "templateer_static.rc.height"
          ],
          "layout": [
            "ExportedInputPin",
            "templateer_static.rc.layout"
          ],
          "plotly_data": [
            "ExportedInputPin",
            "templateer_static.rc.plotly_data"
          ],
          "title": [
            "ExportedInputPin",
            "templateer_static.rc.title"
          ],
          "width": [
            "ExportedInputPin",
            "templateer_static.rc.width"
          ]
        },
        "auto": [
          "cell1",
          "cell2",
          "cell3",
          "cell4",
          "cell5"
        ],
        "children": {
          "cell1": {
            "dtype": [
              "text",
              "html"
            ],
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "hash": "c143621967917717158f2915c7a199cc",
            "owner": "templateer_static.rc"
          },
          "cell2": {
            "dtype": "json",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "{\n  \"environment\": {\n    \"divname\": \"str\",\n    \"layout\": \"json\",\n    \"width\": \"int\",\n    \"plotly_data\": \"json\",\n    \"title\": \"text\",\n    \"height\": \"int\",\n    \"config\": \"json\"\n  },\n  \"templates\": [\n    \"body\",\n    \"head\",\n    \"head_body\"\n  ],\n  \"result\": \"head_body\"\n}"
          },
          "cell3": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "resource": {
              "filepath": "/cell-templateer.py",
              "lib": true,
              "mode": 2,
              "save_policy": 1
            },
            "data": "import jinja2, jinja2.meta\nimport json\n\nenv = {}\ndepsgraph = {}\ntemplates = []\njenv = jinja2.Environment()\n\nclass Node:\n    _ignore_deps = [\"range\"]\n    def __init__(self, name):\n        self.name = name\n        self.template = None\n        self.template_code = None\n        self.up_to_date = False\n        self.template_deps = []\n        self.env_deps = []\n        self.dependees = []\n\n    def render(self, visited=None):\n        if self.up_to_date:\n            return env[self.name]\n\n        if self.template is None:\n            raise RuntimeError(\"Cannot render template '{0}'\" % self.name)\n        if visited is None:\n            visited = []\n        if self.name in visited:\n            cycle = visited[visited.index(self.name):] + [self.name]\n            raise RuntimeError(\"Cyclic template dependency: {0}\".format(cycle))\n        visited.append(self.name)\n\n        for dep in sorted(self.template_deps):\n            #print(\"DEP\", self.name, dep)\n            depsgraph[dep].render(visited)\n        result = self.template.render(env)\n        self.up_to_date = True\n        #print(\"RENDER\", self.name)\n        env[self.name] = result\n        return result\n\n    def set_dirty(self):\n        self.up_to_date = False\n        for dependee in self.dependees:\n            depsgraph[dependee].set_dirty()\n\n    def set_template(self, template_code):\n        if template_code == self.template_code:\n            return\n        self.template_code = template_code\n        self.template = None\n        self.set_dirty()\n        ast = jenv.parse(template_code)\n        deps = jinja2.meta.find_undeclared_variables(ast)\n        new_env_deps = []\n        new_template_deps = []\n        for d in sorted(deps):\n            if d in env:\n                new_env_deps.append(d)\n            elif d in templates:\n                new_template_deps.append(d)\n            elif d in self._ignore_deps:\n                continue\n            else:\n                raise RuntimeError(\"Unknown dependency: '{0}'\".format(d))\n        self.template = jinja2.Template(ast)\n        for dep in self.template_deps + self.env_deps:\n            depsgraph[dep].dependees.remove(self.name)\n        self.env_deps = new_env_deps\n        self.template_deps = new_template_deps\n        for dep in self.template_deps  + self.env_deps:\n            depsgraph[dep].dependees.append(self.name)\n\ndef make_template():\n    global result_template\n    import jinja2\n    tempdef = PINS.TEMPLATE_DEFINITION.get()\n    if PINS.TEMPLATE_DEFINITION.updated:\n        env.clear()\n        depsgraph.clear()\n        templates[:] = tempdef[\"templates\"]\n        result_template = tempdef.get(\"result\", None)\n        if len(templates) > 1:\n            assert result_template is not None\n        else:\n            result_template = templates[0]\n        assert result_template in templates, (result_template, templates)\n\n    tempdef = PINS.TEMPLATE_DEFINITION.get()\n    environment = tempdef[\"environment\"]\n\n    env_updates = list()\n    for k, v in environment.items():\n        inp = getattr(PINS, k)\n        if inp.updated or k not in env:\n            val = inp.get()\n            if isinstance(val, (bytes, str)):\n                sval = val\n            else:\n                sval = json.dumps(val, indent=2)\n            env[k] = sval\n            env_updates.append(k)\n\n    for k in env_updates:\n        if k not in depsgraph:\n            node = Node(k)\n            node.up_to_date = True\n            depsgraph[k] = node\n        for nodename in depsgraph[k].dependees:\n            depsgraph[nodename].set_dirty()\n\n    templ_updates = []\n    for t in templates:\n        template = getattr(PINS, t)\n        if template.updated or t not in depsgraph:\n            if t not in depsgraph:\n                node = Node(t)\n                depsgraph[t] = node\n            templ_updates.append(t)\n    for t in templ_updates:\n        template = getattr(PINS, t)\n        node = depsgraph[t]\n        node.set_template(template.get())\n\n    firstnode = depsgraph[result_template]\n    result = firstnode.render()\n\n    PINS.RESULT.set(result)\n"
          },
          "cell4": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "make_template()"
          },
          "cell5": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": ""
          },
          "rc": {
            "type": "reactor",
            "mode": "sync",
            "params": {
              "RESULT": {
                "dtype": [
                  "text",
                  "html"
                ],
                "pin": "output"
              },
              "TEMPLATE_DEFINITION": {
                "dtype": "json",
                "pin": "input"
              },
              "body": {
                "dtype": "text",
                "pin": "input"
              },
              "config": {
                "dtype": "json",
                "pin": "input"
              },
              "divname": {
                "dtype": "str",
                "pin": "input"
              },
              "head": {
                "dtype": "text",
                "pin": "input"
              },
              "head_body": {
                "dtype": "text",
                "pin": "input"
              },
              "height": {
                "dtype": "int",
                "pin": "input"
              },
              "layout": {
                "dtype": "json",
                "pin": "input"
              },
              "plotly_data": {
                "dtype": "json",
                "pin": "input"
              },
              "title": {
                "dtype": "text",
                "pin": "input"
              },
              "width": {
                "dtype": "int",
                "pin": "input"
              }
            }
          }
        }
      },
      "templates": {
        "type": "context",
        "like_worker": false,
        "like_cell": false,
        "pins": {},
        "auto": [],
        "children": {
          "body": {
            "dtype": "text",
            "resource": {
              "filepath": "./template-body.jinja",
              "lib": false,
              "mode": 5,
              "save_policy": 1
            },
            "data": "<div id=\"{{divname}}\" style=\"width: {{width}}px; height: {{height}}px;\"><!-- Plotly chart will be drawn inside this DIV --></div>\n<script id=\"javascript\">\n  var data = {{plotly_data}};\n  var layout = {{layout}};\n  var config = {{config}};\n  Plotly.newPlot('{{divname}}', data, layout, config);\n</script>\n"
          },
          "body_dynamic": {
            "dtype": "text",
            "resource": {
              "filepath": "./template-body-dynamic.jinja",
              "lib": false,
              "mode": 5,
              "save_policy": 1
            },
            "data": "<div id=\"echo\"></div>\n<div id=\"{{divname}}\" style=\"width: {{width}}px; height: {{height}}px;\"><!-- Plotly chart will be drawn inside this DIV --></div>\n{{dynamic_html}}\n"
          },
          "head": {
            "dtype": "text",
            "resource": {
              "filepath": "./template-head.jinja",
              "lib": false,
              "mode": 5,
              "save_policy": 1
            },
            "data": "<script type=\"text/javascript\" src=\"plotly-latest.js\"></script>\n<!-- <script type=\"text/javascript\" src=\"plotly-latest.js\"></script> -->\n<meta charset=\"utf-8\">\n<title>{{title}}</title>\n"
          },
          "html_head_body": {
            "dtype": [
              "text",
              "html"
            ],
            "resource": {
              "filepath": "./template-html-head-body.jinja",
              "lib": false,
              "mode": 5,
              "save_policy": 1
            },
            "data": "<!DOCTYPE html>\n<html>\n<head>\n{{head}}\n</head>\n<body>\n{{body}}\n</body>\n</html>\n"
          }
        }
      },
      "title": {
        "dtype": "text",
        "resource": {
          "filepath": "plotdata/title.txt",
          "lib": false,
          "mode": 5,
          "save_policy": 1
        },
        "data": ""
      }
    },
    "macro_objects": [
      {
        "args": [
          null
        ],
        "kwargs": {},
        "cell_args": {
          "0": "params.templateer_static"
        },
        "macro_module_name": "seamless.lib.templateer",
        "macro_func_name": "templateer",
        "macro_order": 0,
        "target": "templateer_static"
      },
      {
        "args": [
          null
        ],
        "kwargs": {},
        "cell_args": {
          "0": "params.templateer_dynamic"
        },
        "macro_module_name": "seamless.lib.templateer",
        "macro_func_name": "templateer",
        "macro_order": 1,
        "target": "templateer_dynamic"
      },
      {
        "args": [
          null
        ],
        "kwargs": {},
        "cell_args": {
          "0": "params.dynamic_html"
        },
        "macro_module_name": "seamless.lib.dynamic_html",
        "macro_func_name": "dynamic_html",
        "macro_order": 0,
        "target": "dynamic_html_maker"
      }
    ],
    "macro_listeners": [
      {
        "cell": "params.templateer_static",
        "macro_target": "templateer_static",
        "macro_arg": 0
      },
      {
        "cell": "params.templateer_dynamic",
        "macro_target": "templateer_dynamic",
        "macro_arg": 0
      },
      {
        "cell": "params.dynamic_html",
        "macro_target": "dynamic_html_maker",
        "macro_arg": 0
      }
    ],
    "registrar_items": [],
    "registrar_listeners": [],
    "registrar_cells": [],
    "pin_cell_connections": [
      [
        "dynamic_html_maker.rc.dynamic_html",
        "dynamic_html_maker.cell1"
      ],
      [
        "integrate_data.plotly_data",
        "plotly_data"
      ],
      [
        "load_data_columns.data",
        "data"
      ],
      [
        "templateer_dynamic.rc.RESULT",
        "html_dynamic"
      ],
      [
        "templateer_dynamic.rc.RESULT",
        "templateer_dynamic.cell1"
      ],
      [
        "templateer_static.rc.RESULT",
        "html"
      ],
      [
        "templateer_static.rc.RESULT",
        "templateer_static.cell1"
      ]
    ],
    "cell_pin_connections": [
      [
        "attrib",
        "dynamic_html_maker.rc.attrib"
      ],
      [
        "attrib",
        "integrate_data.attrib"
      ],
      [
        "attrib",
        "links.attrib.rc.value"
      ],
      [
        "browser.cell1",
        "browser.rc.title"
      ],
      [
        "browser.cell2",
        "browser.rc.code_start"
      ],
      [
        "browser.cell3",
        "browser.rc.code_stop"
      ],
      [
        "browser.cell4",
        "browser.rc.code_update"
      ],
      [
        "browser_dynamic.cell1",
        "browser_dynamic.rc.title"
      ],
      [
        "browser_dynamic.cell2",
        "browser_dynamic.rc.code_start"
      ],
      [
        "browser_dynamic.cell3",
        "browser_dynamic.rc.code_stop"
      ],
      [
        "browser_dynamic.cell4",
        "browser_dynamic.rc.code_update"
      ],
      [
        "code.cell10",
        "links.csv.rc.latency"
      ],
      [
        "code.cell11",
        "load_data_columns.point_shift"
      ],
      [
        "code.cell12",
        "links.html_dynamic.rc.filepath"
      ],
      [
        "code.cell13",
        "links.html_dynamic.rc.latency"
      ],
      [
        "code.cell14",
        "templateer_dynamic.rc.width"
      ],
      [
        "code.cell15",
        "templateer_dynamic.rc.height"
      ],
      [
        "code.cell16",
        "links.template_body_dynamic.rc.filepath"
      ],
      [
        "code.cell17",
        "links.template_body_dynamic.rc.latency"
      ],
      [
        "code.cell18",
        "dynamic_html_maker.rc.make_plot"
      ],
      [
        "code.cell1",
        "links.code_integrate_data.rc.filepath"
      ],
      [
        "code.cell2",
        "links.code_integrate_data.rc.latency"
      ],
      [
        "code.cell3",
        "links.data.rc.filepath"
      ],
      [
        "code.cell4",
        "links.data.rc.latency"
      ],
      [
        "code.cell5",
        "links.attrib.rc.filepath"
      ],
      [
        "code.cell6",
        "links.attrib.rc.latency"
      ],
      [
        "code.cell7",
        "links.code_load_data_columns.rc.filepath"
      ],
      [
        "code.cell8",
        "links.code_load_data_columns.rc.latency"
      ],
      [
        "code.cell9",
        "links.csv.rc.filepath"
      ],
      [
        "code.integrate_data",
        "integrate_data.code"
      ],
      [
        "code.integrate_data",
        "links.code_integrate_data.rc.value"
      ],
      [
        "code.load_data_columns",
        "links.code_load_data_columns.rc.value"
      ],
      [
        "code.load_data_columns",
        "load_data_columns.code"
      ],
      [
        "csv",
        "links.csv.rc.value"
      ],
      [
        "csv",
        "load_data_columns.csv"
      ],
      [
        "data",
        "integrate_data.data"
      ],
      [
        "data",
        "links.data.rc.value"
      ],
      [
        "divname",
        "dynamic_html_maker.rc.divname"
      ],
      [
        "divname",
        "templateer_dynamic.rc.divname"
      ],
      [
        "divname",
        "templateer_static.rc.divname"
      ],
      [
        "dynamic_html_maker.cell1",
        "templateer_dynamic.rc.dynamic_html"
      ],
      [
        "dynamic_html_maker.cell2",
        "dynamic_html_maker.rc.code_start"
      ],
      [
        "dynamic_html_maker.cell3",
        "dynamic_html_maker.rc.code_update"
      ],
      [
        "dynamic_html_maker.cell4",
        "dynamic_html_maker.rc.code_stop"
      ],
      [
        "dynamic_html_maker.cell5",
        "dynamic_html_maker.rc.DYNAMIC_HTML_PARAMS"
      ],
      [
        "dynamic_html_maker.cell6",
        "dynamic_html_maker.rc.DYNAMIC_HTML_TEMPLATE"
      ],
      [
        "edit.cell1",
        "links.html.rc.filepath"
      ],
      [
        "edit.cell2",
        "links.html.rc.latency"
      ],
      [
        "edit.cell3",
        "links.template_html_head_body.rc.filepath"
      ],
      [
        "edit.cell4",
        "links.template_html_head_body.rc.latency"
      ],
      [
        "html_dynamic",
        "browser_dynamic.rc.value"
      ],
      [
        "html_dynamic",
        "links.html_dynamic.rc.value"
      ],
      [
        "html",
        "browser.rc.value"
      ],
      [
        "html",
        "links.html.rc.value"
      ],
      [
        "links.attrib.cell1",
        "links.attrib.rc.code_start"
      ],
      [
        "links.attrib.cell2",
        "links.attrib.rc.code_update"
      ],
      [
        "links.attrib.cell3",
        "links.attrib.rc.code_stop"
      ],
      [
        "links.code_integrate_data.cell1",
        "links.code_integrate_data.rc.code_start"
      ],
      [
        "links.code_integrate_data.cell2",
        "links.code_integrate_data.rc.code_update"
      ],
      [
        "links.code_integrate_data.cell3",
        "links.code_integrate_data.rc.code_stop"
      ],
      [
        "links.code_load_data_columns.cell1",
        "links.code_load_data_columns.rc.code_start"
      ],
      [
        "links.code_load_data_columns.cell2",
        "links.code_load_data_columns.rc.code_update"
      ],
      [
        "links.code_load_data_columns.cell3",
        "links.code_load_data_columns.rc.code_stop"
      ],
      [
        "links.csv.cell1",
        "links.csv.rc.code_start"
      ],
      [
        "links.csv.cell2",
        "links.csv.rc.code_update"
      ],
      [
        "links.csv.cell3",
        "links.csv.rc.code_stop"
      ],
      [
        "links.data.cell1",
        "links.data.rc.code_start"
      ],
      [
        "links.data.cell2",
        "links.data.rc.code_update"
      ],
      [
        "links.data.cell3",
        "links.data.rc.code_stop"
      ],
      [
        "links.html.cell1",
        "links.html.rc.code_start"
      ],
      [
        "links.html.cell2",
        "links.html.rc.code_update"
      ],
      [
        "links.html.cell3",
        "links.html.rc.code_stop"
      ],
      [
        "links.html_dynamic.cell1",
        "links.html_dynamic.rc.code_start"
      ],
      [
        "links.html_dynamic.cell2",
        "links.html_dynamic.rc.code_update"
      ],
      [
        "links.html_dynamic.cell3",
        "links.html_dynamic.rc.code_stop"
      ],
      [
        "links.params_templateer_static.cell1",
        "links.params_templateer_static.rc.code_start"
      ],
      [
        "links.params_templateer_static.cell2",
        "links.params_templateer_static.rc.code_update"
      ],
      [
        "links.params_templateer_static.cell3",
        "links.params_templateer_static.rc.code_stop"
      ],
      [
        "links.plotly_config.cell1",
        "links.plotly_config.rc.code_start"
      ],
      [
        "links.plotly_config.cell2",
        "links.plotly_config.rc.code_update"
      ],
      [
        "links.plotly_config.cell3",
        "links.plotly_config.rc.code_stop"
      ],
      [
        "links.plotly_data.cell1",
        "links.plotly_data.rc.code_start"
      ],
      [
        "links.plotly_data.cell2",
        "links.plotly_data.rc.code_update"
      ],
      [
        "links.plotly_data.cell3",
        "links.plotly_data.rc.code_stop"
      ],
      [
        "links.plotly_layout.cell1",
        "links.plotly_layout.rc.code_start"
      ],
      [
        "links.plotly_layout.cell2",
        "links.plotly_layout.rc.code_update"
      ],
      [
        "links.plotly_layout.cell3",
        "links.plotly_layout.rc.code_stop"
      ],
      [
        "links.template_body.cell1",
        "links.template_body.rc.code_start"
      ],
      [
        "links.template_body.cell2",
        "links.template_body.rc.code_update"
      ],
      [
        "links.template_body.cell3",
        "links.template_body.rc.code_stop"
      ],
      [
        "links.template_body_dynamic.cell1",
        "links.template_body_dynamic.rc.code_start"
      ],
      [
        "links.template_body_dynamic.cell2",
        "links.template_body_dynamic.rc.code_update"
      ],
      [
        "links.template_body_dynamic.cell3",
        "links.template_body_dynamic.rc.code_stop"
      ],
      [
        "links.template_head.cell1",
        "links.template_head.rc.code_start"
      ],
      [
        "links.template_head.cell2",
        "links.template_head.rc.code_update"
      ],
      [
        "links.template_head.cell3",
        "links.template_head.rc.code_stop"
      ],
      [
        "links.template_html_head_body.cell1",
        "links.template_html_head_body.rc.code_start"
      ],
      [
        "links.template_html_head_body.cell2",
        "links.template_html_head_body.rc.code_update"
      ],
      [
        "links.template_html_head_body.cell3",
        "links.template_html_head_body.rc.code_stop"
      ],
      [
        "links.title.cell1",
        "links.title.rc.code_start"
      ],
      [
        "links.title.cell2",
        "links.title.rc.code_update"
      ],
      [
        "links.title.cell3",
        "links.title.rc.code_stop"
      ],
      [
        "params.cell10",
        "templateer_static.rc.height"
      ],
      [
        "params.cell11",
        "links.plotly_data.rc.filepath"
      ],
      [
        "params.cell12",
        "links.plotly_data.rc.latency"
      ],
      [
        "params.cell13",
        "links.plotly_layout.rc.filepath"
      ],
      [
        "params.cell14",
        "links.plotly_layout.rc.latency"
      ],
      [
        "params.cell15",
        "links.plotly_config.rc.filepath"
      ],
      [
        "params.cell16",
        "links.plotly_config.rc.latency"
      ],
      [
        "params.cell1",
        "links.params_templateer_static.rc.filepath"
      ],
      [
        "params.cell2",
        "links.params_templateer_static.rc.latency"
      ],
      [
        "params.cell3",
        "links.template_head.rc.filepath"
      ],
      [
        "params.cell4",
        "links.template_head.rc.latency"
      ],
      [
        "params.cell5",
        "links.title.rc.filepath"
      ],
      [
        "params.cell6",
        "links.title.rc.latency"
      ],
      [
        "params.cell7",
        "links.template_body.rc.filepath"
      ],
      [
        "params.cell8",
        "links.template_body.rc.latency"
      ],
      [
        "params.cell9",
        "templateer_static.rc.width"
      ],
      [
        "params.templateer_static",
        "links.params_templateer_static.rc.value"
      ],
      [
        "plotly_config",
        "dynamic_html_maker.rc.config"
      ],
      [
        "plotly_config",
        "links.plotly_config.rc.value"
      ],
      [
        "plotly_config",
        "templateer_static.rc.config"
      ],
      [
        "plotly_data",
        "dynamic_html_maker.rc.plotly_data"
      ],
      [
        "plotly_data",
        "links.plotly_data.rc.value"
      ],
      [
        "plotly_data",
        "templateer_static.rc.plotly_data"
      ],
      [
        "plotly_layout",
        "dynamic_html_maker.rc.layout"
      ],
      [
        "plotly_layout",
        "links.plotly_layout.rc.value"
      ],
      [
        "plotly_layout",
        "templateer_static.rc.layout"
      ],
      [
        "templateer_dynamic.cell2",
        "templateer_dynamic.rc.TEMPLATE_DEFINITION"
      ],
      [
        "templateer_dynamic.cell3",
        "templateer_dynamic.rc.code_start"
      ],
      [
        "templateer_dynamic.cell4",
        "templateer_dynamic.rc.code_update"
      ],
      [
        "templateer_dynamic.cell5",
        "templateer_dynamic.rc.code_stop"
      ],
      [
        "templateer_static.cell2",
        "templateer_static.rc.TEMPLATE_DEFINITION"
      ],
      [
        "templateer_static.cell3",
        "templateer_static.rc.code_start"
      ],
      [
        "templateer_static.cell4",
        "templateer_static.rc.code_update"
      ],
      [
        "templateer_static.cell5",
        "templateer_static.rc.code_stop"
      ],
      [
        "templates.body_dynamic",
        "links.template_body_dynamic.rc.value"
      ],
      [
        "templates.body_dynamic",
        "templateer_dynamic.rc.body"
      ],
      [
        "templates.body",
        "links.template_body.rc.value"
      ],
      [
        "templates.body",
        "templateer_static.rc.body"
      ],
      [
        "templates.head",
        "links.template_head.rc.value"
      ],
      [
        "templates.head",
        "templateer_dynamic.rc.head"
      ],
      [
        "templates.head",
        "templateer_static.rc.head"
      ],
      [
        "templates.html_head_body",
        "links.template_html_head_body.rc.value"
      ],
      [
        "templates.html_head_body",
        "templateer_dynamic.rc.head_body"
      ],
      [
        "templates.html_head_body",
        "templateer_static.rc.head_body"
      ],
      [
        "title",
        "links.title.rc.value"
      ],
      [
        "title",
        "templateer_dynamic.rc.title"
      ],
      [
        "title",
        "templateer_static.rc.title"
      ]
    ],
    "cell_cell_connections": []
  }
}