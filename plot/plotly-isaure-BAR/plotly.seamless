{
  "lib": {
    "/cell-filelink-start.py": {
      "data": "if __name__ == \"__main__\":\n    #test with ipython -i\n    import sys, os\n\n    class dummy:\n        pass\n\n    class EditPin:\n        def __init__(self, value):\n            self.value = value\n            self.defined = True\n        def set(self, value):\n            print(\"SET\", value)\n            self.value = value\n        def get(self):\n            return self.value\n\n    class Getter:\n        def __init__(self, arg):\n            self.arg = arg\n        def get(self):\n            return self.arg\n    PINS = dummy()\n    PINS.value = EditPin(\"test\")\n    directory = sys.argv[1]\n    filename = sys.argv[2]\n    PINS.filepath = Getter(os.path.join(directory, filename))\n    PINS.latency = Getter(float(sys.argv[3]))\n    def serializer(v):\n        return str(v.get())\n    print(\"Edit in \" + filepath.get())\nelse:\n    from seamless.dtypes import serialize\n    def serializer(v):\n        return serialize(v._dtype, v.get())\n\n\nimport os, time, functools, traceback\nfrom threading import Thread, RLock\nlast_value = None\nlast_serialized_value = None\nlast_exc = None\nlast_mtime = None\n\ndef write_file(fpath):\n    global last_mtime, last_value, last_serialized_value\n    if not PINS.value.defined:\n        last_mtime = -1 #will trigger a file read\n        return\n    if last_value == PINS.value.get():\n        return\n    val = serializer(PINS.value)\n    if last_serialized_value == val:\n        return\n    with lock:\n        if last_serialized_value != val:\n            #print(\"WRITE\", val)\n            with open(fpath, \"w\", encoding=\"utf-8\") as f:\n                f.write(val)\n                last_value = PINS.value.get()\n                last_serialized_value = val\n            last_time = time.time()\n            try:\n                stat = os.stat(fpath)\n                last_mtime = stat.st_mtime\n            except:\n                pass\n\ndef poll():\n    global last_time, last_mtime, last_value, last_serialized_value, last_exc\n    fpath = PINS.filepath.get()\n    while 1:\n        time.sleep(PINS.latency.get())\n        curr_time = time.time()\n        last_time = curr_time\n        if not os.path.exists(fpath):\n            try:\n                write_file(fpath)\n            except:\n                exc = traceback.format_exc()\n                if exc != last_exc:\n                    print(exc)\n                    last_exc = exc\n        else:\n            with lock:\n                stat = os.stat(fpath)\n                try:\n                    if last_mtime is None or stat.st_mtime > last_mtime:\n                        data = None\n                        with open(fpath, encoding=\"utf-8\") as f:\n                            data = f.read()\n                        if data is not None:\n                            if last_serialized_value != data:\n                                #print(\"LOAD\")\n                                PINS.value.set(data)\n                                last_value = None\n                                last_serialized_value = data\n                        last_mtime = stat.st_mtime\n                except:\n                    exc = traceback.format_exc()\n                    if exc != last_exc:\n                        print(exc)\n                        last_exc = exc\n\nt = Thread(target=poll)\nt.setDaemon(True)\nlock = RLock()\nwrite_file(PINS.filepath.get())\nt.start()\n",
      "links": [
        "links.html.cell1",
        "links.template_html_head_body.cell1",
        "links.params_templateer_static.cell1",
        "links.template_head.cell1",
        "links.title.cell1",
        "links.template_body.cell1",
        "links.plotly_data.cell1",
        "links.plotly_layout.cell1",
        "links.plotly_config.cell1",
        "links.code_integrate_data.cell1",
        "links.data.cell1",
        "links.attrib.cell1",
        "links.code_load_data_columns.cell1",
        "links.csv.cell1",
        "links.data_parser_code.cell1",
        "links.code_generate_attrib.cell1",
        "links.code_generate_layout.cell1"
      ]
    },
    "/cell-templateer.py": {
      "data": "import jinja2, jinja2.meta\nimport json\n\nenv = {}\ndepsgraph = {}\ntemplates = []\njenv = jinja2.Environment()\n\nclass Node:\n    _ignore_deps = [\"range\"]\n    def __init__(self, name):\n        self.name = name\n        self.template = None\n        self.template_code = None\n        self.up_to_date = False\n        self.template_deps = []\n        self.env_deps = []\n        self.dependees = []\n\n    def render(self, visited=None):\n        if self.up_to_date:\n            return env[self.name]\n\n        if self.template is None:\n            raise RuntimeError(\"Cannot render template '{0}'\" % self.name)\n        if visited is None:\n            visited = []\n        if self.name in visited:\n            cycle = visited[visited.index(self.name):] + [self.name]\n            raise RuntimeError(\"Cyclic template dependency: {0}\".format(cycle))\n        visited.append(self.name)\n\n        for dep in sorted(self.template_deps):\n            #print(\"DEP\", self.name, dep)\n            depsgraph[dep].render(visited)\n        result = self.template.render(env)\n        self.up_to_date = True\n        #print(\"RENDER\", self.name)\n        env[self.name] = result\n        return result\n\n    def set_dirty(self):\n        self.up_to_date = False\n        for dependee in self.dependees:\n            depsgraph[dependee].set_dirty()\n\n    def set_template(self, template_code):\n        if template_code == self.template_code:\n            return\n        self.template_code = template_code\n        self.template = None\n        self.set_dirty()\n        ast = jenv.parse(template_code)\n        deps = jinja2.meta.find_undeclared_variables(ast)\n        new_env_deps = []\n        new_template_deps = []\n        for d in sorted(deps):\n            if d in env:\n                new_env_deps.append(d)\n            elif d in templates:\n                new_template_deps.append(d)\n            elif d in self._ignore_deps:\n                continue\n            else:\n                raise RuntimeError(\"Unknown dependency: '{0}'\".format(d))\n        self.template = jinja2.Template(ast)\n        for dep in self.template_deps + self.env_deps:\n            depsgraph[dep].dependees.remove(self.name)\n        self.env_deps = new_env_deps\n        self.template_deps = new_template_deps\n        for dep in self.template_deps  + self.env_deps:\n            depsgraph[dep].dependees.append(self.name)\n\ndef make_template():\n    global result_template\n    import jinja2\n    tempdef = PINS.TEMPLATE_DEFINITION.get()\n    if PINS.TEMPLATE_DEFINITION.updated:\n        env.clear()\n        depsgraph.clear()\n        templates[:] = tempdef[\"templates\"]\n        result_template = tempdef.get(\"result\", None)\n        if len(templates) > 1:\n            assert result_template is not None\n        else:\n            result_template = templates[0]\n        assert result_template in templates, (result_template, templates)\n\n    tempdef = PINS.TEMPLATE_DEFINITION.get()\n    environment = tempdef[\"environment\"]\n\n    env_updates = list()\n    for k, v in environment.items():\n        inp = getattr(PINS, k)\n        if inp.updated or k not in env:\n            val = inp.get()\n            if isinstance(val, (bytes, str)):\n                sval = val\n            else:\n                sval = json.dumps(val, indent=2)\n            env[k] = sval\n            env_updates.append(k)\n\n    for k in env_updates:\n        if k not in depsgraph:\n            node = Node(k)\n            node.up_to_date = True\n            depsgraph[k] = node\n        for nodename in depsgraph[k].dependees:\n            depsgraph[nodename].set_dirty()\n\n    templ_updates = []\n    for t in templates:\n        template = getattr(PINS, t)\n        if template.updated or t not in depsgraph:\n            if t not in depsgraph:\n                node = Node(t)\n                depsgraph[t] = node\n            templ_updates.append(t)\n    for t in templ_updates:\n        template = getattr(PINS, t)\n        node = depsgraph[t]\n        node.set_template(template.get())\n\n    firstnode = depsgraph[result_template]\n    result = firstnode.render()\n\n    PINS.RESULT.set(result)\n",
      "links": [
        "templateer_static.cell3"
      ]
    },
    "/gui/cell-basic_editor_UPDATE.py": {
      "data": "if PINS.value.updated:\n    b.setValue(PINS.value.get())\nif PINS.title.updated:\n    w.setWindowTitle(PINS.title.get())\n",
      "links": []
    },
    "/gui/cell-basic_editor_float.py": {
      "data": "from seamless.qt.QtWidgets import QDoubleSpinBox, QWidget, QVBoxLayout\nfrom seamless.qt.QtCore import Qt\n\nw = QWidget()\n#w.setWindowFlags(Qt.WindowStaysOnTopHint)\nw.setAttribute(Qt.WA_ShowWithoutActivating)\nvbox = QVBoxLayout()\nvbox.addStretch(1)\nw.setLayout(vbox)\nw.resize(300,100)\nw.setWindowTitle(PINS.title.get())\nw.show()\nb = QDoubleSpinBox()\nb.setSingleStep(0.1)\nb.setMaximum(1000000)\nif PINS.value.defined:\n    b.setValue(PINS.value.get())\nvbox.addWidget(b)\nb.valueChanged.connect(PINS.value.set)\n",
      "links": []
    },
    "/gui/cell-basic_editor_int.py": {
      "data": "from seamless.qt.QtWidgets import QSpinBox, QWidget, QVBoxLayout\nfrom seamless.qt.QtCore import Qt\n\nw = QWidget()\n#w.setWindowFlags(Qt.WindowStaysOnTopHint)\nw.setAttribute(Qt.WA_ShowWithoutActivating)\nvbox = QVBoxLayout()\nvbox.addStretch(1)\nw.setLayout(vbox)\nw.resize(300,100)\nw.setWindowTitle(PINS.title.get())\nw.show()\nb = QSpinBox()\nb.setMaximum(1000000)\nif PINS.value.defined:\n    b.setValue(PINS.value.get())\nvbox.addWidget(b)\nb.valueChanged.connect(PINS.value.set)\n",
      "links": []
    },
    "/gui/cell-basic_editor_json.py": {
      "data": "from seamless.qt.QtWidgets import QTextEdit, QWidget, QVBoxLayout\nfrom seamless.qt.QtCore import Qt\nfrom PyQt5.QtGui import QColor\nimport json\n\nw = QWidget()\n#w.setWindowFlags(Qt.WindowStaysOnTopHint)\nw.setAttribute(Qt.WA_ShowWithoutActivating)\nvbox = QVBoxLayout()\n#vbox.addStretch(1)\nw.resize(600,600)\nw.setLayout(vbox)\nw.setWindowTitle(PINS.title.get())\n\nclass MyTextEdit(QTextEdit):\n    def focusOutEvent(self, event):\n        PINS.value.set(self.toPlainText())\n        QTextEdit.focusOutEvent(self, event)\n\nw.show()\nb = MyTextEdit()\nb.setFontPointSize(15)\nif PINS.value.defined:\n    b.setText(json.dumps(PINS.value.get(), indent=2))\n#b.setFontItalic(True)\n#b.setTextColor(QColor(255,0,0))\nvbox.addWidget(b)\n",
      "links": []
    },
    "/gui/cell-basic_editor_json_UPDATE.py": {
      "data": "if PINS.value.updated:\n    b.setText(json.dumps(PINS.value.get(), indent=2))\nif PINS.title.updated:\n    w.setWindowTitle(PINS.title.get())\n",
      "links": []
    },
    "/gui/cell-basic_editor_text.py": {
      "data": "from seamless.qt.QtWidgets import QTextEdit, QWidget, QVBoxLayout\nfrom seamless.qt.QtCore import Qt\nfrom PyQt5.QtGui import QColor\n\nw = QWidget()\n#w.setWindowFlags(Qt.WindowStaysOnTopHint)\nw.setAttribute(Qt.WA_ShowWithoutActivating)\nvbox = QVBoxLayout()\n#vbox.addStretch(1)\nw.resize(600,600)\nw.setLayout(vbox)\nw.setWindowTitle(PINS.title.get())\n\nclass MyTextEdit(QTextEdit):\n    def focusOutEvent(self, event):\n        PINS.value.set(self.toPlainText())\n        QTextEdit.focusOutEvent(self, event)\n\nw.show()\nb = MyTextEdit()\nb.setFontPointSize(15)\nif PINS.value.defined:\n    b.setText(PINS.value.get())\n#b.setFontItalic(True)\n#b.setTextColor(QColor(255,0,0))\nvbox.addWidget(b)\n",
      "links": []
    },
    "/gui/cell-basic_editor_text_UPDATE.py": {
      "data": "if PINS.value.updated:\n    b.setText(PINS.value.get())\nif PINS.title.updated:\n    w.setWindowTitle(PINS.title.get())\n",
      "links": []
    },
    "/gui/cell-browser.py": {
      "data": "import os\nfrom seamless.qt.QtWebEngineWidgets import QWebEngineView\nfrom seamless.qt.Qt import QUrl\nfrom seamless.qt import QtWidgets, QtGui\n\nwidget = QWebEngineView()\nfake_url = QUrl.fromLocalFile(os.path.abspath(\"seamless.html\"))\nwidget.setWindowTitle(PINS.title.get())\nreloadAction = QtWidgets.QAction(QtGui.QIcon('exit.png'), '&Reload', widget)\nreloadAction.setShortcut('F5')\nreloadAction.setStatusTip('Reload')\nreloadAction.triggered.connect(widget.reload)\nwidget.addAction(reloadAction)\nwidget.setHtml(PINS.value.get())\nwidget.show()\n",
      "links": [
        "browser.cell2"
      ]
    },
    "/gui/cell-browser_UPDATE.py": {
      "data": "if PINS.value.defined:\n    widget.setHtml(PINS.value.get(), fake_url)\nif PINS.title.updated:\n    widget.setWindowTitle(PINS.title.get())\n",
      "links": [
        "browser.cell4"
      ]
    }
  },
  "macro": [
    {
      "with_context": false,
      "dtype": [
        "text",
        "code",
        "python"
      ],
      "type_args": [
        "json",
        "seamless",
        "editor_params"
      ],
      "module_name": "seamless.core.editor",
      "func_name": "editor",
      "code": "@macro(type=(\"json\", \"seamless\", \"editor_params\"),with_context=False)\ndef editor(kwargs):\n    from seamless.core.editor import Editor #code must be standalone\n    #TODO: remapping, e.g. output_finish, destroy, ...\n    return Editor(kwargs)\n"
    },
    {
      "with_context": false,
      "dtype": [
        "text",
        "code",
        "python"
      ],
      "type_args": [
        "json",
        "seamless",
        "transformer_params"
      ],
      "module_name": "seamless.core.transformer",
      "func_name": "transformer",
      "code": "@macro(type=(\"json\", \"seamless\", \"transformer_params\"), with_context=False)\ndef transformer(kwargs):\n    from seamless.core.transformer import Transformer #code must be standalone\n    #TODO: remapping, e.g. output_finish, destroy, ...\n    return Transformer(kwargs)\n"
    },
    {
      "with_context": true,
      "dtype": [
        "text",
        "code",
        "python"
      ],
      "type_args": "str",
      "module_name": "seamless.lib.filelink",
      "func_name": "filelink",
      "code": "@macro(\"str\")\ndef filelink(ctx, cell_type):\n    cell_filelink_start = \"cell-filelink-start.py\" #repeat for inline\n    from seamless import editor\n    pinparams = {\n       \"value\": {\n         \"pin\": \"edit\",\n         \"dtype\": cell_type,\n         \"must_be_defined\": False\n       },\n       \"filepath\" : {\n         \"pin\": \"input\",\n         \"dtype\": \"str\"\n       },\n       \"latency\" : {\n         \"pin\": \"input\",\n         \"dtype\": \"float\"\n       },\n    }\n    ed = ctx.ed = editor(pinparams)\n    ed.code_start.cell().fromfile(cell_filelink_start)\n    ed.code_update.cell().set(\"write_file(PINS.filepath.get())\")\n    ed.code_stop.cell().set('t.join(0)')\n    ctx.export(ed)\n"
    },
    {
      "with_context": true,
      "dtype": [
        "text",
        "code",
        "python"
      ],
      "type_args": {
        "editor_type": "str",
        "title": {
          "default": "Basic editor",
          "type": "str"
        }
      },
      "module_name": "seamless.lib.gui.basic_editor",
      "func_name": "basic_editor",
      "code": "@macro(OrderedDict((\n    (\"editor_type\",\"str\"),\n    (\"title\",{\"type\": \"str\", \"default\": \"Basic editor\"})\n)))\ndef basic_editor(ctx, editor_type, title):\n    from seamless import editor\n\n    _editors = {\n      \"int\": {\n        \"code\": \"cell-basic_editor_int.py\",\n        \"update\": \"cell-basic_editor_UPDATE.py\",\n      },\n      \"float\": {\n        \"code\": \"cell-basic_editor_float.py\",\n        \"update\": \"cell-basic_editor_UPDATE.py\",\n      },\n      \"text\": {\n        \"code\": \"cell-basic_editor_text.py\",\n        \"update\": \"cell-basic_editor_text_UPDATE.py\",\n      },\n      \"json\": {\n        \"code\": \"cell-basic_editor_json.py\",\n        \"update\": \"cell-basic_editor_json_UPDATE.py\",\n      },\n    }\n\n    def _match_type(type, typelist):\n        typelist = list(typelist)\n        type2 = type\n        if isinstance(type, str):\n            type2 = (type,)\n        typelist2 = []\n        for t in typelist:\n            if isinstance(t, str):\n                typelist2.append((t,))\n            else:\n                typelist2.append(t)\n        matches = []\n        for n in range(len(typelist)):\n            ltype = typelist2[n]\n            k = min(len(type2), len(ltype))\n            if type2[:k] == ltype[:k]:\n                matches.append((n, k))\n        if not len(matches):\n            raise TypeError(\"Cannot find editor for cell type '{0}'\".format(type))\n        matches.sort(key=lambda v: -v[1])\n        bestmatch = matches[0][0]\n        return typelist[bestmatch]\n\n    editor_type = _match_type(editor_type, _editors.keys())\n    pinparams = {\n      \"value\": {\n        \"pin\": \"edit\",\n        \"dtype\": editor_type,\n        \"must_be_defined\": False\n      },\n      \"title\": {\n        \"pin\": \"input\",\n        \"dtype\": \"str\",\n      },\n    }\n    ed = ctx.ed = editor(pinparams)\n    ed.title.cell().set(title)\n    ed.code_start.cell().fromfile(_editors[editor_type][\"code\"])\n    ed.code_stop.cell().set('w.destroy()')\n    upfile = _editors[editor_type][\"update\"]\n    c_up = ed.code_update.cell(True)\n    if upfile is not None:\n        c_up.fromfile(upfile)\n    else:\n        c_up.set(\"\")\n    ctx.export(ed, forced=[\"title\"])\n"
    },
    {
      "with_context": true,
      "dtype": [
        "text",
        "code",
        "python"
      ],
      "type_args": {
        "dtype": {
          "default": [
            "text",
            "html"
          ],
          "type": "dtype"
        },
        "title": {
          "default": "Browser",
          "type": "str"
        }
      },
      "module_name": "seamless.lib.gui.browser",
      "func_name": "browser",
      "code": "@macro(OrderedDict((\n    (\"dtype\",{\"type\": \"dtype\", \"default\": (\"text\", \"html\")}),\n    (\"title\",{\"type\": \"str\", \"default\": \"Browser\"})\n)))\ndef browser(ctx, dtype, title):\n    from seamless import editor\n    assert dtype[:2] == (\"text\", \"html\") #for now...\n    pinparams = {\n      \"value\": {\n        \"pin\": \"edit\",\n        \"dtype\": dtype\n      },\n      \"title\": {\n        \"pin\": \"input\",\n        \"dtype\": \"str\",\n      },\n    }\n    ed = ctx.ed = editor(pinparams)\n    ed.title.cell().set(title)\n    ed.code_start.cell().fromfile(\"cell-browser.py\")\n    ed.code_stop.cell().set('widget.destroy()')\n    c_up = ed.code_update.cell(True)\n    c_up.fromfile(\"cell-browser_UPDATE.py\")\n    ctx.export(ed, forced=[\"title\"])\n"
    },
    {
      "with_context": true,
      "dtype": [
        "text",
        "code",
        "python"
      ],
      "type_args": {
        "template_definition": "json",
        "output_type": {
          "default": [
            "text",
            "html"
          ],
          "type": "dtype"
        }
      },
      "module_name": "seamless.lib.templateer",
      "func_name": "templateer",
      "code": "@macro(OrderedDict((\n  (\"template_definition\", \"json\"),\n  (\"output_type\", {\"type\": \"dtype\", \"default\": (\"text\", \"html\")}),\n)))\ndef templateer(ctx, template_definition, output_type):\n    from seamless import cell, editor\n    templates = template_definition[\"templates\"]\n    assert isinstance(templates, list)\n    environment = template_definition[\"environment\"]\n    ed_params = {}\n    for t in templates:\n        assert t not in ed_params, t\n        ed_params[t] = {\"pin\": \"input\", \"dtype\": \"text\"}\n    for k,v in environment.items():\n        assert k not in ed_params, k\n        ed_params[k] = {\"pin\": \"input\", \"dtype\": v}\n    ed_params[\"TEMPLATE_DEFINITION\"] = {\"pin\": \"input\", \"dtype\": \"json\"}\n    ed_params[\"RESULT\"] = {\"pin\": \"output\", \"dtype\": output_type}\n    ctx.ed = editor(ed_params)\n    ctx.ed.TEMPLATE_DEFINITION.cell().set(template_definition)\n    ctx.ed.code_start.cell().fromfile(\"cell-templateer.py\")\n    ctx.ed.code_update.cell().set(\"make_template()\")\n    ctx.ed.code_stop.cell().set(\"\")\n    ctx.export(ctx.ed)\n"
    }
  ],
  "main": {
    "type": "context",
    "like_process": false,
    "like_cell": false,
    "pins": {},
    "auto": [],
    "children": {
      "attrib": {
        "dtype": "cson"
      },
      "axmax": {
        "dtype": "float",
        "data": "60"
      },
      "browser": {
        "type": "context",
        "like_process": true,
        "like_cell": false,
        "pins": {
          "title": "browser.ed.title",
          "value": "browser.ed.value"
        },
        "auto": [
          "cell1",
          "cell2",
          "cell3",
          "cell4"
        ],
        "children": {
          "cell1": {
            "dtype": "str",
            "data": "Browser"
          },
          "cell2": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "resource": {
              "filename": "/gui/cell-browser.py",
              "lib": true,
              "mode": 2
            },
            "data": "import os\nfrom seamless.qt.QtWebEngineWidgets import QWebEngineView\nfrom seamless.qt.Qt import QUrl\nfrom seamless.qt import QtWidgets, QtGui\n\nwidget = QWebEngineView()\nfake_url = QUrl.fromLocalFile(os.path.abspath(\"seamless.html\"))\nwidget.setWindowTitle(PINS.title.get())\nreloadAction = QtWidgets.QAction(QtGui.QIcon('exit.png'), '&Reload', widget)\nreloadAction.setShortcut('F5')\nreloadAction.setStatusTip('Reload')\nreloadAction.triggered.connect(widget.reload)\nwidget.addAction(reloadAction)\nwidget.setHtml(PINS.value.get())\nwidget.show()\n"
          },
          "cell3": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "data": "widget.destroy()"
          },
          "cell4": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "resource": {
              "filename": "/gui/cell-browser_UPDATE.py",
              "lib": true,
              "mode": 2
            },
            "data": "if PINS.value.defined:\n    widget.setHtml(PINS.value.get(), fake_url)\nif PINS.title.updated:\n    widget.setWindowTitle(PINS.title.get())\n",
            "owner": "browser.ed.code_update"
          },
          "ed": {
            "type": "editor",
            "mode": "sync",
            "params": {
              "title": {
                "dtype": "str",
                "pin": "input"
              },
              "value": {
                "dtype": [
                  "text",
                  "html"
                ],
                "pin": "edit"
              }
            }
          }
        }
      },
      "code": {
        "type": "context",
        "like_process": false,
        "like_cell": false,
        "pins": {},
        "auto": [
          "cell1",
          "cell10",
          "cell11",
          "cell12",
          "cell13",
          "cell14",
          "cell15",
          "cell16",
          "cell17",
          "cell18",
          "cell19",
          "cell2",
          "cell20",
          "cell21",
          "cell22",
          "cell23",
          "cell24",
          "cell25",
          "cell3",
          "cell4",
          "cell5",
          "cell6",
          "cell7",
          "cell8",
          "cell9"
        ],
        "children": {
          "cell1": {
            "dtype": "str",
            "data": "./cell-integrate-data.py"
          },
          "cell10": {
            "dtype": "float",
            "data": "0.2"
          },
          "cell11": {
            "dtype": "float",
            "data": "0.2"
          },
          "cell12": {
            "dtype": "str",
            "data": "./cell-data-parser.py"
          },
          "cell13": {
            "dtype": "float",
            "data": "0.2"
          },
          "cell14": {
            "dtype": "str",
            "data": "./cell-generate-attrib.py"
          },
          "cell15": {
            "dtype": "float",
            "data": "0.2"
          },
          "cell16": {
            "dtype": "str",
            "data": "./cell-generate-layout.py"
          },
          "cell17": {
            "dtype": "float",
            "data": "0.2"
          },
          "cell18": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "data": "\nimport sys\nargv = sys.argv\nif \"--\" in argv:\n    argv = argv[argv.index(\"--\"):]\nreturn argv[1] #specify tailstr: data file must have name data/$complex-$tailstr\n"
          },
          "cell19": {
            "dtype": "str"
          },
          "cell2": {
            "dtype": "float",
            "data": "0.2"
          },
          "cell20": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "data": "\nimport sys\nargv = sys.argv\nif \"--\" in argv:\n    argv = argv[argv.index(\"--\"):]\nreturn int(argv[2]) #specify assembly scheme: -1 for the last, -2 for the second-to-last, etc\n"
          },
          "cell21": {
            "dtype": "int"
          },
          "cell22": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "data": "\nimport sys\nargv = sys.argv\nif \"--\" in argv:\n    argv = argv[argv.index(\"--\"):]\nreturn float(argv[3]) #specify cutoff of what is a good structure\n"
          },
          "cell23": {
            "dtype": "float"
          },
          "cell24": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "data": "\nimport sys\nargv = sys.argv\nif \"--\" in argv:\n    argv = argv[argv.index(\"--\"):]\nreturn float(argv[4]) #specify axmax: maximum of both X and Y axis\n"
          },
          "cell25": {
            "dtype": "float"
          },
          "cell3": {
            "dtype": "str",
            "data": "plotdata/data.json"
          },
          "cell4": {
            "dtype": "float",
            "data": "0.2"
          },
          "cell5": {
            "dtype": "str",
            "data": "plotdata/attrib.cson"
          },
          "cell6": {
            "dtype": "float",
            "data": "0.2"
          },
          "cell7": {
            "dtype": "str",
            "data": "./cell-load-data-columns.py"
          },
          "cell8": {
            "dtype": "float",
            "data": "0.2"
          },
          "cell9": {
            "dtype": "str",
            "data": "plotdata/data.csv"
          },
          "integrate_data": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "data": "import copy\nresult = []\nfor n in range(len(data)):\n    series = {}\n    if n >= len(attrib):\n        if len(attrib) > 0:\n            series = attrib[-1]\n    else:\n        series = attrib[n]\n    series = copy.deepcopy(series)\n    series.update(data[n])\n    result.append(series)\nreturn result\n"
          },
          "load_data_columns": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "data": "import pandas as pd\nfrom io import StringIO\nfrom numpy import random\nresult = [{\"x\": [0, 100], \"y\": [0, 100]}]\n\ndf = pd.read_csv(StringIO(csv))\n#print(df.complex)\n#print(df.complex[0] == df.complex[1])\noccupied = {}\nfor complex in df.complex.unique():\n    cdf=df[df.complex==complex]\n    cdf=cdf[(df.attract_hits>0) |  (cdf.autodock_hits>0)]\n    frags = cdf[cdf.columns[1]].tolist()\n    for n in range(2, len(df.columns), 2):\n        v1, v2 = cdf[cdf.columns[n]], cdf[cdf.columns[n+1]]\n        x = v1.tolist()\n        y = v2.tolist()\n        for nn in range(len(v1)):\n            vv1, vv2 = x[nn], y[nn]\n            occ = occupied.get((vv1, vv2), 0)\n            if occ % 2:\n                x[nn] -= point_shift * (occ+1)/2\n            else:\n                x[nn] += point_shift * occ/2\n            occupied[(vv1, vv2)] = occ + 1\n        result.append({\"x\": x, \"y\": y})\nreturn result\n"
          }
        }
      },
      "code_generate_attrib": {
        "dtype": [
          "text",
          "code",
          "python"
        ],
        "data": "import pandas as pd\nfrom io import StringIO\nimport copy\n\ndf = pd.read_csv(StringIO(csv))\ncomplexes = df.complex.unique()\nattrib = [\n  {\n    \"type\": 'scatter',\n    \"showlegend\": False,\n  },\n]\nseries = {\n    \"type\": 'scatter',\n    \"mode\": 'markers',\n    \"marker\": {\n        \"size\": 10\n    }\n}\nsymbol_extremity = \"triangle-up\"\nsymbol_center = \"square\"\nfor complex in complexes:\n    myseries = copy.deepcopy(series)\n    cdf = df[df.complex==complex]\n    markers = []\n    texts = []\n    for n in cdf.index:\n        frag = cdf.fragment[n]\n        texts.append(\"frag\" + str(frag))\n        if frag == 1 or n == cdf.index[-1]:\n            markers.append(symbol_extremity)\n        else:\n            markers.append(symbol_center)\n    myseries[\"marker\"].update({\"symbol\": markers})\n    myseries[\"name\"] = complex\n    myseries[\"text\"] = texts\n    attrib.append(myseries)\n\nreturn attrib\n"
      },
      "code_generate_layout": {
        "dtype": [
          "text",
          "code",
          "python"
        ],
        "data": "layout = {\n    \"xaxis\": {\n      \"title\": 'assembly hits',\n      \"range\": [-0.5,axmax],\n      #type: \"log\"\n    },\n    \"yaxis\": {\n      \"title\": 'autodock hits',\n      \"range\": [-0.5,axmax]\n      #type: \"log\"\n    },\n}\nreturn layout\n"
      },
      "csv": {
        "dtype": "text"
      },
      "data": {
        "dtype": "json"
      },
      "data_parser": {
        "type": "transformer",
        "mode": "thread",
        "params": {
          "assembly_scheme": {
            "dtype": "int",
            "pin": "input"
          },
          "cutoff": {
            "dtype": "float",
            "pin": "input"
          },
          "result": {
            "dtype": "text",
            "pin": "output"
          },
          "tailstr": {
            "dtype": "str",
            "pin": "input"
          }
        }
      },
      "data_parser_code": {
        "dtype": [
          "text",
          "code",
          "python"
        ],
        "data": "import glob\n\nfiles = glob.glob(\"data/*-%s\" % tailstr)\ndata = []\nfor f in files:\n    complexname = f.split(\"/\")[1][:-len(tailstr)-1]\n    lines = list(open(f).readlines())\n    assembly_schemes = []\n    for lnr, l in enumerate(lines):\n        l = l.strip()\n        if l.startswith(\"**************\"):\n            assembly_schemes.append(lnr)\n    assert len(assembly_schemes)\n    frag = None\n    try:\n        pstart = assembly_schemes[assembly_scheme]\n    except IndexError:\n        continue\n    assembly_schemes.append(len(lines))\n    pend = assembly_schemes[assembly_schemes.index(pstart)+1]\n    for l in lines[pstart+1:pend]:\n        ll = l.split()\n        if ll[0] == \"fragment\":\n            frag = int(ll[1])\n            continue\n        if float(ll[0]) != cutoff:\n            continue\n        attract_hits = int(ll[1])\n        ad_hits = int(ll[2])\n        data.append((complexname, frag, attract_hits, ad_hits))\n#header = \"complex,fragment,attract_hits,autodock_hits,attract_best,autodock_best\"\nheader = \"complex,fragment,attract_hits,autodock_hits\"\ndata2 = \"\"\nfor l in data:\n    data2 += \",\".join([str(ll) for ll in l]) + \"\\n\"\nreturn header + \"\\n\" + data2\n"
      },
      "divname": {
        "dtype": "str",
        "data": "plotlydiv"
      },
      "generate_attrib": {
        "type": "transformer",
        "mode": "thread",
        "params": {
          "attrib": {
            "dtype": "json",
            "pin": "output"
          },
          "csv": {
            "dtype": "text",
            "pin": "input"
          }
        }
      },
      "generate_layout": {
        "type": "transformer",
        "mode": "thread",
        "params": {
          "axmax": {
            "dtype": "float",
            "pin": "input"
          },
          "layout": {
            "dtype": "json",
            "pin": "output"
          }
        }
      },
      "get_assembly_scheme": {
        "type": "transformer",
        "mode": "thread",
        "params": {
          "assembly_scheme": {
            "dtype": "int",
            "pin": "output"
          }
        }
      },
      "get_axmax": {
        "type": "transformer",
        "mode": "thread",
        "params": {
          "axmax": {
            "dtype": "float",
            "pin": "output"
          }
        }
      },
      "get_cutoff": {
        "type": "transformer",
        "mode": "thread",
        "params": {
          "cutoff": {
            "dtype": "float",
            "pin": "output"
          }
        }
      },
      "get_tailstr": {
        "type": "transformer",
        "mode": "thread",
        "params": {
          "tailstr": {
            "dtype": "str",
            "pin": "output"
          }
        }
      },
      "html": {
        "dtype": [
          "text",
          "html"
        ]
      },
      "integrate_data": {
        "type": "transformer",
        "mode": "thread",
        "params": {
          "attrib": {
            "dtype": "json",
            "pin": "input"
          },
          "data": {
            "dtype": "json",
            "pin": "input"
          },
          "plotly_data": {
            "dtype": "json",
            "pin": "output"
          }
        }
      },
      "links": {
        "type": "context",
        "like_process": false,
        "like_cell": false,
        "pins": {},
        "auto": [],
        "children": {
          "attrib": {
            "type": "context",
            "like_process": true,
            "like_cell": false,
            "pins": {
              "filepath": "links.attrib.ed.filepath",
              "latency": "links.attrib.ed.latency",
              "value": "links.attrib.ed.value"
            },
            "auto": [
              "cell1",
              "cell2",
              "cell3"
            ],
            "children": {
              "cell1": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filename": "/cell-filelink-start.py",
                  "lib": true,
                  "mode": 2
                },
                "data": "if __name__ == \"__main__\":\n    #test with ipython -i\n    import sys, os\n\n    class dummy:\n        pass\n\n    class EditPin:\n        def __init__(self, value):\n            self.value = value\n            self.defined = True\n        def set(self, value):\n            print(\"SET\", value)\n            self.value = value\n        def get(self):\n            return self.value\n\n    class Getter:\n        def __init__(self, arg):\n            self.arg = arg\n        def get(self):\n            return self.arg\n    PINS = dummy()\n    PINS.value = EditPin(\"test\")\n    directory = sys.argv[1]\n    filename = sys.argv[2]\n    PINS.filepath = Getter(os.path.join(directory, filename))\n    PINS.latency = Getter(float(sys.argv[3]))\n    def serializer(v):\n        return str(v.get())\n    print(\"Edit in \" + filepath.get())\nelse:\n    from seamless.dtypes import serialize\n    def serializer(v):\n        return serialize(v._dtype, v.get())\n\n\nimport os, time, functools, traceback\nfrom threading import Thread, RLock\nlast_value = None\nlast_serialized_value = None\nlast_exc = None\nlast_mtime = None\n\ndef write_file(fpath):\n    global last_mtime, last_value, last_serialized_value\n    if not PINS.value.defined:\n        last_mtime = -1 #will trigger a file read\n        return\n    if last_value == PINS.value.get():\n        return\n    val = serializer(PINS.value)\n    if last_serialized_value == val:\n        return\n    with lock:\n        if last_serialized_value != val:\n            #print(\"WRITE\", val)\n            with open(fpath, \"w\", encoding=\"utf-8\") as f:\n                f.write(val)\n                last_value = PINS.value.get()\n                last_serialized_value = val\n            last_time = time.time()\n            try:\n                stat = os.stat(fpath)\n                last_mtime = stat.st_mtime\n            except:\n                pass\n\ndef poll():\n    global last_time, last_mtime, last_value, last_serialized_value, last_exc\n    fpath = PINS.filepath.get()\n    while 1:\n        time.sleep(PINS.latency.get())\n        curr_time = time.time()\n        last_time = curr_time\n        if not os.path.exists(fpath):\n            try:\n                write_file(fpath)\n            except:\n                exc = traceback.format_exc()\n                if exc != last_exc:\n                    print(exc)\n                    last_exc = exc\n        else:\n            with lock:\n                stat = os.stat(fpath)\n                try:\n                    if last_mtime is None or stat.st_mtime > last_mtime:\n                        data = None\n                        with open(fpath, encoding=\"utf-8\") as f:\n                            data = f.read()\n                        if data is not None:\n                            if last_serialized_value != data:\n                                #print(\"LOAD\")\n                                PINS.value.set(data)\n                                last_value = None\n                                last_serialized_value = data\n                        last_mtime = stat.st_mtime\n                except:\n                    exc = traceback.format_exc()\n                    if exc != last_exc:\n                        print(exc)\n                        last_exc = exc\n\nt = Thread(target=poll)\nt.setDaemon(True)\nlock = RLock()\nwrite_file(PINS.filepath.get())\nt.start()\n"
              },
              "cell2": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "data": "write_file(PINS.filepath.get())"
              },
              "cell3": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "data": "t.join(0)"
              },
              "ed": {
                "type": "editor",
                "mode": "sync",
                "params": {
                  "filepath": {
                    "dtype": "str",
                    "pin": "input"
                  },
                  "latency": {
                    "dtype": "float",
                    "pin": "input"
                  },
                  "value": {
                    "dtype": "cson",
                    "must_be_defined": false,
                    "pin": "edit"
                  }
                }
              }
            }
          },
          "code_generate_attrib": {
            "type": "context",
            "like_process": true,
            "like_cell": false,
            "pins": {
              "filepath": "links.code_generate_attrib.ed.filepath",
              "latency": "links.code_generate_attrib.ed.latency",
              "value": "links.code_generate_attrib.ed.value"
            },
            "auto": [
              "cell1",
              "cell2",
              "cell3"
            ],
            "children": {
              "cell1": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filename": "/cell-filelink-start.py",
                  "lib": true,
                  "mode": 2
                },
                "data": "if __name__ == \"__main__\":\n    #test with ipython -i\n    import sys, os\n\n    class dummy:\n        pass\n\n    class EditPin:\n        def __init__(self, value):\n            self.value = value\n            self.defined = True\n        def set(self, value):\n            print(\"SET\", value)\n            self.value = value\n        def get(self):\n            return self.value\n\n    class Getter:\n        def __init__(self, arg):\n            self.arg = arg\n        def get(self):\n            return self.arg\n    PINS = dummy()\n    PINS.value = EditPin(\"test\")\n    directory = sys.argv[1]\n    filename = sys.argv[2]\n    PINS.filepath = Getter(os.path.join(directory, filename))\n    PINS.latency = Getter(float(sys.argv[3]))\n    def serializer(v):\n        return str(v.get())\n    print(\"Edit in \" + filepath.get())\nelse:\n    from seamless.dtypes import serialize\n    def serializer(v):\n        return serialize(v._dtype, v.get())\n\n\nimport os, time, functools, traceback\nfrom threading import Thread, RLock\nlast_value = None\nlast_serialized_value = None\nlast_exc = None\nlast_mtime = None\n\ndef write_file(fpath):\n    global last_mtime, last_value, last_serialized_value\n    if not PINS.value.defined:\n        last_mtime = -1 #will trigger a file read\n        return\n    if last_value == PINS.value.get():\n        return\n    val = serializer(PINS.value)\n    if last_serialized_value == val:\n        return\n    with lock:\n        if last_serialized_value != val:\n            #print(\"WRITE\", val)\n            with open(fpath, \"w\", encoding=\"utf-8\") as f:\n                f.write(val)\n                last_value = PINS.value.get()\n                last_serialized_value = val\n            last_time = time.time()\n            try:\n                stat = os.stat(fpath)\n                last_mtime = stat.st_mtime\n            except:\n                pass\n\ndef poll():\n    global last_time, last_mtime, last_value, last_serialized_value, last_exc\n    fpath = PINS.filepath.get()\n    while 1:\n        time.sleep(PINS.latency.get())\n        curr_time = time.time()\n        last_time = curr_time\n        if not os.path.exists(fpath):\n            try:\n                write_file(fpath)\n            except:\n                exc = traceback.format_exc()\n                if exc != last_exc:\n                    print(exc)\n                    last_exc = exc\n        else:\n            with lock:\n                stat = os.stat(fpath)\n                try:\n                    if last_mtime is None or stat.st_mtime > last_mtime:\n                        data = None\n                        with open(fpath, encoding=\"utf-8\") as f:\n                            data = f.read()\n                        if data is not None:\n                            if last_serialized_value != data:\n                                #print(\"LOAD\")\n                                PINS.value.set(data)\n                                last_value = None\n                                last_serialized_value = data\n                        last_mtime = stat.st_mtime\n                except:\n                    exc = traceback.format_exc()\n                    if exc != last_exc:\n                        print(exc)\n                        last_exc = exc\n\nt = Thread(target=poll)\nt.setDaemon(True)\nlock = RLock()\nwrite_file(PINS.filepath.get())\nt.start()\n"
              },
              "cell2": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "data": "write_file(PINS.filepath.get())"
              },
              "cell3": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "data": "t.join(0)"
              },
              "ed": {
                "type": "editor",
                "mode": "sync",
                "params": {
                  "filepath": {
                    "dtype": "str",
                    "pin": "input"
                  },
                  "latency": {
                    "dtype": "float",
                    "pin": "input"
                  },
                  "value": {
                    "dtype": [
                      "text",
                      "code",
                      "python"
                    ],
                    "must_be_defined": false,
                    "pin": "edit"
                  }
                }
              }
            }
          },
          "code_generate_layout": {
            "type": "context",
            "like_process": true,
            "like_cell": false,
            "pins": {
              "filepath": "links.code_generate_layout.ed.filepath",
              "latency": "links.code_generate_layout.ed.latency",
              "value": "links.code_generate_layout.ed.value"
            },
            "auto": [
              "cell1",
              "cell2",
              "cell3"
            ],
            "children": {
              "cell1": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filename": "/cell-filelink-start.py",
                  "lib": true,
                  "mode": 2
                },
                "data": "if __name__ == \"__main__\":\n    #test with ipython -i\n    import sys, os\n\n    class dummy:\n        pass\n\n    class EditPin:\n        def __init__(self, value):\n            self.value = value\n            self.defined = True\n        def set(self, value):\n            print(\"SET\", value)\n            self.value = value\n        def get(self):\n            return self.value\n\n    class Getter:\n        def __init__(self, arg):\n            self.arg = arg\n        def get(self):\n            return self.arg\n    PINS = dummy()\n    PINS.value = EditPin(\"test\")\n    directory = sys.argv[1]\n    filename = sys.argv[2]\n    PINS.filepath = Getter(os.path.join(directory, filename))\n    PINS.latency = Getter(float(sys.argv[3]))\n    def serializer(v):\n        return str(v.get())\n    print(\"Edit in \" + filepath.get())\nelse:\n    from seamless.dtypes import serialize\n    def serializer(v):\n        return serialize(v._dtype, v.get())\n\n\nimport os, time, functools, traceback\nfrom threading import Thread, RLock\nlast_value = None\nlast_serialized_value = None\nlast_exc = None\nlast_mtime = None\n\ndef write_file(fpath):\n    global last_mtime, last_value, last_serialized_value\n    if not PINS.value.defined:\n        last_mtime = -1 #will trigger a file read\n        return\n    if last_value == PINS.value.get():\n        return\n    val = serializer(PINS.value)\n    if last_serialized_value == val:\n        return\n    with lock:\n        if last_serialized_value != val:\n            #print(\"WRITE\", val)\n            with open(fpath, \"w\", encoding=\"utf-8\") as f:\n                f.write(val)\n                last_value = PINS.value.get()\n                last_serialized_value = val\n            last_time = time.time()\n            try:\n                stat = os.stat(fpath)\n                last_mtime = stat.st_mtime\n            except:\n                pass\n\ndef poll():\n    global last_time, last_mtime, last_value, last_serialized_value, last_exc\n    fpath = PINS.filepath.get()\n    while 1:\n        time.sleep(PINS.latency.get())\n        curr_time = time.time()\n        last_time = curr_time\n        if not os.path.exists(fpath):\n            try:\n                write_file(fpath)\n            except:\n                exc = traceback.format_exc()\n                if exc != last_exc:\n                    print(exc)\n                    last_exc = exc\n        else:\n            with lock:\n                stat = os.stat(fpath)\n                try:\n                    if last_mtime is None or stat.st_mtime > last_mtime:\n                        data = None\n                        with open(fpath, encoding=\"utf-8\") as f:\n                            data = f.read()\n                        if data is not None:\n                            if last_serialized_value != data:\n                                #print(\"LOAD\")\n                                PINS.value.set(data)\n                                last_value = None\n                                last_serialized_value = data\n                        last_mtime = stat.st_mtime\n                except:\n                    exc = traceback.format_exc()\n                    if exc != last_exc:\n                        print(exc)\n                        last_exc = exc\n\nt = Thread(target=poll)\nt.setDaemon(True)\nlock = RLock()\nwrite_file(PINS.filepath.get())\nt.start()\n"
              },
              "cell2": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "data": "write_file(PINS.filepath.get())"
              },
              "cell3": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "data": "t.join(0)"
              },
              "ed": {
                "type": "editor",
                "mode": "sync",
                "params": {
                  "filepath": {
                    "dtype": "str",
                    "pin": "input"
                  },
                  "latency": {
                    "dtype": "float",
                    "pin": "input"
                  },
                  "value": {
                    "dtype": [
                      "text",
                      "code",
                      "python"
                    ],
                    "must_be_defined": false,
                    "pin": "edit"
                  }
                }
              }
            }
          },
          "code_integrate_data": {
            "type": "context",
            "like_process": true,
            "like_cell": false,
            "pins": {
              "filepath": "links.code_integrate_data.ed.filepath",
              "latency": "links.code_integrate_data.ed.latency",
              "value": "links.code_integrate_data.ed.value"
            },
            "auto": [
              "cell1",
              "cell2",
              "cell3"
            ],
            "children": {
              "cell1": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filename": "/cell-filelink-start.py",
                  "lib": true,
                  "mode": 2
                },
                "data": "if __name__ == \"__main__\":\n    #test with ipython -i\n    import sys, os\n\n    class dummy:\n        pass\n\n    class EditPin:\n        def __init__(self, value):\n            self.value = value\n            self.defined = True\n        def set(self, value):\n            print(\"SET\", value)\n            self.value = value\n        def get(self):\n            return self.value\n\n    class Getter:\n        def __init__(self, arg):\n            self.arg = arg\n        def get(self):\n            return self.arg\n    PINS = dummy()\n    PINS.value = EditPin(\"test\")\n    directory = sys.argv[1]\n    filename = sys.argv[2]\n    PINS.filepath = Getter(os.path.join(directory, filename))\n    PINS.latency = Getter(float(sys.argv[3]))\n    def serializer(v):\n        return str(v.get())\n    print(\"Edit in \" + filepath.get())\nelse:\n    from seamless.dtypes import serialize\n    def serializer(v):\n        return serialize(v._dtype, v.get())\n\n\nimport os, time, functools, traceback\nfrom threading import Thread, RLock\nlast_value = None\nlast_serialized_value = None\nlast_exc = None\nlast_mtime = None\n\ndef write_file(fpath):\n    global last_mtime, last_value, last_serialized_value\n    if not PINS.value.defined:\n        last_mtime = -1 #will trigger a file read\n        return\n    if last_value == PINS.value.get():\n        return\n    val = serializer(PINS.value)\n    if last_serialized_value == val:\n        return\n    with lock:\n        if last_serialized_value != val:\n            #print(\"WRITE\", val)\n            with open(fpath, \"w\", encoding=\"utf-8\") as f:\n                f.write(val)\n                last_value = PINS.value.get()\n                last_serialized_value = val\n            last_time = time.time()\n            try:\n                stat = os.stat(fpath)\n                last_mtime = stat.st_mtime\n            except:\n                pass\n\ndef poll():\n    global last_time, last_mtime, last_value, last_serialized_value, last_exc\n    fpath = PINS.filepath.get()\n    while 1:\n        time.sleep(PINS.latency.get())\n        curr_time = time.time()\n        last_time = curr_time\n        if not os.path.exists(fpath):\n            try:\n                write_file(fpath)\n            except:\n                exc = traceback.format_exc()\n                if exc != last_exc:\n                    print(exc)\n                    last_exc = exc\n        else:\n            with lock:\n                stat = os.stat(fpath)\n                try:\n                    if last_mtime is None or stat.st_mtime > last_mtime:\n                        data = None\n                        with open(fpath, encoding=\"utf-8\") as f:\n                            data = f.read()\n                        if data is not None:\n                            if last_serialized_value != data:\n                                #print(\"LOAD\")\n                                PINS.value.set(data)\n                                last_value = None\n                                last_serialized_value = data\n                        last_mtime = stat.st_mtime\n                except:\n                    exc = traceback.format_exc()\n                    if exc != last_exc:\n                        print(exc)\n                        last_exc = exc\n\nt = Thread(target=poll)\nt.setDaemon(True)\nlock = RLock()\nwrite_file(PINS.filepath.get())\nt.start()\n"
              },
              "cell2": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "data": "write_file(PINS.filepath.get())"
              },
              "cell3": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "data": "t.join(0)"
              },
              "ed": {
                "type": "editor",
                "mode": "sync",
                "params": {
                  "filepath": {
                    "dtype": "str",
                    "pin": "input"
                  },
                  "latency": {
                    "dtype": "float",
                    "pin": "input"
                  },
                  "value": {
                    "dtype": [
                      "text",
                      "code",
                      "python"
                    ],
                    "must_be_defined": false,
                    "pin": "edit"
                  }
                }
              }
            }
          },
          "code_load_data_columns": {
            "type": "context",
            "like_process": true,
            "like_cell": false,
            "pins": {
              "filepath": "links.code_load_data_columns.ed.filepath",
              "latency": "links.code_load_data_columns.ed.latency",
              "value": "links.code_load_data_columns.ed.value"
            },
            "auto": [
              "cell1",
              "cell2",
              "cell3"
            ],
            "children": {
              "cell1": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filename": "/cell-filelink-start.py",
                  "lib": true,
                  "mode": 2
                },
                "data": "if __name__ == \"__main__\":\n    #test with ipython -i\n    import sys, os\n\n    class dummy:\n        pass\n\n    class EditPin:\n        def __init__(self, value):\n            self.value = value\n            self.defined = True\n        def set(self, value):\n            print(\"SET\", value)\n            self.value = value\n        def get(self):\n            return self.value\n\n    class Getter:\n        def __init__(self, arg):\n            self.arg = arg\n        def get(self):\n            return self.arg\n    PINS = dummy()\n    PINS.value = EditPin(\"test\")\n    directory = sys.argv[1]\n    filename = sys.argv[2]\n    PINS.filepath = Getter(os.path.join(directory, filename))\n    PINS.latency = Getter(float(sys.argv[3]))\n    def serializer(v):\n        return str(v.get())\n    print(\"Edit in \" + filepath.get())\nelse:\n    from seamless.dtypes import serialize\n    def serializer(v):\n        return serialize(v._dtype, v.get())\n\n\nimport os, time, functools, traceback\nfrom threading import Thread, RLock\nlast_value = None\nlast_serialized_value = None\nlast_exc = None\nlast_mtime = None\n\ndef write_file(fpath):\n    global last_mtime, last_value, last_serialized_value\n    if not PINS.value.defined:\n        last_mtime = -1 #will trigger a file read\n        return\n    if last_value == PINS.value.get():\n        return\n    val = serializer(PINS.value)\n    if last_serialized_value == val:\n        return\n    with lock:\n        if last_serialized_value != val:\n            #print(\"WRITE\", val)\n            with open(fpath, \"w\", encoding=\"utf-8\") as f:\n                f.write(val)\n                last_value = PINS.value.get()\n                last_serialized_value = val\n            last_time = time.time()\n            try:\n                stat = os.stat(fpath)\n                last_mtime = stat.st_mtime\n            except:\n                pass\n\ndef poll():\n    global last_time, last_mtime, last_value, last_serialized_value, last_exc\n    fpath = PINS.filepath.get()\n    while 1:\n        time.sleep(PINS.latency.get())\n        curr_time = time.time()\n        last_time = curr_time\n        if not os.path.exists(fpath):\n            try:\n                write_file(fpath)\n            except:\n                exc = traceback.format_exc()\n                if exc != last_exc:\n                    print(exc)\n                    last_exc = exc\n        else:\n            with lock:\n                stat = os.stat(fpath)\n                try:\n                    if last_mtime is None or stat.st_mtime > last_mtime:\n                        data = None\n                        with open(fpath, encoding=\"utf-8\") as f:\n                            data = f.read()\n                        if data is not None:\n                            if last_serialized_value != data:\n                                #print(\"LOAD\")\n                                PINS.value.set(data)\n                                last_value = None\n                                last_serialized_value = data\n                        last_mtime = stat.st_mtime\n                except:\n                    exc = traceback.format_exc()\n                    if exc != last_exc:\n                        print(exc)\n                        last_exc = exc\n\nt = Thread(target=poll)\nt.setDaemon(True)\nlock = RLock()\nwrite_file(PINS.filepath.get())\nt.start()\n"
              },
              "cell2": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "data": "write_file(PINS.filepath.get())"
              },
              "cell3": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "data": "t.join(0)"
              },
              "ed": {
                "type": "editor",
                "mode": "sync",
                "params": {
                  "filepath": {
                    "dtype": "str",
                    "pin": "input"
                  },
                  "latency": {
                    "dtype": "float",
                    "pin": "input"
                  },
                  "value": {
                    "dtype": [
                      "text",
                      "code",
                      "python"
                    ],
                    "must_be_defined": false,
                    "pin": "edit"
                  }
                }
              }
            }
          },
          "csv": {
            "type": "context",
            "like_process": true,
            "like_cell": false,
            "pins": {
              "filepath": "links.csv.ed.filepath",
              "latency": "links.csv.ed.latency",
              "value": "links.csv.ed.value"
            },
            "auto": [
              "cell1",
              "cell2",
              "cell3"
            ],
            "children": {
              "cell1": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filename": "/cell-filelink-start.py",
                  "lib": true,
                  "mode": 2
                },
                "data": "if __name__ == \"__main__\":\n    #test with ipython -i\n    import sys, os\n\n    class dummy:\n        pass\n\n    class EditPin:\n        def __init__(self, value):\n            self.value = value\n            self.defined = True\n        def set(self, value):\n            print(\"SET\", value)\n            self.value = value\n        def get(self):\n            return self.value\n\n    class Getter:\n        def __init__(self, arg):\n            self.arg = arg\n        def get(self):\n            return self.arg\n    PINS = dummy()\n    PINS.value = EditPin(\"test\")\n    directory = sys.argv[1]\n    filename = sys.argv[2]\n    PINS.filepath = Getter(os.path.join(directory, filename))\n    PINS.latency = Getter(float(sys.argv[3]))\n    def serializer(v):\n        return str(v.get())\n    print(\"Edit in \" + filepath.get())\nelse:\n    from seamless.dtypes import serialize\n    def serializer(v):\n        return serialize(v._dtype, v.get())\n\n\nimport os, time, functools, traceback\nfrom threading import Thread, RLock\nlast_value = None\nlast_serialized_value = None\nlast_exc = None\nlast_mtime = None\n\ndef write_file(fpath):\n    global last_mtime, last_value, last_serialized_value\n    if not PINS.value.defined:\n        last_mtime = -1 #will trigger a file read\n        return\n    if last_value == PINS.value.get():\n        return\n    val = serializer(PINS.value)\n    if last_serialized_value == val:\n        return\n    with lock:\n        if last_serialized_value != val:\n            #print(\"WRITE\", val)\n            with open(fpath, \"w\", encoding=\"utf-8\") as f:\n                f.write(val)\n                last_value = PINS.value.get()\n                last_serialized_value = val\n            last_time = time.time()\n            try:\n                stat = os.stat(fpath)\n                last_mtime = stat.st_mtime\n            except:\n                pass\n\ndef poll():\n    global last_time, last_mtime, last_value, last_serialized_value, last_exc\n    fpath = PINS.filepath.get()\n    while 1:\n        time.sleep(PINS.latency.get())\n        curr_time = time.time()\n        last_time = curr_time\n        if not os.path.exists(fpath):\n            try:\n                write_file(fpath)\n            except:\n                exc = traceback.format_exc()\n                if exc != last_exc:\n                    print(exc)\n                    last_exc = exc\n        else:\n            with lock:\n                stat = os.stat(fpath)\n                try:\n                    if last_mtime is None or stat.st_mtime > last_mtime:\n                        data = None\n                        with open(fpath, encoding=\"utf-8\") as f:\n                            data = f.read()\n                        if data is not None:\n                            if last_serialized_value != data:\n                                #print(\"LOAD\")\n                                PINS.value.set(data)\n                                last_value = None\n                                last_serialized_value = data\n                        last_mtime = stat.st_mtime\n                except:\n                    exc = traceback.format_exc()\n                    if exc != last_exc:\n                        print(exc)\n                        last_exc = exc\n\nt = Thread(target=poll)\nt.setDaemon(True)\nlock = RLock()\nwrite_file(PINS.filepath.get())\nt.start()\n"
              },
              "cell2": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "data": "write_file(PINS.filepath.get())"
              },
              "cell3": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "data": "t.join(0)"
              },
              "ed": {
                "type": "editor",
                "mode": "sync",
                "params": {
                  "filepath": {
                    "dtype": "str",
                    "pin": "input"
                  },
                  "latency": {
                    "dtype": "float",
                    "pin": "input"
                  },
                  "value": {
                    "dtype": "text",
                    "must_be_defined": false,
                    "pin": "edit"
                  }
                }
              }
            }
          },
          "data": {
            "type": "context",
            "like_process": true,
            "like_cell": false,
            "pins": {
              "filepath": "links.data.ed.filepath",
              "latency": "links.data.ed.latency",
              "value": "links.data.ed.value"
            },
            "auto": [
              "cell1",
              "cell2",
              "cell3"
            ],
            "children": {
              "cell1": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filename": "/cell-filelink-start.py",
                  "lib": true,
                  "mode": 2
                },
                "data": "if __name__ == \"__main__\":\n    #test with ipython -i\n    import sys, os\n\n    class dummy:\n        pass\n\n    class EditPin:\n        def __init__(self, value):\n            self.value = value\n            self.defined = True\n        def set(self, value):\n            print(\"SET\", value)\n            self.value = value\n        def get(self):\n            return self.value\n\n    class Getter:\n        def __init__(self, arg):\n            self.arg = arg\n        def get(self):\n            return self.arg\n    PINS = dummy()\n    PINS.value = EditPin(\"test\")\n    directory = sys.argv[1]\n    filename = sys.argv[2]\n    PINS.filepath = Getter(os.path.join(directory, filename))\n    PINS.latency = Getter(float(sys.argv[3]))\n    def serializer(v):\n        return str(v.get())\n    print(\"Edit in \" + filepath.get())\nelse:\n    from seamless.dtypes import serialize\n    def serializer(v):\n        return serialize(v._dtype, v.get())\n\n\nimport os, time, functools, traceback\nfrom threading import Thread, RLock\nlast_value = None\nlast_serialized_value = None\nlast_exc = None\nlast_mtime = None\n\ndef write_file(fpath):\n    global last_mtime, last_value, last_serialized_value\n    if not PINS.value.defined:\n        last_mtime = -1 #will trigger a file read\n        return\n    if last_value == PINS.value.get():\n        return\n    val = serializer(PINS.value)\n    if last_serialized_value == val:\n        return\n    with lock:\n        if last_serialized_value != val:\n            #print(\"WRITE\", val)\n            with open(fpath, \"w\", encoding=\"utf-8\") as f:\n                f.write(val)\n                last_value = PINS.value.get()\n                last_serialized_value = val\n            last_time = time.time()\n            try:\n                stat = os.stat(fpath)\n                last_mtime = stat.st_mtime\n            except:\n                pass\n\ndef poll():\n    global last_time, last_mtime, last_value, last_serialized_value, last_exc\n    fpath = PINS.filepath.get()\n    while 1:\n        time.sleep(PINS.latency.get())\n        curr_time = time.time()\n        last_time = curr_time\n        if not os.path.exists(fpath):\n            try:\n                write_file(fpath)\n            except:\n                exc = traceback.format_exc()\n                if exc != last_exc:\n                    print(exc)\n                    last_exc = exc\n        else:\n            with lock:\n                stat = os.stat(fpath)\n                try:\n                    if last_mtime is None or stat.st_mtime > last_mtime:\n                        data = None\n                        with open(fpath, encoding=\"utf-8\") as f:\n                            data = f.read()\n                        if data is not None:\n                            if last_serialized_value != data:\n                                #print(\"LOAD\")\n                                PINS.value.set(data)\n                                last_value = None\n                                last_serialized_value = data\n                        last_mtime = stat.st_mtime\n                except:\n                    exc = traceback.format_exc()\n                    if exc != last_exc:\n                        print(exc)\n                        last_exc = exc\n\nt = Thread(target=poll)\nt.setDaemon(True)\nlock = RLock()\nwrite_file(PINS.filepath.get())\nt.start()\n"
              },
              "cell2": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "data": "write_file(PINS.filepath.get())"
              },
              "cell3": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "data": "t.join(0)"
              },
              "ed": {
                "type": "editor",
                "mode": "sync",
                "params": {
                  "filepath": {
                    "dtype": "str",
                    "pin": "input"
                  },
                  "latency": {
                    "dtype": "float",
                    "pin": "input"
                  },
                  "value": {
                    "dtype": "json",
                    "must_be_defined": false,
                    "pin": "edit"
                  }
                }
              }
            }
          },
          "data_parser_code": {
            "type": "context",
            "like_process": true,
            "like_cell": false,
            "pins": {
              "filepath": "links.data_parser_code.ed.filepath",
              "latency": "links.data_parser_code.ed.latency",
              "value": "links.data_parser_code.ed.value"
            },
            "auto": [
              "cell1",
              "cell2",
              "cell3"
            ],
            "children": {
              "cell1": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filename": "/cell-filelink-start.py",
                  "lib": true,
                  "mode": 2
                },
                "data": "if __name__ == \"__main__\":\n    #test with ipython -i\n    import sys, os\n\n    class dummy:\n        pass\n\n    class EditPin:\n        def __init__(self, value):\n            self.value = value\n            self.defined = True\n        def set(self, value):\n            print(\"SET\", value)\n            self.value = value\n        def get(self):\n            return self.value\n\n    class Getter:\n        def __init__(self, arg):\n            self.arg = arg\n        def get(self):\n            return self.arg\n    PINS = dummy()\n    PINS.value = EditPin(\"test\")\n    directory = sys.argv[1]\n    filename = sys.argv[2]\n    PINS.filepath = Getter(os.path.join(directory, filename))\n    PINS.latency = Getter(float(sys.argv[3]))\n    def serializer(v):\n        return str(v.get())\n    print(\"Edit in \" + filepath.get())\nelse:\n    from seamless.dtypes import serialize\n    def serializer(v):\n        return serialize(v._dtype, v.get())\n\n\nimport os, time, functools, traceback\nfrom threading import Thread, RLock\nlast_value = None\nlast_serialized_value = None\nlast_exc = None\nlast_mtime = None\n\ndef write_file(fpath):\n    global last_mtime, last_value, last_serialized_value\n    if not PINS.value.defined:\n        last_mtime = -1 #will trigger a file read\n        return\n    if last_value == PINS.value.get():\n        return\n    val = serializer(PINS.value)\n    if last_serialized_value == val:\n        return\n    with lock:\n        if last_serialized_value != val:\n            #print(\"WRITE\", val)\n            with open(fpath, \"w\", encoding=\"utf-8\") as f:\n                f.write(val)\n                last_value = PINS.value.get()\n                last_serialized_value = val\n            last_time = time.time()\n            try:\n                stat = os.stat(fpath)\n                last_mtime = stat.st_mtime\n            except:\n                pass\n\ndef poll():\n    global last_time, last_mtime, last_value, last_serialized_value, last_exc\n    fpath = PINS.filepath.get()\n    while 1:\n        time.sleep(PINS.latency.get())\n        curr_time = time.time()\n        last_time = curr_time\n        if not os.path.exists(fpath):\n            try:\n                write_file(fpath)\n            except:\n                exc = traceback.format_exc()\n                if exc != last_exc:\n                    print(exc)\n                    last_exc = exc\n        else:\n            with lock:\n                stat = os.stat(fpath)\n                try:\n                    if last_mtime is None or stat.st_mtime > last_mtime:\n                        data = None\n                        with open(fpath, encoding=\"utf-8\") as f:\n                            data = f.read()\n                        if data is not None:\n                            if last_serialized_value != data:\n                                #print(\"LOAD\")\n                                PINS.value.set(data)\n                                last_value = None\n                                last_serialized_value = data\n                        last_mtime = stat.st_mtime\n                except:\n                    exc = traceback.format_exc()\n                    if exc != last_exc:\n                        print(exc)\n                        last_exc = exc\n\nt = Thread(target=poll)\nt.setDaemon(True)\nlock = RLock()\nwrite_file(PINS.filepath.get())\nt.start()\n"
              },
              "cell2": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "data": "write_file(PINS.filepath.get())"
              },
              "cell3": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "data": "t.join(0)"
              },
              "ed": {
                "type": "editor",
                "mode": "sync",
                "params": {
                  "filepath": {
                    "dtype": "str",
                    "pin": "input"
                  },
                  "latency": {
                    "dtype": "float",
                    "pin": "input"
                  },
                  "value": {
                    "dtype": [
                      "text",
                      "code",
                      "python"
                    ],
                    "must_be_defined": false,
                    "pin": "edit"
                  }
                }
              }
            }
          },
          "html": {
            "type": "context",
            "like_process": true,
            "like_cell": false,
            "pins": {
              "filepath": "links.html.ed.filepath",
              "latency": "links.html.ed.latency",
              "value": "links.html.ed.value"
            },
            "auto": [
              "cell1",
              "cell2",
              "cell3"
            ],
            "children": {
              "cell1": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filename": "/cell-filelink-start.py",
                  "lib": true,
                  "mode": 2
                },
                "data": "if __name__ == \"__main__\":\n    #test with ipython -i\n    import sys, os\n\n    class dummy:\n        pass\n\n    class EditPin:\n        def __init__(self, value):\n            self.value = value\n            self.defined = True\n        def set(self, value):\n            print(\"SET\", value)\n            self.value = value\n        def get(self):\n            return self.value\n\n    class Getter:\n        def __init__(self, arg):\n            self.arg = arg\n        def get(self):\n            return self.arg\n    PINS = dummy()\n    PINS.value = EditPin(\"test\")\n    directory = sys.argv[1]\n    filename = sys.argv[2]\n    PINS.filepath = Getter(os.path.join(directory, filename))\n    PINS.latency = Getter(float(sys.argv[3]))\n    def serializer(v):\n        return str(v.get())\n    print(\"Edit in \" + filepath.get())\nelse:\n    from seamless.dtypes import serialize\n    def serializer(v):\n        return serialize(v._dtype, v.get())\n\n\nimport os, time, functools, traceback\nfrom threading import Thread, RLock\nlast_value = None\nlast_serialized_value = None\nlast_exc = None\nlast_mtime = None\n\ndef write_file(fpath):\n    global last_mtime, last_value, last_serialized_value\n    if not PINS.value.defined:\n        last_mtime = -1 #will trigger a file read\n        return\n    if last_value == PINS.value.get():\n        return\n    val = serializer(PINS.value)\n    if last_serialized_value == val:\n        return\n    with lock:\n        if last_serialized_value != val:\n            #print(\"WRITE\", val)\n            with open(fpath, \"w\", encoding=\"utf-8\") as f:\n                f.write(val)\n                last_value = PINS.value.get()\n                last_serialized_value = val\n            last_time = time.time()\n            try:\n                stat = os.stat(fpath)\n                last_mtime = stat.st_mtime\n            except:\n                pass\n\ndef poll():\n    global last_time, last_mtime, last_value, last_serialized_value, last_exc\n    fpath = PINS.filepath.get()\n    while 1:\n        time.sleep(PINS.latency.get())\n        curr_time = time.time()\n        last_time = curr_time\n        if not os.path.exists(fpath):\n            try:\n                write_file(fpath)\n            except:\n                exc = traceback.format_exc()\n                if exc != last_exc:\n                    print(exc)\n                    last_exc = exc\n        else:\n            with lock:\n                stat = os.stat(fpath)\n                try:\n                    if last_mtime is None or stat.st_mtime > last_mtime:\n                        data = None\n                        with open(fpath, encoding=\"utf-8\") as f:\n                            data = f.read()\n                        if data is not None:\n                            if last_serialized_value != data:\n                                #print(\"LOAD\")\n                                PINS.value.set(data)\n                                last_value = None\n                                last_serialized_value = data\n                        last_mtime = stat.st_mtime\n                except:\n                    exc = traceback.format_exc()\n                    if exc != last_exc:\n                        print(exc)\n                        last_exc = exc\n\nt = Thread(target=poll)\nt.setDaemon(True)\nlock = RLock()\nwrite_file(PINS.filepath.get())\nt.start()\n"
              },
              "cell2": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "data": "write_file(PINS.filepath.get())"
              },
              "cell3": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "data": "t.join(0)"
              },
              "ed": {
                "type": "editor",
                "mode": "sync",
                "params": {
                  "filepath": {
                    "dtype": "str",
                    "pin": "input"
                  },
                  "latency": {
                    "dtype": "float",
                    "pin": "input"
                  },
                  "value": {
                    "dtype": [
                      "text",
                      "html"
                    ],
                    "must_be_defined": false,
                    "pin": "edit"
                  }
                }
              }
            }
          },
          "params_templateer_static": {
            "type": "context",
            "like_process": true,
            "like_cell": false,
            "pins": {
              "filepath": "links.params_templateer_static.ed.filepath",
              "latency": "links.params_templateer_static.ed.latency",
              "value": "links.params_templateer_static.ed.value"
            },
            "auto": [
              "cell1",
              "cell2",
              "cell3"
            ],
            "children": {
              "cell1": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filename": "/cell-filelink-start.py",
                  "lib": true,
                  "mode": 2
                },
                "data": "if __name__ == \"__main__\":\n    #test with ipython -i\n    import sys, os\n\n    class dummy:\n        pass\n\n    class EditPin:\n        def __init__(self, value):\n            self.value = value\n            self.defined = True\n        def set(self, value):\n            print(\"SET\", value)\n            self.value = value\n        def get(self):\n            return self.value\n\n    class Getter:\n        def __init__(self, arg):\n            self.arg = arg\n        def get(self):\n            return self.arg\n    PINS = dummy()\n    PINS.value = EditPin(\"test\")\n    directory = sys.argv[1]\n    filename = sys.argv[2]\n    PINS.filepath = Getter(os.path.join(directory, filename))\n    PINS.latency = Getter(float(sys.argv[3]))\n    def serializer(v):\n        return str(v.get())\n    print(\"Edit in \" + filepath.get())\nelse:\n    from seamless.dtypes import serialize\n    def serializer(v):\n        return serialize(v._dtype, v.get())\n\n\nimport os, time, functools, traceback\nfrom threading import Thread, RLock\nlast_value = None\nlast_serialized_value = None\nlast_exc = None\nlast_mtime = None\n\ndef write_file(fpath):\n    global last_mtime, last_value, last_serialized_value\n    if not PINS.value.defined:\n        last_mtime = -1 #will trigger a file read\n        return\n    if last_value == PINS.value.get():\n        return\n    val = serializer(PINS.value)\n    if last_serialized_value == val:\n        return\n    with lock:\n        if last_serialized_value != val:\n            #print(\"WRITE\", val)\n            with open(fpath, \"w\", encoding=\"utf-8\") as f:\n                f.write(val)\n                last_value = PINS.value.get()\n                last_serialized_value = val\n            last_time = time.time()\n            try:\n                stat = os.stat(fpath)\n                last_mtime = stat.st_mtime\n            except:\n                pass\n\ndef poll():\n    global last_time, last_mtime, last_value, last_serialized_value, last_exc\n    fpath = PINS.filepath.get()\n    while 1:\n        time.sleep(PINS.latency.get())\n        curr_time = time.time()\n        last_time = curr_time\n        if not os.path.exists(fpath):\n            try:\n                write_file(fpath)\n            except:\n                exc = traceback.format_exc()\n                if exc != last_exc:\n                    print(exc)\n                    last_exc = exc\n        else:\n            with lock:\n                stat = os.stat(fpath)\n                try:\n                    if last_mtime is None or stat.st_mtime > last_mtime:\n                        data = None\n                        with open(fpath, encoding=\"utf-8\") as f:\n                            data = f.read()\n                        if data is not None:\n                            if last_serialized_value != data:\n                                #print(\"LOAD\")\n                                PINS.value.set(data)\n                                last_value = None\n                                last_serialized_value = data\n                        last_mtime = stat.st_mtime\n                except:\n                    exc = traceback.format_exc()\n                    if exc != last_exc:\n                        print(exc)\n                        last_exc = exc\n\nt = Thread(target=poll)\nt.setDaemon(True)\nlock = RLock()\nwrite_file(PINS.filepath.get())\nt.start()\n"
              },
              "cell2": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "data": "write_file(PINS.filepath.get())"
              },
              "cell3": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "data": "t.join(0)"
              },
              "ed": {
                "type": "editor",
                "mode": "sync",
                "params": {
                  "filepath": {
                    "dtype": "str",
                    "pin": "input"
                  },
                  "latency": {
                    "dtype": "float",
                    "pin": "input"
                  },
                  "value": {
                    "dtype": "cson",
                    "must_be_defined": false,
                    "pin": "edit"
                  }
                }
              }
            }
          },
          "plotly_config": {
            "type": "context",
            "like_process": true,
            "like_cell": false,
            "pins": {
              "filepath": "links.plotly_config.ed.filepath",
              "latency": "links.plotly_config.ed.latency",
              "value": "links.plotly_config.ed.value"
            },
            "auto": [
              "cell1",
              "cell2",
              "cell3"
            ],
            "children": {
              "cell1": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filename": "/cell-filelink-start.py",
                  "lib": true,
                  "mode": 2
                },
                "data": "if __name__ == \"__main__\":\n    #test with ipython -i\n    import sys, os\n\n    class dummy:\n        pass\n\n    class EditPin:\n        def __init__(self, value):\n            self.value = value\n            self.defined = True\n        def set(self, value):\n            print(\"SET\", value)\n            self.value = value\n        def get(self):\n            return self.value\n\n    class Getter:\n        def __init__(self, arg):\n            self.arg = arg\n        def get(self):\n            return self.arg\n    PINS = dummy()\n    PINS.value = EditPin(\"test\")\n    directory = sys.argv[1]\n    filename = sys.argv[2]\n    PINS.filepath = Getter(os.path.join(directory, filename))\n    PINS.latency = Getter(float(sys.argv[3]))\n    def serializer(v):\n        return str(v.get())\n    print(\"Edit in \" + filepath.get())\nelse:\n    from seamless.dtypes import serialize\n    def serializer(v):\n        return serialize(v._dtype, v.get())\n\n\nimport os, time, functools, traceback\nfrom threading import Thread, RLock\nlast_value = None\nlast_serialized_value = None\nlast_exc = None\nlast_mtime = None\n\ndef write_file(fpath):\n    global last_mtime, last_value, last_serialized_value\n    if not PINS.value.defined:\n        last_mtime = -1 #will trigger a file read\n        return\n    if last_value == PINS.value.get():\n        return\n    val = serializer(PINS.value)\n    if last_serialized_value == val:\n        return\n    with lock:\n        if last_serialized_value != val:\n            #print(\"WRITE\", val)\n            with open(fpath, \"w\", encoding=\"utf-8\") as f:\n                f.write(val)\n                last_value = PINS.value.get()\n                last_serialized_value = val\n            last_time = time.time()\n            try:\n                stat = os.stat(fpath)\n                last_mtime = stat.st_mtime\n            except:\n                pass\n\ndef poll():\n    global last_time, last_mtime, last_value, last_serialized_value, last_exc\n    fpath = PINS.filepath.get()\n    while 1:\n        time.sleep(PINS.latency.get())\n        curr_time = time.time()\n        last_time = curr_time\n        if not os.path.exists(fpath):\n            try:\n                write_file(fpath)\n            except:\n                exc = traceback.format_exc()\n                if exc != last_exc:\n                    print(exc)\n                    last_exc = exc\n        else:\n            with lock:\n                stat = os.stat(fpath)\n                try:\n                    if last_mtime is None or stat.st_mtime > last_mtime:\n                        data = None\n                        with open(fpath, encoding=\"utf-8\") as f:\n                            data = f.read()\n                        if data is not None:\n                            if last_serialized_value != data:\n                                #print(\"LOAD\")\n                                PINS.value.set(data)\n                                last_value = None\n                                last_serialized_value = data\n                        last_mtime = stat.st_mtime\n                except:\n                    exc = traceback.format_exc()\n                    if exc != last_exc:\n                        print(exc)\n                        last_exc = exc\n\nt = Thread(target=poll)\nt.setDaemon(True)\nlock = RLock()\nwrite_file(PINS.filepath.get())\nt.start()\n"
              },
              "cell2": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "data": "write_file(PINS.filepath.get())"
              },
              "cell3": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "data": "t.join(0)"
              },
              "ed": {
                "type": "editor",
                "mode": "sync",
                "params": {
                  "filepath": {
                    "dtype": "str",
                    "pin": "input"
                  },
                  "latency": {
                    "dtype": "float",
                    "pin": "input"
                  },
                  "value": {
                    "dtype": "cson",
                    "must_be_defined": false,
                    "pin": "edit"
                  }
                }
              }
            }
          },
          "plotly_data": {
            "type": "context",
            "like_process": true,
            "like_cell": false,
            "pins": {
              "filepath": "links.plotly_data.ed.filepath",
              "latency": "links.plotly_data.ed.latency",
              "value": "links.plotly_data.ed.value"
            },
            "auto": [
              "cell1",
              "cell2",
              "cell3"
            ],
            "children": {
              "cell1": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filename": "/cell-filelink-start.py",
                  "lib": true,
                  "mode": 2
                },
                "data": "if __name__ == \"__main__\":\n    #test with ipython -i\n    import sys, os\n\n    class dummy:\n        pass\n\n    class EditPin:\n        def __init__(self, value):\n            self.value = value\n            self.defined = True\n        def set(self, value):\n            print(\"SET\", value)\n            self.value = value\n        def get(self):\n            return self.value\n\n    class Getter:\n        def __init__(self, arg):\n            self.arg = arg\n        def get(self):\n            return self.arg\n    PINS = dummy()\n    PINS.value = EditPin(\"test\")\n    directory = sys.argv[1]\n    filename = sys.argv[2]\n    PINS.filepath = Getter(os.path.join(directory, filename))\n    PINS.latency = Getter(float(sys.argv[3]))\n    def serializer(v):\n        return str(v.get())\n    print(\"Edit in \" + filepath.get())\nelse:\n    from seamless.dtypes import serialize\n    def serializer(v):\n        return serialize(v._dtype, v.get())\n\n\nimport os, time, functools, traceback\nfrom threading import Thread, RLock\nlast_value = None\nlast_serialized_value = None\nlast_exc = None\nlast_mtime = None\n\ndef write_file(fpath):\n    global last_mtime, last_value, last_serialized_value\n    if not PINS.value.defined:\n        last_mtime = -1 #will trigger a file read\n        return\n    if last_value == PINS.value.get():\n        return\n    val = serializer(PINS.value)\n    if last_serialized_value == val:\n        return\n    with lock:\n        if last_serialized_value != val:\n            #print(\"WRITE\", val)\n            with open(fpath, \"w\", encoding=\"utf-8\") as f:\n                f.write(val)\n                last_value = PINS.value.get()\n                last_serialized_value = val\n            last_time = time.time()\n            try:\n                stat = os.stat(fpath)\n                last_mtime = stat.st_mtime\n            except:\n                pass\n\ndef poll():\n    global last_time, last_mtime, last_value, last_serialized_value, last_exc\n    fpath = PINS.filepath.get()\n    while 1:\n        time.sleep(PINS.latency.get())\n        curr_time = time.time()\n        last_time = curr_time\n        if not os.path.exists(fpath):\n            try:\n                write_file(fpath)\n            except:\n                exc = traceback.format_exc()\n                if exc != last_exc:\n                    print(exc)\n                    last_exc = exc\n        else:\n            with lock:\n                stat = os.stat(fpath)\n                try:\n                    if last_mtime is None or stat.st_mtime > last_mtime:\n                        data = None\n                        with open(fpath, encoding=\"utf-8\") as f:\n                            data = f.read()\n                        if data is not None:\n                            if last_serialized_value != data:\n                                #print(\"LOAD\")\n                                PINS.value.set(data)\n                                last_value = None\n                                last_serialized_value = data\n                        last_mtime = stat.st_mtime\n                except:\n                    exc = traceback.format_exc()\n                    if exc != last_exc:\n                        print(exc)\n                        last_exc = exc\n\nt = Thread(target=poll)\nt.setDaemon(True)\nlock = RLock()\nwrite_file(PINS.filepath.get())\nt.start()\n"
              },
              "cell2": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "data": "write_file(PINS.filepath.get())"
              },
              "cell3": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "data": "t.join(0)"
              },
              "ed": {
                "type": "editor",
                "mode": "sync",
                "params": {
                  "filepath": {
                    "dtype": "str",
                    "pin": "input"
                  },
                  "latency": {
                    "dtype": "float",
                    "pin": "input"
                  },
                  "value": {
                    "dtype": "cson",
                    "must_be_defined": false,
                    "pin": "edit"
                  }
                }
              }
            }
          },
          "plotly_layout": {
            "type": "context",
            "like_process": true,
            "like_cell": false,
            "pins": {
              "filepath": "links.plotly_layout.ed.filepath",
              "latency": "links.plotly_layout.ed.latency",
              "value": "links.plotly_layout.ed.value"
            },
            "auto": [
              "cell1",
              "cell2",
              "cell3"
            ],
            "children": {
              "cell1": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filename": "/cell-filelink-start.py",
                  "lib": true,
                  "mode": 2
                },
                "data": "if __name__ == \"__main__\":\n    #test with ipython -i\n    import sys, os\n\n    class dummy:\n        pass\n\n    class EditPin:\n        def __init__(self, value):\n            self.value = value\n            self.defined = True\n        def set(self, value):\n            print(\"SET\", value)\n            self.value = value\n        def get(self):\n            return self.value\n\n    class Getter:\n        def __init__(self, arg):\n            self.arg = arg\n        def get(self):\n            return self.arg\n    PINS = dummy()\n    PINS.value = EditPin(\"test\")\n    directory = sys.argv[1]\n    filename = sys.argv[2]\n    PINS.filepath = Getter(os.path.join(directory, filename))\n    PINS.latency = Getter(float(sys.argv[3]))\n    def serializer(v):\n        return str(v.get())\n    print(\"Edit in \" + filepath.get())\nelse:\n    from seamless.dtypes import serialize\n    def serializer(v):\n        return serialize(v._dtype, v.get())\n\n\nimport os, time, functools, traceback\nfrom threading import Thread, RLock\nlast_value = None\nlast_serialized_value = None\nlast_exc = None\nlast_mtime = None\n\ndef write_file(fpath):\n    global last_mtime, last_value, last_serialized_value\n    if not PINS.value.defined:\n        last_mtime = -1 #will trigger a file read\n        return\n    if last_value == PINS.value.get():\n        return\n    val = serializer(PINS.value)\n    if last_serialized_value == val:\n        return\n    with lock:\n        if last_serialized_value != val:\n            #print(\"WRITE\", val)\n            with open(fpath, \"w\", encoding=\"utf-8\") as f:\n                f.write(val)\n                last_value = PINS.value.get()\n                last_serialized_value = val\n            last_time = time.time()\n            try:\n                stat = os.stat(fpath)\n                last_mtime = stat.st_mtime\n            except:\n                pass\n\ndef poll():\n    global last_time, last_mtime, last_value, last_serialized_value, last_exc\n    fpath = PINS.filepath.get()\n    while 1:\n        time.sleep(PINS.latency.get())\n        curr_time = time.time()\n        last_time = curr_time\n        if not os.path.exists(fpath):\n            try:\n                write_file(fpath)\n            except:\n                exc = traceback.format_exc()\n                if exc != last_exc:\n                    print(exc)\n                    last_exc = exc\n        else:\n            with lock:\n                stat = os.stat(fpath)\n                try:\n                    if last_mtime is None or stat.st_mtime > last_mtime:\n                        data = None\n                        with open(fpath, encoding=\"utf-8\") as f:\n                            data = f.read()\n                        if data is not None:\n                            if last_serialized_value != data:\n                                #print(\"LOAD\")\n                                PINS.value.set(data)\n                                last_value = None\n                                last_serialized_value = data\n                        last_mtime = stat.st_mtime\n                except:\n                    exc = traceback.format_exc()\n                    if exc != last_exc:\n                        print(exc)\n                        last_exc = exc\n\nt = Thread(target=poll)\nt.setDaemon(True)\nlock = RLock()\nwrite_file(PINS.filepath.get())\nt.start()\n"
              },
              "cell2": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "data": "write_file(PINS.filepath.get())"
              },
              "cell3": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "data": "t.join(0)"
              },
              "ed": {
                "type": "editor",
                "mode": "sync",
                "params": {
                  "filepath": {
                    "dtype": "str",
                    "pin": "input"
                  },
                  "latency": {
                    "dtype": "float",
                    "pin": "input"
                  },
                  "value": {
                    "dtype": "cson",
                    "must_be_defined": false,
                    "pin": "edit"
                  }
                }
              }
            }
          },
          "template_body": {
            "type": "context",
            "like_process": true,
            "like_cell": false,
            "pins": {
              "filepath": "links.template_body.ed.filepath",
              "latency": "links.template_body.ed.latency",
              "value": "links.template_body.ed.value"
            },
            "auto": [
              "cell1",
              "cell2",
              "cell3"
            ],
            "children": {
              "cell1": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filename": "/cell-filelink-start.py",
                  "lib": true,
                  "mode": 2
                },
                "data": "if __name__ == \"__main__\":\n    #test with ipython -i\n    import sys, os\n\n    class dummy:\n        pass\n\n    class EditPin:\n        def __init__(self, value):\n            self.value = value\n            self.defined = True\n        def set(self, value):\n            print(\"SET\", value)\n            self.value = value\n        def get(self):\n            return self.value\n\n    class Getter:\n        def __init__(self, arg):\n            self.arg = arg\n        def get(self):\n            return self.arg\n    PINS = dummy()\n    PINS.value = EditPin(\"test\")\n    directory = sys.argv[1]\n    filename = sys.argv[2]\n    PINS.filepath = Getter(os.path.join(directory, filename))\n    PINS.latency = Getter(float(sys.argv[3]))\n    def serializer(v):\n        return str(v.get())\n    print(\"Edit in \" + filepath.get())\nelse:\n    from seamless.dtypes import serialize\n    def serializer(v):\n        return serialize(v._dtype, v.get())\n\n\nimport os, time, functools, traceback\nfrom threading import Thread, RLock\nlast_value = None\nlast_serialized_value = None\nlast_exc = None\nlast_mtime = None\n\ndef write_file(fpath):\n    global last_mtime, last_value, last_serialized_value\n    if not PINS.value.defined:\n        last_mtime = -1 #will trigger a file read\n        return\n    if last_value == PINS.value.get():\n        return\n    val = serializer(PINS.value)\n    if last_serialized_value == val:\n        return\n    with lock:\n        if last_serialized_value != val:\n            #print(\"WRITE\", val)\n            with open(fpath, \"w\", encoding=\"utf-8\") as f:\n                f.write(val)\n                last_value = PINS.value.get()\n                last_serialized_value = val\n            last_time = time.time()\n            try:\n                stat = os.stat(fpath)\n                last_mtime = stat.st_mtime\n            except:\n                pass\n\ndef poll():\n    global last_time, last_mtime, last_value, last_serialized_value, last_exc\n    fpath = PINS.filepath.get()\n    while 1:\n        time.sleep(PINS.latency.get())\n        curr_time = time.time()\n        last_time = curr_time\n        if not os.path.exists(fpath):\n            try:\n                write_file(fpath)\n            except:\n                exc = traceback.format_exc()\n                if exc != last_exc:\n                    print(exc)\n                    last_exc = exc\n        else:\n            with lock:\n                stat = os.stat(fpath)\n                try:\n                    if last_mtime is None or stat.st_mtime > last_mtime:\n                        data = None\n                        with open(fpath, encoding=\"utf-8\") as f:\n                            data = f.read()\n                        if data is not None:\n                            if last_serialized_value != data:\n                                #print(\"LOAD\")\n                                PINS.value.set(data)\n                                last_value = None\n                                last_serialized_value = data\n                        last_mtime = stat.st_mtime\n                except:\n                    exc = traceback.format_exc()\n                    if exc != last_exc:\n                        print(exc)\n                        last_exc = exc\n\nt = Thread(target=poll)\nt.setDaemon(True)\nlock = RLock()\nwrite_file(PINS.filepath.get())\nt.start()\n"
              },
              "cell2": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "data": "write_file(PINS.filepath.get())"
              },
              "cell3": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "data": "t.join(0)"
              },
              "ed": {
                "type": "editor",
                "mode": "sync",
                "params": {
                  "filepath": {
                    "dtype": "str",
                    "pin": "input"
                  },
                  "latency": {
                    "dtype": "float",
                    "pin": "input"
                  },
                  "value": {
                    "dtype": "text",
                    "must_be_defined": false,
                    "pin": "edit"
                  }
                }
              }
            }
          },
          "template_head": {
            "type": "context",
            "like_process": true,
            "like_cell": false,
            "pins": {
              "filepath": "links.template_head.ed.filepath",
              "latency": "links.template_head.ed.latency",
              "value": "links.template_head.ed.value"
            },
            "auto": [
              "cell1",
              "cell2",
              "cell3"
            ],
            "children": {
              "cell1": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filename": "/cell-filelink-start.py",
                  "lib": true,
                  "mode": 2
                },
                "data": "if __name__ == \"__main__\":\n    #test with ipython -i\n    import sys, os\n\n    class dummy:\n        pass\n\n    class EditPin:\n        def __init__(self, value):\n            self.value = value\n            self.defined = True\n        def set(self, value):\n            print(\"SET\", value)\n            self.value = value\n        def get(self):\n            return self.value\n\n    class Getter:\n        def __init__(self, arg):\n            self.arg = arg\n        def get(self):\n            return self.arg\n    PINS = dummy()\n    PINS.value = EditPin(\"test\")\n    directory = sys.argv[1]\n    filename = sys.argv[2]\n    PINS.filepath = Getter(os.path.join(directory, filename))\n    PINS.latency = Getter(float(sys.argv[3]))\n    def serializer(v):\n        return str(v.get())\n    print(\"Edit in \" + filepath.get())\nelse:\n    from seamless.dtypes import serialize\n    def serializer(v):\n        return serialize(v._dtype, v.get())\n\n\nimport os, time, functools, traceback\nfrom threading import Thread, RLock\nlast_value = None\nlast_serialized_value = None\nlast_exc = None\nlast_mtime = None\n\ndef write_file(fpath):\n    global last_mtime, last_value, last_serialized_value\n    if not PINS.value.defined:\n        last_mtime = -1 #will trigger a file read\n        return\n    if last_value == PINS.value.get():\n        return\n    val = serializer(PINS.value)\n    if last_serialized_value == val:\n        return\n    with lock:\n        if last_serialized_value != val:\n            #print(\"WRITE\", val)\n            with open(fpath, \"w\", encoding=\"utf-8\") as f:\n                f.write(val)\n                last_value = PINS.value.get()\n                last_serialized_value = val\n            last_time = time.time()\n            try:\n                stat = os.stat(fpath)\n                last_mtime = stat.st_mtime\n            except:\n                pass\n\ndef poll():\n    global last_time, last_mtime, last_value, last_serialized_value, last_exc\n    fpath = PINS.filepath.get()\n    while 1:\n        time.sleep(PINS.latency.get())\n        curr_time = time.time()\n        last_time = curr_time\n        if not os.path.exists(fpath):\n            try:\n                write_file(fpath)\n            except:\n                exc = traceback.format_exc()\n                if exc != last_exc:\n                    print(exc)\n                    last_exc = exc\n        else:\n            with lock:\n                stat = os.stat(fpath)\n                try:\n                    if last_mtime is None or stat.st_mtime > last_mtime:\n                        data = None\n                        with open(fpath, encoding=\"utf-8\") as f:\n                            data = f.read()\n                        if data is not None:\n                            if last_serialized_value != data:\n                                #print(\"LOAD\")\n                                PINS.value.set(data)\n                                last_value = None\n                                last_serialized_value = data\n                        last_mtime = stat.st_mtime\n                except:\n                    exc = traceback.format_exc()\n                    if exc != last_exc:\n                        print(exc)\n                        last_exc = exc\n\nt = Thread(target=poll)\nt.setDaemon(True)\nlock = RLock()\nwrite_file(PINS.filepath.get())\nt.start()\n"
              },
              "cell2": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "data": "write_file(PINS.filepath.get())"
              },
              "cell3": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "data": "t.join(0)"
              },
              "ed": {
                "type": "editor",
                "mode": "sync",
                "params": {
                  "filepath": {
                    "dtype": "str",
                    "pin": "input"
                  },
                  "latency": {
                    "dtype": "float",
                    "pin": "input"
                  },
                  "value": {
                    "dtype": "text",
                    "must_be_defined": false,
                    "pin": "edit"
                  }
                }
              }
            }
          },
          "template_html_head_body": {
            "type": "context",
            "like_process": true,
            "like_cell": false,
            "pins": {
              "filepath": "links.template_html_head_body.ed.filepath",
              "latency": "links.template_html_head_body.ed.latency",
              "value": "links.template_html_head_body.ed.value"
            },
            "auto": [
              "cell1",
              "cell2",
              "cell3"
            ],
            "children": {
              "cell1": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filename": "/cell-filelink-start.py",
                  "lib": true,
                  "mode": 2
                },
                "data": "if __name__ == \"__main__\":\n    #test with ipython -i\n    import sys, os\n\n    class dummy:\n        pass\n\n    class EditPin:\n        def __init__(self, value):\n            self.value = value\n            self.defined = True\n        def set(self, value):\n            print(\"SET\", value)\n            self.value = value\n        def get(self):\n            return self.value\n\n    class Getter:\n        def __init__(self, arg):\n            self.arg = arg\n        def get(self):\n            return self.arg\n    PINS = dummy()\n    PINS.value = EditPin(\"test\")\n    directory = sys.argv[1]\n    filename = sys.argv[2]\n    PINS.filepath = Getter(os.path.join(directory, filename))\n    PINS.latency = Getter(float(sys.argv[3]))\n    def serializer(v):\n        return str(v.get())\n    print(\"Edit in \" + filepath.get())\nelse:\n    from seamless.dtypes import serialize\n    def serializer(v):\n        return serialize(v._dtype, v.get())\n\n\nimport os, time, functools, traceback\nfrom threading import Thread, RLock\nlast_value = None\nlast_serialized_value = None\nlast_exc = None\nlast_mtime = None\n\ndef write_file(fpath):\n    global last_mtime, last_value, last_serialized_value\n    if not PINS.value.defined:\n        last_mtime = -1 #will trigger a file read\n        return\n    if last_value == PINS.value.get():\n        return\n    val = serializer(PINS.value)\n    if last_serialized_value == val:\n        return\n    with lock:\n        if last_serialized_value != val:\n            #print(\"WRITE\", val)\n            with open(fpath, \"w\", encoding=\"utf-8\") as f:\n                f.write(val)\n                last_value = PINS.value.get()\n                last_serialized_value = val\n            last_time = time.time()\n            try:\n                stat = os.stat(fpath)\n                last_mtime = stat.st_mtime\n            except:\n                pass\n\ndef poll():\n    global last_time, last_mtime, last_value, last_serialized_value, last_exc\n    fpath = PINS.filepath.get()\n    while 1:\n        time.sleep(PINS.latency.get())\n        curr_time = time.time()\n        last_time = curr_time\n        if not os.path.exists(fpath):\n            try:\n                write_file(fpath)\n            except:\n                exc = traceback.format_exc()\n                if exc != last_exc:\n                    print(exc)\n                    last_exc = exc\n        else:\n            with lock:\n                stat = os.stat(fpath)\n                try:\n                    if last_mtime is None or stat.st_mtime > last_mtime:\n                        data = None\n                        with open(fpath, encoding=\"utf-8\") as f:\n                            data = f.read()\n                        if data is not None:\n                            if last_serialized_value != data:\n                                #print(\"LOAD\")\n                                PINS.value.set(data)\n                                last_value = None\n                                last_serialized_value = data\n                        last_mtime = stat.st_mtime\n                except:\n                    exc = traceback.format_exc()\n                    if exc != last_exc:\n                        print(exc)\n                        last_exc = exc\n\nt = Thread(target=poll)\nt.setDaemon(True)\nlock = RLock()\nwrite_file(PINS.filepath.get())\nt.start()\n"
              },
              "cell2": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "data": "write_file(PINS.filepath.get())"
              },
              "cell3": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "data": "t.join(0)"
              },
              "ed": {
                "type": "editor",
                "mode": "sync",
                "params": {
                  "filepath": {
                    "dtype": "str",
                    "pin": "input"
                  },
                  "latency": {
                    "dtype": "float",
                    "pin": "input"
                  },
                  "value": {
                    "dtype": [
                      "text",
                      "html"
                    ],
                    "must_be_defined": false,
                    "pin": "edit"
                  }
                }
              }
            }
          },
          "title": {
            "type": "context",
            "like_process": true,
            "like_cell": false,
            "pins": {
              "filepath": "links.title.ed.filepath",
              "latency": "links.title.ed.latency",
              "value": "links.title.ed.value"
            },
            "auto": [
              "cell1",
              "cell2",
              "cell3"
            ],
            "children": {
              "cell1": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filename": "/cell-filelink-start.py",
                  "lib": true,
                  "mode": 2
                },
                "data": "if __name__ == \"__main__\":\n    #test with ipython -i\n    import sys, os\n\n    class dummy:\n        pass\n\n    class EditPin:\n        def __init__(self, value):\n            self.value = value\n            self.defined = True\n        def set(self, value):\n            print(\"SET\", value)\n            self.value = value\n        def get(self):\n            return self.value\n\n    class Getter:\n        def __init__(self, arg):\n            self.arg = arg\n        def get(self):\n            return self.arg\n    PINS = dummy()\n    PINS.value = EditPin(\"test\")\n    directory = sys.argv[1]\n    filename = sys.argv[2]\n    PINS.filepath = Getter(os.path.join(directory, filename))\n    PINS.latency = Getter(float(sys.argv[3]))\n    def serializer(v):\n        return str(v.get())\n    print(\"Edit in \" + filepath.get())\nelse:\n    from seamless.dtypes import serialize\n    def serializer(v):\n        return serialize(v._dtype, v.get())\n\n\nimport os, time, functools, traceback\nfrom threading import Thread, RLock\nlast_value = None\nlast_serialized_value = None\nlast_exc = None\nlast_mtime = None\n\ndef write_file(fpath):\n    global last_mtime, last_value, last_serialized_value\n    if not PINS.value.defined:\n        last_mtime = -1 #will trigger a file read\n        return\n    if last_value == PINS.value.get():\n        return\n    val = serializer(PINS.value)\n    if last_serialized_value == val:\n        return\n    with lock:\n        if last_serialized_value != val:\n            #print(\"WRITE\", val)\n            with open(fpath, \"w\", encoding=\"utf-8\") as f:\n                f.write(val)\n                last_value = PINS.value.get()\n                last_serialized_value = val\n            last_time = time.time()\n            try:\n                stat = os.stat(fpath)\n                last_mtime = stat.st_mtime\n            except:\n                pass\n\ndef poll():\n    global last_time, last_mtime, last_value, last_serialized_value, last_exc\n    fpath = PINS.filepath.get()\n    while 1:\n        time.sleep(PINS.latency.get())\n        curr_time = time.time()\n        last_time = curr_time\n        if not os.path.exists(fpath):\n            try:\n                write_file(fpath)\n            except:\n                exc = traceback.format_exc()\n                if exc != last_exc:\n                    print(exc)\n                    last_exc = exc\n        else:\n            with lock:\n                stat = os.stat(fpath)\n                try:\n                    if last_mtime is None or stat.st_mtime > last_mtime:\n                        data = None\n                        with open(fpath, encoding=\"utf-8\") as f:\n                            data = f.read()\n                        if data is not None:\n                            if last_serialized_value != data:\n                                #print(\"LOAD\")\n                                PINS.value.set(data)\n                                last_value = None\n                                last_serialized_value = data\n                        last_mtime = stat.st_mtime\n                except:\n                    exc = traceback.format_exc()\n                    if exc != last_exc:\n                        print(exc)\n                        last_exc = exc\n\nt = Thread(target=poll)\nt.setDaemon(True)\nlock = RLock()\nwrite_file(PINS.filepath.get())\nt.start()\n"
              },
              "cell2": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "data": "write_file(PINS.filepath.get())"
              },
              "cell3": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "data": "t.join(0)"
              },
              "ed": {
                "type": "editor",
                "mode": "sync",
                "params": {
                  "filepath": {
                    "dtype": "str",
                    "pin": "input"
                  },
                  "latency": {
                    "dtype": "float",
                    "pin": "input"
                  },
                  "value": {
                    "dtype": "text",
                    "must_be_defined": false,
                    "pin": "edit"
                  }
                }
              }
            }
          }
        }
      },
      "load_data_columns": {
        "type": "transformer",
        "mode": "thread",
        "params": {
          "csv": {
            "dtype": "text",
            "pin": "input"
          },
          "data": {
            "dtype": "json",
            "pin": "output"
          },
          "point_shift": {
            "dtype": "float",
            "pin": "input"
          }
        }
      },
      "params": {
        "type": "context",
        "like_process": false,
        "like_cell": false,
        "pins": {},
        "auto": [
          "cell1",
          "cell10",
          "cell11",
          "cell12",
          "cell13",
          "cell14",
          "cell15",
          "cell16",
          "cell2",
          "cell3",
          "cell4",
          "cell5",
          "cell6",
          "cell7",
          "cell8",
          "cell9"
        ],
        "children": {
          "cell1": {
            "dtype": "str",
            "data": "./params-templateer-static.cson"
          },
          "cell10": {
            "dtype": "int",
            "data": "500"
          },
          "cell11": {
            "dtype": "str",
            "data": "plotdata/plotly_data.cson"
          },
          "cell12": {
            "dtype": "float",
            "data": "0.2"
          },
          "cell13": {
            "dtype": "str",
            "data": "plotdata/layout.cson"
          },
          "cell14": {
            "dtype": "float",
            "data": "0.2"
          },
          "cell15": {
            "dtype": "str",
            "data": "plotdata/config.cson"
          },
          "cell16": {
            "dtype": "float",
            "data": "0.2"
          },
          "cell2": {
            "dtype": "float",
            "data": "0.2"
          },
          "cell3": {
            "dtype": "str",
            "data": "./template-head.jinja"
          },
          "cell4": {
            "dtype": "float",
            "data": "0.2"
          },
          "cell5": {
            "dtype": "str",
            "data": "plotdata/title.txt"
          },
          "cell6": {
            "dtype": "float",
            "data": "0.2"
          },
          "cell7": {
            "dtype": "str",
            "data": "./template-body.jinja"
          },
          "cell8": {
            "dtype": "float",
            "data": "0.2"
          },
          "cell9": {
            "dtype": "int",
            "data": "500"
          },
          "templateer_static": {
            "dtype": "cson",
            "data": "{\n  \"result\": \"head_body\",\n  \"templates\": [\n    \"body\",\n    \"head\",\n    \"head_body\"\n  ],\n  \"environment\": {\n    \"config\": \"json\",\n    \"plotly_data\": \"json\",\n    \"width\": \"int\",\n    \"layout\": \"json\",\n    \"height\": \"int\",\n    \"title\": \"text\",\n    \"divname\": \"str\"\n  }\n}"
          }
        }
      },
      "plotly_config": {
        "dtype": "cson",
        "data": "{}\n"
      },
      "plotly_data": {
        "dtype": "cson"
      },
      "plotly_layout": {
        "dtype": "cson"
      },
      "temp_body": {
        "dtype": "text"
      },
      "templateer_static": {
        "type": "context",
        "like_process": true,
        "like_cell": false,
        "pins": {
          "RESULT": "templateer_static.ed.RESULT",
          "body": "templateer_static.ed.body",
          "config": "templateer_static.ed.config",
          "divname": "templateer_static.ed.divname",
          "head": "templateer_static.ed.head",
          "head_body": "templateer_static.ed.head_body",
          "height": "templateer_static.ed.height",
          "layout": "templateer_static.ed.layout",
          "plotly_data": "templateer_static.ed.plotly_data",
          "title": "templateer_static.ed.title",
          "width": "templateer_static.ed.width"
        },
        "auto": [
          "cell1",
          "cell2",
          "cell3",
          "cell4",
          "cell5"
        ],
        "children": {
          "cell1": {
            "dtype": [
              "text",
              "html"
            ],
            "owner": "templateer_static.ed"
          },
          "cell2": {
            "dtype": "json",
            "data": "{\n  \"result\": \"head_body\",\n  \"templates\": [\n    \"body\",\n    \"head\",\n    \"head_body\"\n  ],\n  \"environment\": {\n    \"config\": \"json\",\n    \"plotly_data\": \"json\",\n    \"height\": \"int\",\n    \"layout\": \"json\",\n    \"width\": \"int\",\n    \"title\": \"text\",\n    \"divname\": \"str\"\n  }\n}"
          },
          "cell3": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "resource": {
              "filename": "/cell-templateer.py",
              "lib": true,
              "mode": 2
            },
            "data": "import jinja2, jinja2.meta\nimport json\n\nenv = {}\ndepsgraph = {}\ntemplates = []\njenv = jinja2.Environment()\n\nclass Node:\n    _ignore_deps = [\"range\"]\n    def __init__(self, name):\n        self.name = name\n        self.template = None\n        self.template_code = None\n        self.up_to_date = False\n        self.template_deps = []\n        self.env_deps = []\n        self.dependees = []\n\n    def render(self, visited=None):\n        if self.up_to_date:\n            return env[self.name]\n\n        if self.template is None:\n            raise RuntimeError(\"Cannot render template '{0}'\" % self.name)\n        if visited is None:\n            visited = []\n        if self.name in visited:\n            cycle = visited[visited.index(self.name):] + [self.name]\n            raise RuntimeError(\"Cyclic template dependency: {0}\".format(cycle))\n        visited.append(self.name)\n\n        for dep in sorted(self.template_deps):\n            #print(\"DEP\", self.name, dep)\n            depsgraph[dep].render(visited)\n        result = self.template.render(env)\n        self.up_to_date = True\n        #print(\"RENDER\", self.name)\n        env[self.name] = result\n        return result\n\n    def set_dirty(self):\n        self.up_to_date = False\n        for dependee in self.dependees:\n            depsgraph[dependee].set_dirty()\n\n    def set_template(self, template_code):\n        if template_code == self.template_code:\n            return\n        self.template_code = template_code\n        self.template = None\n        self.set_dirty()\n        ast = jenv.parse(template_code)\n        deps = jinja2.meta.find_undeclared_variables(ast)\n        new_env_deps = []\n        new_template_deps = []\n        for d in sorted(deps):\n            if d in env:\n                new_env_deps.append(d)\n            elif d in templates:\n                new_template_deps.append(d)\n            elif d in self._ignore_deps:\n                continue\n            else:\n                raise RuntimeError(\"Unknown dependency: '{0}'\".format(d))\n        self.template = jinja2.Template(ast)\n        for dep in self.template_deps + self.env_deps:\n            depsgraph[dep].dependees.remove(self.name)\n        self.env_deps = new_env_deps\n        self.template_deps = new_template_deps\n        for dep in self.template_deps  + self.env_deps:\n            depsgraph[dep].dependees.append(self.name)\n\ndef make_template():\n    global result_template\n    import jinja2\n    tempdef = PINS.TEMPLATE_DEFINITION.get()\n    if PINS.TEMPLATE_DEFINITION.updated:\n        env.clear()\n        depsgraph.clear()\n        templates[:] = tempdef[\"templates\"]\n        result_template = tempdef.get(\"result\", None)\n        if len(templates) > 1:\n            assert result_template is not None\n        else:\n            result_template = templates[0]\n        assert result_template in templates, (result_template, templates)\n\n    tempdef = PINS.TEMPLATE_DEFINITION.get()\n    environment = tempdef[\"environment\"]\n\n    env_updates = list()\n    for k, v in environment.items():\n        inp = getattr(PINS, k)\n        if inp.updated or k not in env:\n            val = inp.get()\n            if isinstance(val, (bytes, str)):\n                sval = val\n            else:\n                sval = json.dumps(val, indent=2)\n            env[k] = sval\n            env_updates.append(k)\n\n    for k in env_updates:\n        if k not in depsgraph:\n            node = Node(k)\n            node.up_to_date = True\n            depsgraph[k] = node\n        for nodename in depsgraph[k].dependees:\n            depsgraph[nodename].set_dirty()\n\n    templ_updates = []\n    for t in templates:\n        template = getattr(PINS, t)\n        if template.updated or t not in depsgraph:\n            if t not in depsgraph:\n                node = Node(t)\n                depsgraph[t] = node\n            templ_updates.append(t)\n    for t in templ_updates:\n        template = getattr(PINS, t)\n        node = depsgraph[t]\n        node.set_template(template.get())\n\n    firstnode = depsgraph[result_template]\n    result = firstnode.render()\n\n    PINS.RESULT.set(result)\n"
          },
          "cell4": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "data": "make_template()"
          },
          "cell5": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "data": ""
          },
          "ed": {
            "type": "editor",
            "mode": "sync",
            "params": {
              "RESULT": {
                "dtype": [
                  "text",
                  "html"
                ],
                "pin": "output"
              },
              "TEMPLATE_DEFINITION": {
                "dtype": "json",
                "pin": "input"
              },
              "body": {
                "dtype": "text",
                "pin": "input"
              },
              "config": {
                "dtype": "json",
                "pin": "input"
              },
              "divname": {
                "dtype": "str",
                "pin": "input"
              },
              "head": {
                "dtype": "text",
                "pin": "input"
              },
              "head_body": {
                "dtype": "text",
                "pin": "input"
              },
              "height": {
                "dtype": "int",
                "pin": "input"
              },
              "layout": {
                "dtype": "json",
                "pin": "input"
              },
              "plotly_data": {
                "dtype": "json",
                "pin": "input"
              },
              "title": {
                "dtype": "text",
                "pin": "input"
              },
              "width": {
                "dtype": "int",
                "pin": "input"
              }
            }
          }
        }
      },
      "templates": {
        "type": "context",
        "like_process": false,
        "like_cell": false,
        "pins": {},
        "auto": [
          "cell1",
          "cell2",
          "cell3",
          "cell4"
        ],
        "children": {
          "body": {
            "dtype": "text",
            "data": "<div id=\"{{divname}}\" style=\"width: {{width}}px; height: {{height}}px;\"><!-- Plotly chart will be drawn inside this DIV --></div>\n<script id=\"javascript\">\n  var data = {{plotly_data}};\n  var layout = {{layout}};\n  var config = {{config}};\n  Plotly.newPlot('{{divname}}', data, layout, config);\n</script>\n"
          },
          "cell1": {
            "dtype": "str",
            "data": "plotdata/plotly.html"
          },
          "cell2": {
            "dtype": "float",
            "data": "0.2"
          },
          "cell3": {
            "dtype": "str",
            "data": "./template-html-head-body.jinja"
          },
          "cell4": {
            "dtype": "float",
            "data": "0.2"
          },
          "head": {
            "dtype": "text",
            "data": "<script type=\"text/javascript\" src=\"plotly-latest.js\"></script>\n<!-- <script type=\"text/javascript\" src=\"plotly-latest.js\"></script> -->\n<meta charset=\"utf-8\">\n<title>{{title}}</title>\n"
          },
          "html_head_body": {
            "dtype": [
              "text",
              "html"
            ],
            "data": "<!DOCTYPE html>\n<html>\n<head>\n{{head}}\n</head>\n<body>\n{{body}}\n</body>\n</html>\n"
          }
        }
      },
      "title": {
        "dtype": "text",
        "data": ""
      }
    },
    "macro_objects": [
      {
        "args": [
          null
        ],
        "kwargs": {},
        "cell_args": {
          "template_definition": "params.templateer_static"
        },
        "macro_module_name": "seamless.lib.templateer",
        "macro_func_name": "templateer",
        "macro_order": 0,
        "target": "templateer_static"
      }
    ],
    "macro_listeners": [
      {
        "cell": "params.templateer_static",
        "macro_target": "templateer_static",
        "macro_arg": "template_definition"
      }
    ],
    "registrar_items": [],
    "registrar_listeners": [],
    "registrar_cells": [],
    "pin_cell_connections": [
      [
        "data_parser.result",
        "csv"
      ],
      [
        "generate_attrib.attrib",
        "attrib"
      ],
      [
        "generate_layout.layout",
        "plotly_layout"
      ],
      [
        "get_assembly_scheme.assembly_scheme",
        "code.cell21"
      ],
      [
        "get_axmax.axmax",
        "code.cell25"
      ],
      [
        "get_cutoff.cutoff",
        "code.cell23"
      ],
      [
        "get_tailstr.tailstr",
        "code.cell19"
      ],
      [
        "integrate_data.plotly_data",
        "plotly_data"
      ],
      [
        "load_data_columns.data",
        "data"
      ],
      [
        "templateer_static.ed.RESULT",
        "html"
      ],
      [
        "templateer_static.ed.RESULT",
        "templateer_static.cell1"
      ]
    ],
    "cell_pin_connections": [
      [
        "attrib",
        "integrate_data.attrib"
      ],
      [
        "attrib",
        "links.attrib.ed.value"
      ],
      [
        "axmax",
        "generate_layout.axmax"
      ],
      [
        "browser.cell1",
        "browser.ed.title"
      ],
      [
        "browser.cell2",
        "browser.ed.code_start"
      ],
      [
        "browser.cell3",
        "browser.ed.code_stop"
      ],
      [
        "browser.cell4",
        "browser.ed.code_update"
      ],
      [
        "code.cell10",
        "links.csv.ed.latency"
      ],
      [
        "code.cell11",
        "load_data_columns.point_shift"
      ],
      [
        "code.cell12",
        "links.data_parser_code.ed.filepath"
      ],
      [
        "code.cell13",
        "links.data_parser_code.ed.latency"
      ],
      [
        "code.cell14",
        "links.code_generate_attrib.ed.filepath"
      ],
      [
        "code.cell15",
        "links.code_generate_attrib.ed.latency"
      ],
      [
        "code.cell16",
        "links.code_generate_layout.ed.filepath"
      ],
      [
        "code.cell17",
        "links.code_generate_layout.ed.latency"
      ],
      [
        "code.cell18",
        "get_tailstr.code"
      ],
      [
        "code.cell19",
        "data_parser.tailstr"
      ],
      [
        "code.cell1",
        "links.code_integrate_data.ed.filepath"
      ],
      [
        "code.cell20",
        "get_assembly_scheme.code"
      ],
      [
        "code.cell21",
        "data_parser.assembly_scheme"
      ],
      [
        "code.cell22",
        "get_cutoff.code"
      ],
      [
        "code.cell23",
        "data_parser.cutoff"
      ],
      [
        "code.cell24",
        "get_axmax.code"
      ],
      [
        "code.cell25",
        "generate_layout.axmax"
      ],
      [
        "code.cell2",
        "links.code_integrate_data.ed.latency"
      ],
      [
        "code.cell3",
        "links.data.ed.filepath"
      ],
      [
        "code.cell4",
        "links.data.ed.latency"
      ],
      [
        "code.cell5",
        "links.attrib.ed.filepath"
      ],
      [
        "code.cell6",
        "links.attrib.ed.latency"
      ],
      [
        "code.cell7",
        "links.code_load_data_columns.ed.filepath"
      ],
      [
        "code.cell8",
        "links.code_load_data_columns.ed.latency"
      ],
      [
        "code.cell9",
        "links.csv.ed.filepath"
      ],
      [
        "code.integrate_data",
        "integrate_data.code"
      ],
      [
        "code.integrate_data",
        "links.code_integrate_data.ed.value"
      ],
      [
        "code.load_data_columns",
        "links.code_load_data_columns.ed.value"
      ],
      [
        "code.load_data_columns",
        "load_data_columns.code"
      ],
      [
        "code_generate_attrib",
        "generate_attrib.code"
      ],
      [
        "code_generate_attrib",
        "links.code_generate_attrib.ed.value"
      ],
      [
        "code_generate_layout",
        "generate_layout.code"
      ],
      [
        "code_generate_layout",
        "links.code_generate_layout.ed.value"
      ],
      [
        "csv",
        "generate_attrib.csv"
      ],
      [
        "csv",
        "links.csv.ed.value"
      ],
      [
        "csv",
        "load_data_columns.csv"
      ],
      [
        "data_parser_code",
        "data_parser.code"
      ],
      [
        "data_parser_code",
        "links.data_parser_code.ed.value"
      ],
      [
        "data",
        "integrate_data.data"
      ],
      [
        "data",
        "links.data.ed.value"
      ],
      [
        "divname",
        "templateer_static.ed.divname"
      ],
      [
        "html",
        "browser.ed.value"
      ],
      [
        "html",
        "links.html.ed.value"
      ],
      [
        "links.attrib.cell1",
        "links.attrib.ed.code_start"
      ],
      [
        "links.attrib.cell2",
        "links.attrib.ed.code_update"
      ],
      [
        "links.attrib.cell3",
        "links.attrib.ed.code_stop"
      ],
      [
        "links.code_generate_attrib.cell1",
        "links.code_generate_attrib.ed.code_start"
      ],
      [
        "links.code_generate_attrib.cell2",
        "links.code_generate_attrib.ed.code_update"
      ],
      [
        "links.code_generate_attrib.cell3",
        "links.code_generate_attrib.ed.code_stop"
      ],
      [
        "links.code_generate_layout.cell1",
        "links.code_generate_layout.ed.code_start"
      ],
      [
        "links.code_generate_layout.cell2",
        "links.code_generate_layout.ed.code_update"
      ],
      [
        "links.code_generate_layout.cell3",
        "links.code_generate_layout.ed.code_stop"
      ],
      [
        "links.code_integrate_data.cell1",
        "links.code_integrate_data.ed.code_start"
      ],
      [
        "links.code_integrate_data.cell2",
        "links.code_integrate_data.ed.code_update"
      ],
      [
        "links.code_integrate_data.cell3",
        "links.code_integrate_data.ed.code_stop"
      ],
      [
        "links.code_load_data_columns.cell1",
        "links.code_load_data_columns.ed.code_start"
      ],
      [
        "links.code_load_data_columns.cell2",
        "links.code_load_data_columns.ed.code_update"
      ],
      [
        "links.code_load_data_columns.cell3",
        "links.code_load_data_columns.ed.code_stop"
      ],
      [
        "links.csv.cell1",
        "links.csv.ed.code_start"
      ],
      [
        "links.csv.cell2",
        "links.csv.ed.code_update"
      ],
      [
        "links.csv.cell3",
        "links.csv.ed.code_stop"
      ],
      [
        "links.data.cell1",
        "links.data.ed.code_start"
      ],
      [
        "links.data.cell2",
        "links.data.ed.code_update"
      ],
      [
        "links.data.cell3",
        "links.data.ed.code_stop"
      ],
      [
        "links.data_parser_code.cell1",
        "links.data_parser_code.ed.code_start"
      ],
      [
        "links.data_parser_code.cell2",
        "links.data_parser_code.ed.code_update"
      ],
      [
        "links.data_parser_code.cell3",
        "links.data_parser_code.ed.code_stop"
      ],
      [
        "links.html.cell1",
        "links.html.ed.code_start"
      ],
      [
        "links.html.cell2",
        "links.html.ed.code_update"
      ],
      [
        "links.html.cell3",
        "links.html.ed.code_stop"
      ],
      [
        "links.params_templateer_static.cell1",
        "links.params_templateer_static.ed.code_start"
      ],
      [
        "links.params_templateer_static.cell2",
        "links.params_templateer_static.ed.code_update"
      ],
      [
        "links.params_templateer_static.cell3",
        "links.params_templateer_static.ed.code_stop"
      ],
      [
        "links.plotly_config.cell1",
        "links.plotly_config.ed.code_start"
      ],
      [
        "links.plotly_config.cell2",
        "links.plotly_config.ed.code_update"
      ],
      [
        "links.plotly_config.cell3",
        "links.plotly_config.ed.code_stop"
      ],
      [
        "links.plotly_data.cell1",
        "links.plotly_data.ed.code_start"
      ],
      [
        "links.plotly_data.cell2",
        "links.plotly_data.ed.code_update"
      ],
      [
        "links.plotly_data.cell3",
        "links.plotly_data.ed.code_stop"
      ],
      [
        "links.plotly_layout.cell1",
        "links.plotly_layout.ed.code_start"
      ],
      [
        "links.plotly_layout.cell2",
        "links.plotly_layout.ed.code_update"
      ],
      [
        "links.plotly_layout.cell3",
        "links.plotly_layout.ed.code_stop"
      ],
      [
        "links.template_body.cell1",
        "links.template_body.ed.code_start"
      ],
      [
        "links.template_body.cell2",
        "links.template_body.ed.code_update"
      ],
      [
        "links.template_body.cell3",
        "links.template_body.ed.code_stop"
      ],
      [
        "links.template_head.cell1",
        "links.template_head.ed.code_start"
      ],
      [
        "links.template_head.cell2",
        "links.template_head.ed.code_update"
      ],
      [
        "links.template_head.cell3",
        "links.template_head.ed.code_stop"
      ],
      [
        "links.template_html_head_body.cell1",
        "links.template_html_head_body.ed.code_start"
      ],
      [
        "links.template_html_head_body.cell2",
        "links.template_html_head_body.ed.code_update"
      ],
      [
        "links.template_html_head_body.cell3",
        "links.template_html_head_body.ed.code_stop"
      ],
      [
        "links.title.cell1",
        "links.title.ed.code_start"
      ],
      [
        "links.title.cell2",
        "links.title.ed.code_update"
      ],
      [
        "links.title.cell3",
        "links.title.ed.code_stop"
      ],
      [
        "params.cell10",
        "templateer_static.ed.height"
      ],
      [
        "params.cell11",
        "links.plotly_data.ed.filepath"
      ],
      [
        "params.cell12",
        "links.plotly_data.ed.latency"
      ],
      [
        "params.cell13",
        "links.plotly_layout.ed.filepath"
      ],
      [
        "params.cell14",
        "links.plotly_layout.ed.latency"
      ],
      [
        "params.cell15",
        "links.plotly_config.ed.filepath"
      ],
      [
        "params.cell16",
        "links.plotly_config.ed.latency"
      ],
      [
        "params.cell1",
        "links.params_templateer_static.ed.filepath"
      ],
      [
        "params.cell2",
        "links.params_templateer_static.ed.latency"
      ],
      [
        "params.cell3",
        "links.template_head.ed.filepath"
      ],
      [
        "params.cell4",
        "links.template_head.ed.latency"
      ],
      [
        "params.cell5",
        "links.title.ed.filepath"
      ],
      [
        "params.cell6",
        "links.title.ed.latency"
      ],
      [
        "params.cell7",
        "links.template_body.ed.filepath"
      ],
      [
        "params.cell8",
        "links.template_body.ed.latency"
      ],
      [
        "params.cell9",
        "templateer_static.ed.width"
      ],
      [
        "params.templateer_static",
        "links.params_templateer_static.ed.value"
      ],
      [
        "plotly_config",
        "links.plotly_config.ed.value"
      ],
      [
        "plotly_config",
        "templateer_static.ed.config"
      ],
      [
        "plotly_data",
        "links.plotly_data.ed.value"
      ],
      [
        "plotly_data",
        "templateer_static.ed.plotly_data"
      ],
      [
        "plotly_layout",
        "links.plotly_layout.ed.value"
      ],
      [
        "plotly_layout",
        "templateer_static.ed.layout"
      ],
      [
        "templateer_static.cell2",
        "templateer_static.ed.TEMPLATE_DEFINITION"
      ],
      [
        "templateer_static.cell3",
        "templateer_static.ed.code_start"
      ],
      [
        "templateer_static.cell4",
        "templateer_static.ed.code_update"
      ],
      [
        "templateer_static.cell5",
        "templateer_static.ed.code_stop"
      ],
      [
        "templates.body",
        "links.template_body.ed.value"
      ],
      [
        "templates.body",
        "templateer_static.ed.body"
      ],
      [
        "templates.cell1",
        "links.html.ed.filepath"
      ],
      [
        "templates.cell2",
        "links.html.ed.latency"
      ],
      [
        "templates.cell3",
        "links.template_html_head_body.ed.filepath"
      ],
      [
        "templates.cell4",
        "links.template_html_head_body.ed.latency"
      ],
      [
        "templates.head",
        "links.template_head.ed.value"
      ],
      [
        "templates.head",
        "templateer_static.ed.head"
      ],
      [
        "templates.html_head_body",
        "links.template_html_head_body.ed.value"
      ],
      [
        "templates.html_head_body",
        "templateer_static.ed.head_body"
      ],
      [
        "title",
        "links.title.ed.value"
      ],
      [
        "title",
        "templateer_static.ed.title"
      ]
    ]
  }
}
